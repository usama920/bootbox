import {
  __export,
  __publicField
} from "./chunk-Y4AOG3KG.js";

// node_modules/tw-elements/dist/src/js/util/index.js
var MAX_UID = 1e6;
var MILLISECONDS_MULTIPLIER = 1e3;
var TRANSITION_END = "transitionend";
var toType = (obj) => {
  if (obj === null || obj === void 0) {
    return `${obj}`;
  }
  return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
};
var getUID = (prefix) => {
  do {
    prefix += Math.floor(Math.random() * MAX_UID);
  } while (document.getElementById(prefix));
  return prefix;
};
var getSelector = (element2) => {
  let selector = element2.getAttribute("data-te-target");
  if (!selector || selector === "#") {
    let hrefAttr = element2.getAttribute("href");
    if (!hrefAttr || !hrefAttr.includes("#") && !hrefAttr.startsWith(".")) {
      return null;
    }
    if (hrefAttr.includes("#") && !hrefAttr.startsWith("#")) {
      hrefAttr = `#${hrefAttr.split("#")[1]}`;
    }
    selector = hrefAttr && hrefAttr !== "#" ? hrefAttr.trim() : null;
  }
  return selector;
};
var getSelectorFromElement = (element2) => {
  const selector = getSelector(element2);
  if (selector) {
    return document.querySelector(selector) ? selector : null;
  }
  return null;
};
var getElementFromSelector = (element2) => {
  const selector = getSelector(element2);
  return selector ? document.querySelector(selector) : null;
};
var getTransitionDurationFromElement = (element2) => {
  if (!element2) {
    return 0;
  }
  let { transitionDuration, transitionDelay } = window.getComputedStyle(element2);
  const floatTransitionDuration = Number.parseFloat(transitionDuration);
  const floatTransitionDelay = Number.parseFloat(transitionDelay);
  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  }
  transitionDuration = transitionDuration.split(",")[0];
  transitionDelay = transitionDelay.split(",")[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};
var triggerTransitionEnd = (element2) => {
  element2.dispatchEvent(new Event(TRANSITION_END));
};
var isElement = (obj) => {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (typeof obj.jquery !== "undefined") {
    obj = obj[0];
  }
  return typeof obj.nodeType !== "undefined";
};
var getElement = (obj) => {
  if (isElement(obj)) {
    return obj.jquery ? obj[0] : obj;
  }
  if (typeof obj === "string" && obj.length > 0) {
    return document.querySelector(obj);
  }
  return null;
};
var typeCheckConfig = (componentName, config, configTypes) => {
  Object.keys(configTypes).forEach((property) => {
    const expectedTypes = configTypes[property];
    const value = config[property];
    const valueType = value && isElement(value) ? "element" : toType(value);
    if (!new RegExp(expectedTypes).test(valueType)) {
      throw new Error(
        `${componentName.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`
      );
    }
  });
};
var isVisible = (element2) => {
  if (!element2 || element2.getClientRects().length === 0) {
    return false;
  }
  if (element2.style && element2.parentNode && element2.parentNode.style) {
    const elementStyle = getComputedStyle(element2);
    const parentNodeStyle = getComputedStyle(element2.parentNode);
    return getComputedStyle(element2).getPropertyValue("visibility") === "visible" || elementStyle.display !== "none" && parentNodeStyle.display !== "none" && elementStyle.visibility !== "hidden";
  }
  return false;
};
var isDisabled = (element2) => {
  if (!element2 || element2.nodeType !== Node.ELEMENT_NODE) {
    return true;
  }
  if (element2.classList.contains("disabled")) {
    return true;
  }
  if (typeof element2.disabled !== "undefined") {
    return element2.disabled;
  }
  return element2.hasAttribute("disabled") && element2.getAttribute("disabled") !== "false";
};
var findShadowRoot = (element2) => {
  if (!document.documentElement.attachShadow) {
    return null;
  }
  if (typeof element2.getRootNode === "function") {
    const root = element2.getRootNode();
    return root instanceof ShadowRoot ? root : null;
  }
  if (element2 instanceof ShadowRoot) {
    return element2;
  }
  if (!element2.parentNode) {
    return null;
  }
  return findShadowRoot(element2.parentNode);
};
var noop = () => function() {
};
var reflow = (element2) => {
  element2.offsetHeight;
};
var getjQuery = () => {
  const { jQuery } = window;
  if (jQuery && !document.body.hasAttribute("data-te-no-jquery")) {
    return jQuery;
  }
  return null;
};
var DOMContentLoadedCallbacks = [];
var onDOMContentLoaded = (callback) => {
  if (document.readyState === "loading") {
    if (!DOMContentLoadedCallbacks.length) {
      document.addEventListener("DOMContentLoaded", () => {
        DOMContentLoadedCallbacks.forEach((callback2) => callback2());
      });
    }
    DOMContentLoadedCallbacks.push(callback);
  } else {
    callback();
  }
};
var isRTL = () => document.documentElement.dir === "rtl";
var array = (collection) => {
  return Array.from(collection);
};
var element = (tag) => {
  return document.createElement(tag);
};
var defineJQueryPlugin = (plugin) => {
  onDOMContentLoaded(() => {
    const $2 = getjQuery();
    if ($2) {
      const name = plugin.NAME;
      const JQUERY_NO_CONFLICT = $2.fn[name];
      $2.fn[name] = plugin.jQueryInterface;
      $2.fn[name].Constructor = plugin;
      $2.fn[name].noConflict = () => {
        $2.fn[name] = JQUERY_NO_CONFLICT;
        return plugin.jQueryInterface;
      };
    }
  });
};
var execute = (callback) => {
  if (typeof callback === "function") {
    callback();
  }
};
var executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
  if (!waitForTransition) {
    execute(callback);
    return;
  }
  const durationPadding = 5;
  const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
  let called = false;
  const handler = ({ target }) => {
    if (target !== transitionElement) {
      return;
    }
    called = true;
    transitionElement.removeEventListener(TRANSITION_END, handler);
    execute(callback);
  };
  transitionElement.addEventListener(TRANSITION_END, handler);
  setTimeout(() => {
    if (!called) {
      triggerTransitionEnd(transitionElement);
    }
  }, emulatedDuration);
};
var getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
  let index = list.indexOf(activeElement);
  if (index === -1) {
    return list[!shouldGetNext && isCycleAllowed ? list.length - 1 : 0];
  }
  const listLength = list.length;
  index += shouldGetNext ? 1 : -1;
  if (isCycleAllowed) {
    index = (index + listLength) % listLength;
  }
  return list[Math.max(0, Math.min(index, listLength - 1))];
};

// node_modules/tw-elements/dist/src/js/dom/event-handler.js
var namespaceRegex = /[^.]*(?=\..*)\.|.*/;
var stripNameRegex = /\..*/;
var stripUidRegex = /::\d+$/;
var eventRegistry = {};
var uidEvent = 1;
var customEvents = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
};
var customEventsRegex = /^(mouseenter|mouseleave)/i;
var nativeEvents = /* @__PURE__ */ new Set([
  "click",
  "dblclick",
  "mouseup",
  "mousedown",
  "contextmenu",
  "mousewheel",
  "DOMMouseScroll",
  "mouseover",
  "mouseout",
  "mousemove",
  "selectstart",
  "selectend",
  "keydown",
  "keypress",
  "keyup",
  "orientationchange",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointercancel",
  "gesturestart",
  "gesturechange",
  "gestureend",
  "focus",
  "blur",
  "change",
  "reset",
  "select",
  "submit",
  "focusin",
  "focusout",
  "load",
  "unload",
  "beforeunload",
  "resize",
  "move",
  "DOMContentLoaded",
  "readystatechange",
  "error",
  "abort",
  "scroll"
]);
function getUidEvent(element2, uid) {
  return uid && `${uid}::${uidEvent++}` || element2.uidEvent || uidEvent++;
}
function getEvent(element2) {
  const uid = getUidEvent(element2);
  element2.uidEvent = uid;
  eventRegistry[uid] = eventRegistry[uid] || {};
  return eventRegistry[uid];
}
function bootstrapHandler(element2, fn2) {
  return function handler(event) {
    event.delegateTarget = element2;
    if (handler.oneOff) {
      EventHandler.off(element2, event.type, fn2);
    }
    return fn2.apply(element2, [event]);
  };
}
function bootstrapDelegationHandler(element2, selector, fn2) {
  return function handler(event) {
    const domElements = element2.querySelectorAll(selector);
    for (let { target } = event; target && target !== this; target = target.parentNode) {
      for (let i = domElements.length; i--; "") {
        if (domElements[i] === target) {
          event.delegateTarget = target;
          if (handler.oneOff) {
            EventHandler.off(element2, event.type, fn2);
          }
          return fn2.apply(target, [event]);
        }
      }
    }
    return null;
  };
}
function findHandler(events, handler, delegationSelector = null) {
  const uidEventList = Object.keys(events);
  for (let i = 0, len = uidEventList.length; i < len; i++) {
    const event = events[uidEventList[i]];
    if (event.originalHandler === handler && event.delegationSelector === delegationSelector) {
      return event;
    }
  }
  return null;
}
function normalizeParams(originalTypeEvent, handler, delegationFn) {
  const delegation = typeof handler === "string";
  const originalHandler = delegation ? delegationFn : handler;
  let typeEvent = getTypeEvent(originalTypeEvent);
  const isNative = nativeEvents.has(typeEvent);
  if (!isNative) {
    typeEvent = originalTypeEvent;
  }
  return [delegation, originalHandler, typeEvent];
}
function addHandler(element2, originalTypeEvent, handler, delegationFn, oneOff) {
  if (typeof originalTypeEvent !== "string" || !element2) {
    return;
  }
  if (!handler) {
    handler = delegationFn;
    delegationFn = null;
  }
  if (customEventsRegex.test(originalTypeEvent)) {
    const wrapFn = (fn3) => {
      return function(event) {
        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
          return fn3.call(this, event);
        }
      };
    };
    if (delegationFn) {
      delegationFn = wrapFn(delegationFn);
    } else {
      handler = wrapFn(handler);
    }
  }
  const [delegation, originalHandler, typeEvent] = normalizeParams(
    originalTypeEvent,
    handler,
    delegationFn
  );
  const events = getEvent(element2);
  const handlers2 = events[typeEvent] || (events[typeEvent] = {});
  const previousFn = findHandler(
    handlers2,
    originalHandler,
    delegation ? handler : null
  );
  if (previousFn) {
    previousFn.oneOff = previousFn.oneOff && oneOff;
    return;
  }
  const uid = getUidEvent(
    originalHandler,
    originalTypeEvent.replace(namespaceRegex, "")
  );
  const fn2 = delegation ? bootstrapDelegationHandler(element2, handler, delegationFn) : bootstrapHandler(element2, handler);
  fn2.delegationSelector = delegation ? handler : null;
  fn2.originalHandler = originalHandler;
  fn2.oneOff = oneOff;
  fn2.uidEvent = uid;
  handlers2[uid] = fn2;
  element2.addEventListener(typeEvent, fn2, delegation);
}
function removeHandler(element2, events, typeEvent, handler, delegationSelector) {
  const fn2 = findHandler(events[typeEvent], handler, delegationSelector);
  if (!fn2) {
    return;
  }
  element2.removeEventListener(typeEvent, fn2, Boolean(delegationSelector));
  delete events[typeEvent][fn2.uidEvent];
}
function removeNamespacedHandlers(element2, events, typeEvent, namespace) {
  const storeElementEvent = events[typeEvent] || {};
  Object.keys(storeElementEvent).forEach((handlerKey) => {
    if (handlerKey.includes(namespace)) {
      const event = storeElementEvent[handlerKey];
      removeHandler(
        element2,
        events,
        typeEvent,
        event.originalHandler,
        event.delegationSelector
      );
    }
  });
}
function getTypeEvent(event) {
  event = event.replace(stripNameRegex, "");
  return customEvents[event] || event;
}
var EventHandler = {
  on(element2, event, handler, delegationFn) {
    addHandler(element2, event, handler, delegationFn, false);
  },
  one(element2, event, handler, delegationFn) {
    addHandler(element2, event, handler, delegationFn, true);
  },
  off(element2, originalTypeEvent, handler, delegationFn) {
    if (typeof originalTypeEvent !== "string" || !element2) {
      return;
    }
    const [delegation, originalHandler, typeEvent] = normalizeParams(
      originalTypeEvent,
      handler,
      delegationFn
    );
    const inNamespace = typeEvent !== originalTypeEvent;
    const events = getEvent(element2);
    const isNamespace = originalTypeEvent.startsWith(".");
    if (typeof originalHandler !== "undefined") {
      if (!events || !events[typeEvent]) {
        return;
      }
      removeHandler(
        element2,
        events,
        typeEvent,
        originalHandler,
        delegation ? handler : null
      );
      return;
    }
    if (isNamespace) {
      Object.keys(events).forEach((elementEvent) => {
        removeNamespacedHandlers(
          element2,
          events,
          elementEvent,
          originalTypeEvent.slice(1)
        );
      });
    }
    const storeElementEvent = events[typeEvent] || {};
    Object.keys(storeElementEvent).forEach((keyHandlers) => {
      const handlerKey = keyHandlers.replace(stripUidRegex, "");
      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
        const event = storeElementEvent[keyHandlers];
        removeHandler(
          element2,
          events,
          typeEvent,
          event.originalHandler,
          event.delegationSelector
        );
      }
    });
  },
  trigger(element2, event, args) {
    if (typeof event !== "string" || !element2) {
      return null;
    }
    const $2 = getjQuery();
    const typeEvent = getTypeEvent(event);
    const inNamespace = event !== typeEvent;
    const isNative = nativeEvents.has(typeEvent);
    let jQueryEvent;
    let bubbles = true;
    let nativeDispatch = true;
    let defaultPrevented = false;
    let evt = null;
    if (inNamespace && $2) {
      jQueryEvent = $2.Event(event, args);
      $2(element2).trigger(jQueryEvent);
      bubbles = !jQueryEvent.isPropagationStopped();
      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
      defaultPrevented = jQueryEvent.isDefaultPrevented();
    }
    if (isNative) {
      evt = document.createEvent("HTMLEvents");
      evt.initEvent(typeEvent, bubbles, true);
    } else {
      evt = new CustomEvent(event, {
        bubbles,
        cancelable: true
      });
    }
    if (typeof args !== "undefined") {
      Object.keys(args).forEach((key) => {
        Object.defineProperty(evt, key, {
          get() {
            return args[key];
          }
        });
      });
    }
    if (defaultPrevented) {
      evt.preventDefault();
    }
    if (nativeDispatch) {
      element2.dispatchEvent(evt);
    }
    if (evt.defaultPrevented && typeof jQueryEvent !== "undefined") {
      jQueryEvent.preventDefault();
    }
    return evt;
  }
};
var EventHandlerMulti = {
  on(element2, eventsName, handler, delegationFn) {
    const events = eventsName.split(" ");
    for (let i = 0; i < events.length; i++) {
      EventHandler.on(element2, events[i], handler, delegationFn);
    }
  },
  off(element2, originalTypeEvent, handler, delegationFn) {
    const events = originalTypeEvent.split(" ");
    for (let i = 0; i < events.length; i++) {
      EventHandler.off(element2, events[i], handler, delegationFn);
    }
  }
};
var event_handler_default = EventHandler;

// node_modules/tw-elements/dist/src/js/dom/data.js
var mapData = (() => {
  const storeData = {};
  let id = 1;
  return {
    set(element2, key, data) {
      if (typeof element2[key] === "undefined") {
        element2[key] = {
          key,
          id
        };
        id++;
      }
      storeData[element2[key].id] = data;
    },
    get(element2, key) {
      if (!element2 || typeof element2[key] === "undefined") {
        return null;
      }
      const keyProperties = element2[key];
      if (keyProperties.key === key) {
        return storeData[keyProperties.id];
      }
      return null;
    },
    delete(element2, key) {
      if (typeof element2[key] === "undefined") {
        return;
      }
      const keyProperties = element2[key];
      if (keyProperties.key === key) {
        delete storeData[keyProperties.id];
        delete element2[key];
      }
    }
  };
})();
var Data = {
  setData(instance, key, data) {
    mapData.set(instance, key, data);
  },
  getData(instance, key) {
    return mapData.get(instance, key);
  },
  removeData(instance, key) {
    mapData.delete(instance, key);
  }
};
var data_default = Data;

// node_modules/tw-elements/dist/src/js/base-component.js
var VERSION = "5.1.3";
var BaseComponent = class {
  constructor(element2) {
    element2 = getElement(element2);
    if (!element2) {
      return;
    }
    this._element = element2;
    data_default.setData(this._element, this.constructor.DATA_KEY, this);
  }
  dispose() {
    data_default.removeData(this._element, this.constructor.DATA_KEY);
    event_handler_default.off(this._element, this.constructor.EVENT_KEY);
    Object.getOwnPropertyNames(this).forEach((propertyName) => {
      this[propertyName] = null;
    });
  }
  _queueCallback(callback, element2, isAnimated = true) {
    executeAfterTransition(callback, element2, isAnimated);
  }
  /** Static */
  static getInstance(element2) {
    return data_default.getData(getElement(element2), this.DATA_KEY);
  }
  static getOrCreateInstance(element2, config = {}) {
    return this.getInstance(element2) || new this(element2, typeof config === "object" ? config : null);
  }
  static get VERSION() {
    return VERSION;
  }
  static get NAME() {
    throw new Error(
      'You have to implement the static method "NAME", for each component!'
    );
  }
  static get DATA_KEY() {
    return `te.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
};
var base_component_default = BaseComponent;

// node_modules/tw-elements/dist/src/js/components/button.js
var NAME = "button";
var DATA_KEY = "bs.button";
var EVENT_KEY = `.${DATA_KEY}`;
var DATA_API_KEY = ".data-api";
var CLASS_NAME_ACTIVE = "active";
var SELECTOR_DATA_TOGGLE = '[data-te-toggle="button"]';
var EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;
var Button = class extends base_component_default {
  // Getters
  static get NAME() {
    return NAME;
  }
  // Public
  toggle() {
    this._element.setAttribute(
      "aria-pressed",
      this._element.classList.toggle(CLASS_NAME_ACTIVE)
    );
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Button.getOrCreateInstance(this);
      if (config === "toggle") {
        data[config]();
      }
    });
  }
};
event_handler_default.on(
  document,
  EVENT_CLICK_DATA_API,
  SELECTOR_DATA_TOGGLE,
  (event) => {
    event.preventDefault();
    const button = event.target.closest(SELECTOR_DATA_TOGGLE);
    const data = Button.getOrCreateInstance(button);
    data.toggle();
  }
);
defineJQueryPlugin(Button);
var button_default = Button;

// node_modules/@popperjs/core/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  afterMain: () => afterMain,
  afterRead: () => afterRead,
  afterWrite: () => afterWrite,
  applyStyles: () => applyStyles_default,
  arrow: () => arrow_default,
  auto: () => auto,
  basePlacements: () => basePlacements,
  beforeMain: () => beforeMain,
  beforeRead: () => beforeRead,
  beforeWrite: () => beforeWrite,
  bottom: () => bottom,
  clippingParents: () => clippingParents,
  computeStyles: () => computeStyles_default,
  createPopper: () => createPopper3,
  createPopperBase: () => createPopper,
  createPopperLite: () => createPopper2,
  detectOverflow: () => detectOverflow,
  end: () => end,
  eventListeners: () => eventListeners_default,
  flip: () => flip_default,
  hide: () => hide_default,
  left: () => left,
  main: () => main,
  modifierPhases: () => modifierPhases,
  offset: () => offset_default,
  placements: () => placements,
  popper: () => popper,
  popperGenerator: () => popperGenerator,
  popperOffsets: () => popperOffsets_default,
  preventOverflow: () => preventOverflow_default,
  read: () => read,
  reference: () => reference,
  right: () => right,
  start: () => start,
  top: () => top,
  variationPlacements: () => variationPlacements,
  viewport: () => viewport,
  write: () => write
});

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement2(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement2(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement2(element2) ? element2.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element2.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element2.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element2.parentNode || // DOM Element detected
    (isShadowRoot(element2) ? element2.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element2)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element2),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement2(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement2(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement2(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement2(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement2(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy2() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/tw-elements/dist/src/js/dom/manipulator.js
function normalizeData(val) {
  if (val === "true") {
    return true;
  }
  if (val === "false") {
    return false;
  }
  if (val === Number(val).toString()) {
    return Number(val);
  }
  if (val === "" || val === "null") {
    return null;
  }
  return val;
}
function normalizeDataKey(key) {
  return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
}
var Manipulator = {
  setDataAttribute(element2, key, value) {
    element2.setAttribute(`data-te-${normalizeDataKey(key)}`, value);
  },
  removeDataAttribute(element2, key) {
    element2.removeAttribute(`data-te-${normalizeDataKey(key)}`);
  },
  getDataAttributes(element2) {
    if (!element2) {
      return {};
    }
    const attributes = {};
    Object.keys(element2.dataset).filter((key) => key.startsWith("te")).forEach((key) => {
      if (key.startsWith("teClass")) {
        return;
      }
      let pureKey = key.replace(/^te/, "");
      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
      attributes[pureKey] = normalizeData(element2.dataset[key]);
    });
    return attributes;
  },
  getDataClassAttributes(element2) {
    if (!element2) {
      return {};
    }
    const attributes = {
      ...element2.dataset
    };
    Object.keys(attributes).filter((key) => key.startsWith("teClass")).forEach((key) => {
      let pureKey = key.replace(/^teClass/, "");
      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
      attributes[pureKey] = normalizeData(attributes[key]);
    });
    return attributes;
  },
  getDataAttribute(element2, key) {
    return normalizeData(
      element2.getAttribute(`data-te-${normalizeDataKey(key)}`)
    );
  },
  offset(element2) {
    const rect = element2.getBoundingClientRect();
    return {
      top: rect.top + document.body.scrollTop,
      left: rect.left + document.body.scrollLeft
    };
  },
  position(element2) {
    return {
      top: element2.offsetTop,
      left: element2.offsetLeft
    };
  },
  style(element2, style) {
    Object.assign(element2.style, style);
  },
  toggleClass(element2, classNameOrList) {
    if (!element2) {
      return;
    }
    _classNameOrListToArray(classNameOrList).forEach((className) => {
      if (element2.classList.contains(className)) {
        element2.classList.remove(className);
      } else {
        element2.classList.add(className);
      }
    });
  },
  addClass(element2, classNameOrList) {
    _classNameOrListToArray(classNameOrList).forEach(
      (className) => !element2.classList.contains(className) && element2.classList.add(className)
    );
  },
  addStyle(element2, style) {
    Object.keys(style).forEach((property) => {
      element2.style[property] = style[property];
    });
  },
  removeClass(element2, classNameOrList) {
    _classNameOrListToArray(classNameOrList).forEach(
      (className) => element2.classList.contains(className) && element2.classList.remove(className)
    );
  },
  hasClass(element2, className) {
    return element2.classList.contains(className);
  }
};
function _classNameOrListToArray(classNameOrList) {
  if (typeof classNameOrList === "string") {
    return classNameOrList.split(" ");
  } else if (Array.isArray(classNameOrList)) {
    return classNameOrList;
  }
  return false;
}
var manipulator_default = Manipulator;

// node_modules/tw-elements/dist/src/js/dom/selector-engine.js
var NODE_TEXT = 3;
var SelectorEngine = {
  closest(element2, selector) {
    return element2.closest(selector);
  },
  matches(element2, selector) {
    return element2.matches(selector);
  },
  find(selector, element2 = document.documentElement) {
    return [].concat(
      ...Element.prototype.querySelectorAll.call(element2, selector)
    );
  },
  findOne(selector, element2 = document.documentElement) {
    return Element.prototype.querySelector.call(element2, selector);
  },
  children(element2, selector) {
    const children = [].concat(...element2.children);
    return children.filter((child) => child.matches(selector));
  },
  parents(element2, selector) {
    const parents = [];
    let ancestor = element2.parentNode;
    while (ancestor && ancestor.nodeType === Node.ELEMENT_NODE && ancestor.nodeType !== NODE_TEXT) {
      if (this.matches(ancestor, selector)) {
        parents.push(ancestor);
      }
      ancestor = ancestor.parentNode;
    }
    return parents;
  },
  prev(element2, selector) {
    let previous = element2.previousElementSibling;
    while (previous) {
      if (previous.matches(selector)) {
        return [previous];
      }
      previous = previous.previousElementSibling;
    }
    return [];
  },
  next(element2, selector) {
    let next = element2.nextElementSibling;
    while (next) {
      if (this.matches(next, selector)) {
        return [next];
      }
      next = next.nextElementSibling;
    }
    return [];
  },
  focusableChildren(element2) {
    const focusables = [
      "a",
      "button",
      "input",
      "textarea",
      "select",
      "details",
      "[tabindex]",
      '[contenteditable="true"]'
    ].map((selector) => `${selector}:not([tabindex^="-"])`).join(", ");
    return this.find(focusables, element2).filter(
      (el) => !isDisabled(el) && isVisible(el)
    );
  }
};
var selector_engine_default = SelectorEngine;

// node_modules/tw-elements/dist/src/js/components/dropdown.js
var NAME2 = "dropdown";
var DATA_KEY2 = "te.dropdown";
var EVENT_KEY2 = `.${DATA_KEY2}`;
var DATA_API_KEY2 = ".data-api";
var ESCAPE_KEY = "Escape";
var SPACE_KEY = "Space";
var TAB_KEY = "Tab";
var ARROW_UP_KEY = "ArrowUp";
var ARROW_DOWN_KEY = "ArrowDown";
var RIGHT_MOUSE_BUTTON = 2;
var REGEXP_KEYDOWN = new RegExp(
  `${ARROW_UP_KEY}|${ARROW_DOWN_KEY}|${ESCAPE_KEY}`
);
var EVENT_HIDE = `hide${EVENT_KEY2}`;
var EVENT_HIDDEN = `hidden${EVENT_KEY2}`;
var EVENT_SHOW = `show${EVENT_KEY2}`;
var EVENT_SHOWN = `shown${EVENT_KEY2}`;
var EVENT_CLICK_DATA_API2 = `click${EVENT_KEY2}${DATA_API_KEY2}`;
var EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY2}${DATA_API_KEY2}`;
var EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY2}${DATA_API_KEY2}`;
var CLASS_NAME_SHOW = "show";
var CLASS_NAME_DROPUP = "dropup";
var CLASS_NAME_DROPEND = "dropend";
var CLASS_NAME_DROPSTART = "dropstart";
var SELECTOR_NAVBAR = "[data-te-navbar-ref]";
var SELECTOR_DATA_TOGGLE2 = "[data-te-dropdown-toggle-ref]";
var SELECTOR_MENU = "[data-te-dropdown-menu-ref]";
var SELECTOR_NAVBAR_NAV = "[data-te-navbar-nav-ref]";
var SELECTOR_VISIBLE_ITEMS = "[data-te-dropdown-menu-ref] [data-te-dropdown-item-ref]:not(.disabled):not(:disabled)";
var PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
var PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
var PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
var PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
var PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
var PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
var ANIMATION_FADE_IN = [{ opacity: "0" }, { opacity: "1" }];
var ANIMATION_FADE_OUT = [{ opacity: "1" }, { opacity: "0" }];
var ANIMATION_TIMING = {
  duration: 550,
  iterations: 1,
  easing: "ease",
  fill: "both"
};
var Default = {
  offset: [0, 2],
  boundary: "clippingParents",
  reference: "toggle",
  display: "dynamic",
  popperConfig: null,
  autoClose: true,
  dropdownAnimation: "on"
};
var DefaultType = {
  offset: "(array|string|function)",
  boundary: "(string|element)",
  reference: "(string|element|object)",
  display: "string",
  popperConfig: "(null|object|function)",
  autoClose: "(boolean|string)",
  dropdownAnimation: "string"
};
var Dropdown = class extends base_component_default {
  constructor(element2, config) {
    super(element2);
    this._popper = null;
    this._config = this._getConfig(config);
    this._menu = this._getMenuElement();
    this._inNavbar = this._detectNavbar();
    this._fadeOutAnimate = null;
    const isPrefersReducedMotionSet = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;
    this._animationCanPlay = this._config.dropdownAnimation === "on" && !isPrefersReducedMotionSet;
  }
  // Getters
  static get Default() {
    return Default;
  }
  static get DefaultType() {
    return DefaultType;
  }
  static get NAME() {
    return NAME2;
  }
  // Public
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (isDisabled(this._element) || this._isShown(this._menu)) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    const showEvent = event_handler_default.trigger(
      this._element,
      EVENT_SHOW,
      relatedTarget
    );
    if (showEvent.defaultPrevented) {
      return;
    }
    const parent = Dropdown.getParentFromElement(this._element);
    if (this._inNavbar) {
      manipulator_default.setDataAttribute(this._menu, "popper", "none");
    } else {
      this._createPopper(parent);
    }
    if ("ontouchstart" in document.documentElement && !parent.closest(SELECTOR_NAVBAR_NAV)) {
      [].concat(...document.body.children).forEach((elem) => event_handler_default.on(elem, "mouseover", noop));
    }
    this._element.focus();
    this._element.setAttribute("aria-expanded", true);
    this._menu.setAttribute(`data-te-dropdown-${CLASS_NAME_SHOW}`, "");
    this._animationCanPlay && this._menu.animate(ANIMATION_FADE_IN, ANIMATION_TIMING);
    this._element.setAttribute(`data-te-dropdown-${CLASS_NAME_SHOW}`, "");
    setTimeout(
      () => {
        event_handler_default.trigger(this._element, EVENT_SHOWN, relatedTarget);
      },
      this._animationCanPlay ? ANIMATION_TIMING.duration : 0
    );
  }
  hide() {
    if (isDisabled(this._element) || !this._isShown(this._menu)) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    this._completeHide(relatedTarget);
  }
  dispose() {
    if (this._popper) {
      this._popper.destroy();
    }
    super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar();
    if (this._popper) {
      this._popper.update();
    }
  }
  // Private
  _completeHide(relatedTarget) {
    if (this._fadeOutAnimate && this._fadeOutAnimate.playState === "running") {
      return;
    }
    const hideEvent = event_handler_default.trigger(
      this._element,
      EVENT_HIDE,
      relatedTarget
    );
    if (hideEvent.defaultPrevented) {
      return;
    }
    if ("ontouchstart" in document.documentElement) {
      [].concat(...document.body.children).forEach((elem) => event_handler_default.off(elem, "mouseover", noop));
    }
    if (this._animationCanPlay) {
      this._fadeOutAnimate = this._menu.animate(
        ANIMATION_FADE_OUT,
        ANIMATION_TIMING
      );
    }
    setTimeout(
      () => {
        if (this._popper) {
          this._popper.destroy();
        }
        this._menu.removeAttribute(`data-te-dropdown-${CLASS_NAME_SHOW}`);
        this._element.removeAttribute(`data-te-dropdown-${CLASS_NAME_SHOW}`);
        this._element.setAttribute("aria-expanded", "false");
        manipulator_default.removeDataAttribute(this._menu, "popper");
        event_handler_default.trigger(this._element, EVENT_HIDDEN, relatedTarget);
      },
      this._animationCanPlay ? ANIMATION_TIMING.duration : 0
    );
  }
  _getConfig(config) {
    config = {
      ...this.constructor.Default,
      ...manipulator_default.getDataAttributes(this._element),
      ...config
    };
    typeCheckConfig(NAME2, config, this.constructor.DefaultType);
    if (typeof config.reference === "object" && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== "function") {
      throw new TypeError(
        `${NAME2.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`
      );
    }
    return config;
  }
  _createPopper(parent) {
    if (typeof lib_exports === "undefined") {
      throw new TypeError(
        "Bootstrap's dropdowns require Popper (https://popper.js.org)"
      );
    }
    let referenceElement = this._element;
    if (this._config.reference === "parent") {
      referenceElement = parent;
    } else if (isElement(this._config.reference)) {
      referenceElement = getElement(this._config.reference);
    } else if (typeof this._config.reference === "object") {
      referenceElement = this._config.reference;
    }
    const popperConfig = this._getPopperConfig();
    const isDisplayStatic = popperConfig.modifiers.find(
      (modifier) => modifier.name === "applyStyles" && modifier.enabled === false
    );
    this._popper = createPopper3(
      referenceElement,
      this._menu,
      popperConfig
    );
    if (isDisplayStatic) {
      manipulator_default.setDataAttribute(this._menu, "popper", "static");
    }
  }
  _isShown(element2 = this._element) {
    return element2.dataset[`teDropdown${CLASS_NAME_SHOW.charAt(0).toUpperCase() + CLASS_NAME_SHOW.slice(1)}`] === "";
  }
  _getMenuElement() {
    return selector_engine_default.next(this._element, SELECTOR_MENU)[0];
  }
  _getPlacement() {
    const parentDropdown = this._element.parentNode;
    if (parentDropdown.dataset.teDropdownPosition === CLASS_NAME_DROPEND) {
      return PLACEMENT_RIGHT;
    }
    if (parentDropdown.dataset.teDropdownPosition === CLASS_NAME_DROPSTART) {
      return PLACEMENT_LEFT;
    }
    const isEnd = getComputedStyle(this._menu).getPropertyValue("--te-position").trim() === "end";
    if (parentDropdown.dataset.teDropdownPosition === CLASS_NAME_DROPUP) {
      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
    }
    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
  }
  _detectNavbar() {
    return this._element.closest(SELECTOR_NAVBAR) !== null;
  }
  _getOffset() {
    const { offset: offset2 } = this._config;
    if (typeof offset2 === "string") {
      return offset2.split(",").map((val) => Number.parseInt(val, 10));
    }
    if (typeof offset2 === "function") {
      return (popperData) => offset2(popperData, this._element);
    }
    return offset2;
  }
  _getPopperConfig() {
    const defaultBsPopperConfig = {
      placement: this._getPlacement(),
      modifiers: [
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }
      ]
    };
    if (this._config.display === "static") {
      defaultBsPopperConfig.modifiers = [
        {
          name: "applyStyles",
          enabled: false
        }
      ];
    }
    return {
      ...defaultBsPopperConfig,
      ...typeof this._config.popperConfig === "function" ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
    };
  }
  _selectMenuItem({ key, target }) {
    const items = selector_engine_default.find(
      SELECTOR_VISIBLE_ITEMS,
      this._menu
    ).filter(isVisible);
    if (!items.length) {
      return;
    }
    getNextActiveElement(
      items,
      target,
      key === ARROW_DOWN_KEY,
      !items.includes(target)
    ).focus();
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Dropdown.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (typeof data[config] === "undefined") {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
  static clearMenus(event) {
    if (event && (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY)) {
      return;
    }
    const toggles = selector_engine_default.find(SELECTOR_DATA_TOGGLE2);
    for (let i = 0, len = toggles.length; i < len; i++) {
      const context = Dropdown.getInstance(toggles[i]);
      if (!context || context._config.autoClose === false) {
        continue;
      }
      if (!context._isShown()) {
        continue;
      }
      const relatedTarget = {
        relatedTarget: context._element
      };
      if (event) {
        const composedPath = event.composedPath();
        const isMenuTarget = composedPath.includes(context._menu);
        if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
          continue;
        }
        if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY || /input|select|option|textarea|form/i.test(event.target.tagName))) {
          continue;
        }
        if (event.type === "click") {
          relatedTarget.clickEvent = event;
        }
      }
      context._completeHide(relatedTarget);
    }
  }
  static getParentFromElement(element2) {
    return getElementFromSelector(element2) || element2.parentNode;
  }
  static dataApiKeydownHandler(event) {
    if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY && (event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) {
      return;
    }
    const isActive = this.dataset[`teDropdown${CLASS_NAME_SHOW.charAt(0).toUpperCase() + CLASS_NAME_SHOW.slice(1)}`] === "";
    if (!isActive && event.key === ESCAPE_KEY) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    if (isDisabled(this)) {
      return;
    }
    const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE2) ? this : selector_engine_default.prev(this, SELECTOR_DATA_TOGGLE2)[0];
    const instance = Dropdown.getOrCreateInstance(getToggleButton);
    if (event.key === ESCAPE_KEY) {
      instance.hide();
      return;
    }
    if (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY) {
      if (!isActive) {
        instance.show();
      }
      instance._selectMenuItem(event);
      return;
    }
    if (!isActive || event.key === SPACE_KEY) {
      Dropdown.clearMenus();
    }
  }
};
event_handler_default.on(
  document,
  EVENT_KEYDOWN_DATA_API,
  SELECTOR_DATA_TOGGLE2,
  Dropdown.dataApiKeydownHandler
);
event_handler_default.on(
  document,
  EVENT_KEYDOWN_DATA_API,
  SELECTOR_MENU,
  Dropdown.dataApiKeydownHandler
);
event_handler_default.on(document, EVENT_CLICK_DATA_API2, Dropdown.clearMenus);
event_handler_default.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
event_handler_default.on(
  document,
  EVENT_CLICK_DATA_API2,
  SELECTOR_DATA_TOGGLE2,
  function(event) {
    event.preventDefault();
    Dropdown.getOrCreateInstance(this).toggle();
  }
);
defineJQueryPlugin(Dropdown);
var dropdown_default = Dropdown;

// node_modules/tw-elements/dist/src/js/components/collapse.js
var NAME3 = "collapse";
var DATA_KEY3 = "te.collapse";
var EVENT_KEY3 = `.${DATA_KEY3}`;
var DATA_API_KEY3 = ".data-api";
var Default2 = {
  toggle: true,
  parent: null
};
var DefaultType2 = {
  toggle: "boolean",
  parent: "(null|element)"
};
var EVENT_SHOW2 = `show${EVENT_KEY3}`;
var EVENT_SHOWN2 = `shown${EVENT_KEY3}`;
var EVENT_HIDE2 = `hide${EVENT_KEY3}`;
var EVENT_HIDDEN2 = `hidden${EVENT_KEY3}`;
var EVENT_CLICK_DATA_API3 = `click${EVENT_KEY3}${DATA_API_KEY3}`;
var ATTR_SHOW = "data-te-collapse-show";
var ATTR_COLLAPSED = "data-te-collapse-collapsed";
var ATTR_COLLAPSING = "data-te-collapse-collapsing";
var ATTR_HORIZONTAL = "data-te-collapse-horizontal";
var ATTR_COLLAPSE_ITEM = "data-te-collapse-item";
var ATTR_COLLAPSE_DEEPER_CHILDREN = `:scope [${ATTR_COLLAPSE_ITEM}] [${ATTR_COLLAPSE_ITEM}]`;
var WIDTH = "width";
var HEIGHT = "height";
var SELECTOR_DATA_ACTIVES = "[data-te-collapse-item][data-te-collapse-show], [data-te-collapse-item][data-te-collapse-collapsing]";
var SELECTOR_DATA_COLLAPSE_INIT = "[data-te-collapse-init]";
var DefaultClasses = {
  visible: "!visible",
  hidden: "hidden",
  baseTransition: "overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none",
  collapsing: "h-0 transition-[height] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none",
  collapsingHorizontal: "w-0 h-auto transition-[width] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none"
};
var DefaultClassesType = {
  visible: "string",
  hidden: "string",
  baseTransition: "string",
  collapsing: "string",
  collapsingHorizontal: "string"
};
var Collapse = class extends base_component_default {
  constructor(element2, config, classes) {
    super(element2);
    this._isTransitioning = false;
    this._config = this._getConfig(config);
    this._classes = this._getClasses(classes);
    this._triggerArray = [];
    const toggleList = selector_engine_default.find(SELECTOR_DATA_COLLAPSE_INIT);
    for (let i = 0, len = toggleList.length; i < len; i++) {
      const elem = toggleList[i];
      const selector = getSelectorFromElement(elem);
      const filterElement = selector_engine_default.find(selector).filter(
        (foundElem) => foundElem === this._element
      );
      if (selector !== null && filterElement.length) {
        this._selector = selector;
        this._triggerArray.push(elem);
      }
    }
    this._initializeChildren();
    if (!this._config.parent) {
      this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
    }
    if (this._config.toggle) {
      this.toggle();
    }
  }
  // Getters
  static get Default() {
    return Default2;
  }
  static get NAME() {
    return NAME3;
  }
  // Public
  toggle() {
    if (this._isShown()) {
      this.hide();
    } else {
      this.show();
    }
  }
  show() {
    if (this._isTransitioning || this._isShown()) {
      return;
    }
    let actives = [];
    let activesData;
    if (this._config.parent) {
      const children = selector_engine_default.find(
        ATTR_COLLAPSE_DEEPER_CHILDREN,
        this._config.parent
      );
      actives = selector_engine_default.find(
        SELECTOR_DATA_ACTIVES,
        this._config.parent
      ).filter((elem) => !children.includes(elem));
    }
    const container = selector_engine_default.findOne(this._selector);
    if (actives.length) {
      const tempActiveData = actives.find((elem) => container !== elem);
      activesData = tempActiveData ? Collapse.getInstance(tempActiveData) : null;
      if (activesData && activesData._isTransitioning) {
        return;
      }
    }
    const startEvent = event_handler_default.trigger(this._element, EVENT_SHOW2);
    if (startEvent.defaultPrevented) {
      return;
    }
    actives.forEach((elemActive) => {
      if (container !== elemActive) {
        Collapse.getOrCreateInstance(elemActive, { toggle: false }).hide();
      }
      if (!activesData) {
        data_default.setData(elemActive, DATA_KEY3, null);
      }
    });
    const dimension = this._getDimension();
    const CLASS_NAME_TRANSITION = dimension === "height" ? this._classes.collapsing : this._classes.collapsingHorizontal;
    manipulator_default.removeClass(this._element, this._classes.visible);
    manipulator_default.removeClass(this._element, this._classes.hidden);
    manipulator_default.addClass(this._element, CLASS_NAME_TRANSITION);
    this._element.removeAttribute(ATTR_COLLAPSE_ITEM);
    this._element.setAttribute(ATTR_COLLAPSING, "");
    this._element.style[dimension] = 0;
    this._addAriaAndCollapsedClass(this._triggerArray, true);
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      manipulator_default.removeClass(this._element, this._classes.hidden);
      manipulator_default.removeClass(this._element, CLASS_NAME_TRANSITION);
      manipulator_default.addClass(this._element, this._classes.visible);
      this._element.removeAttribute(ATTR_COLLAPSING);
      this._element.setAttribute(ATTR_COLLAPSE_ITEM, "");
      this._element.setAttribute(ATTR_SHOW, "");
      this._element.style[dimension] = "";
      event_handler_default.trigger(this._element, EVENT_SHOWN2);
    };
    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
    const scrollSize = `scroll${capitalizedDimension}`;
    this._queueCallback(complete, this._element, true);
    this._element.style[dimension] = `${this._element[scrollSize]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown()) {
      return;
    }
    const startEvent = event_handler_default.trigger(this._element, EVENT_HIDE2);
    if (startEvent.defaultPrevented) {
      return;
    }
    const dimension = this._getDimension();
    const CLASS_NAME_TRANSITION = dimension === "height" ? this._classes.collapsing : this._classes.collapsingHorizontal;
    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
    reflow(this._element);
    manipulator_default.addClass(this._element, CLASS_NAME_TRANSITION);
    manipulator_default.removeClass(this._element, this._classes.visible);
    manipulator_default.removeClass(this._element, this._classes.hidden);
    this._element.setAttribute(ATTR_COLLAPSING, "");
    this._element.removeAttribute(ATTR_COLLAPSE_ITEM);
    this._element.removeAttribute(ATTR_SHOW);
    const triggerArrayLength = this._triggerArray.length;
    for (let i = 0; i < triggerArrayLength; i++) {
      const trigger = this._triggerArray[i];
      const elem = getElementFromSelector(trigger);
      if (elem && !this._isShown(elem)) {
        this._addAriaAndCollapsedClass([trigger], false);
      }
    }
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      manipulator_default.removeClass(this._element, CLASS_NAME_TRANSITION);
      manipulator_default.addClass(this._element, this._classes.visible);
      manipulator_default.addClass(this._element, this._classes.hidden);
      this._element.removeAttribute(ATTR_COLLAPSING);
      this._element.setAttribute(ATTR_COLLAPSE_ITEM, "");
      event_handler_default.trigger(this._element, EVENT_HIDDEN2);
    };
    this._element.style[dimension] = "";
    this._queueCallback(complete, this._element, true);
  }
  _isShown(element2 = this._element) {
    return element2.hasAttribute(ATTR_SHOW);
  }
  // Private
  _getConfig(config) {
    config = {
      ...Default2,
      ...manipulator_default.getDataAttributes(this._element),
      ...config
    };
    config.toggle = Boolean(config.toggle);
    config.parent = getElement(config.parent);
    typeCheckConfig(NAME3, config, DefaultType2);
    return config;
  }
  _getClasses(classes) {
    const dataAttributes = manipulator_default.getDataClassAttributes(this._element);
    classes = {
      ...DefaultClasses,
      ...dataAttributes,
      ...classes
    };
    typeCheckConfig(NAME3, classes, DefaultClassesType);
    return classes;
  }
  _getDimension() {
    return this._element.hasAttribute(ATTR_HORIZONTAL) ? WIDTH : HEIGHT;
  }
  _initializeChildren() {
    if (!this._config.parent) {
      return;
    }
    const children = selector_engine_default.find(
      ATTR_COLLAPSE_DEEPER_CHILDREN,
      this._config.parent
    );
    selector_engine_default.find(SELECTOR_DATA_COLLAPSE_INIT, this._config.parent).filter((elem) => !children.includes(elem)).forEach((element2) => {
      const selected = getElementFromSelector(element2);
      if (selected) {
        this._addAriaAndCollapsedClass([element2], this._isShown(selected));
      }
    });
  }
  _addAriaAndCollapsedClass(triggerArray, isOpen) {
    if (!triggerArray.length) {
      return;
    }
    triggerArray.forEach((elem) => {
      if (isOpen) {
        elem.removeAttribute(ATTR_COLLAPSED);
      } else {
        elem.setAttribute(`${ATTR_COLLAPSED}`, "");
      }
      elem.setAttribute("aria-expanded", isOpen);
    });
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const _config = {};
      if (typeof config === "string" && /show|hide/.test(config)) {
        _config.toggle = false;
      }
      const data = Collapse.getOrCreateInstance(this, _config);
      if (typeof config === "string") {
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      }
    });
  }
};
event_handler_default.on(
  document,
  EVENT_CLICK_DATA_API3,
  SELECTOR_DATA_COLLAPSE_INIT,
  function(event) {
    if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
      event.preventDefault();
    }
    const selector = getSelectorFromElement(this);
    const selectorElements = selector_engine_default.find(selector);
    selectorElements.forEach((element2) => {
      Collapse.getOrCreateInstance(element2, { toggle: false }).toggle();
    });
  }
);
defineJQueryPlugin(Collapse);
var collapse_default = Collapse;

// node_modules/tw-elements/dist/src/js/util/scrollbar.js
var SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
var SELECTOR_STICKY_CONTENT = ".sticky-top";
var ScrollBarHelper = class {
  constructor() {
    this._element = document.body;
  }
  getWidth() {
    const documentWidth = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - documentWidth);
  }
  hide() {
    const width = this.getWidth();
    this._disableOverFlow();
    this._setElementAttributes(
      this._element,
      "paddingRight",
      (calculatedValue) => calculatedValue + width
    );
    this._setElementAttributes(
      SELECTOR_FIXED_CONTENT,
      "paddingRight",
      (calculatedValue) => calculatedValue + width
    );
    this._setElementAttributes(
      SELECTOR_STICKY_CONTENT,
      "marginRight",
      (calculatedValue) => calculatedValue - width
    );
  }
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, "overflow");
    this._element.style.overflow = "hidden";
  }
  _setElementAttributes(selector, styleProp, callback) {
    const scrollbarWidth = this.getWidth();
    const manipulationCallBack = (element2) => {
      if (element2 !== this._element && window.innerWidth > element2.clientWidth + scrollbarWidth) {
        return;
      }
      this._saveInitialAttribute(element2, styleProp);
      const calculatedValue = window.getComputedStyle(element2)[styleProp];
      element2.style[styleProp] = `${callback(
        Number.parseFloat(calculatedValue)
      )}px`;
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  reset() {
    this._resetElementAttributes(this._element, "overflow");
    this._resetElementAttributes(this._element, "paddingRight");
    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, "paddingRight");
    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, "marginRight");
  }
  _saveInitialAttribute(element2, styleProp) {
    const actualValue = element2.style[styleProp];
    if (actualValue) {
      manipulator_default.setDataAttribute(element2, styleProp, actualValue);
    }
  }
  _resetElementAttributes(selector, styleProp) {
    const manipulationCallBack = (element2) => {
      const value = manipulator_default.getDataAttribute(element2, styleProp);
      if (typeof value === "undefined") {
        element2.style.removeProperty(styleProp);
      } else {
        manipulator_default.removeDataAttribute(element2, styleProp);
        element2.style[styleProp] = value;
      }
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  _applyManipulationCallback(selector, callBack) {
    if (isElement(selector)) {
      callBack(selector);
    } else {
      selector_engine_default.find(selector, this._element).forEach(callBack);
    }
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }
};
var scrollbar_default = ScrollBarHelper;

// node_modules/tw-elements/dist/src/js/util/backdrop.js
var Default3 = {
  isVisible: true,
  // if false, we use the backdrop helper without adding any element to the dom
  isAnimated: false,
  rootElement: "body",
  // give the choice to place backdrop under different elements
  clickCallback: null,
  backdropClasses: null
};
var DefaultType3 = {
  isVisible: "boolean",
  isAnimated: "boolean",
  rootElement: "(element|string)",
  clickCallback: "(function|null)",
  backdropClasses: "(array|null)"
};
var NAME4 = "backdrop";
var EVENT_MOUSEDOWN = `mousedown.te.${NAME4}`;
var Backdrop = class {
  constructor(config) {
    this._config = this._getConfig(config);
    this._isAppended = false;
    this._element = null;
  }
  show(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._append();
    if (this._config.isAnimated) {
      reflow(this._getElement());
    }
    const backdropClasses = this._config.backdropClasses || [
      "opacity-50",
      "transition-all",
      "duration-300",
      "ease-in-out",
      "fixed",
      "top-0",
      "left-0",
      "z-[1040]",
      "bg-black",
      "w-screen",
      "h-screen"
    ];
    manipulator_default.removeClass(this._getElement(), "opacity-0");
    manipulator_default.addClass(this._getElement(), backdropClasses);
    this._element.setAttribute("data-te-backdrop-show", "");
    this._emulateAnimation(() => {
      execute(callback);
    });
  }
  hide(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._element.removeAttribute("data-te-backdrop-show");
    this._getElement().classList.add("opacity-0");
    this._getElement().classList.remove("opacity-50");
    this._emulateAnimation(() => {
      this.dispose();
      execute(callback);
    });
  }
  // Private
  _getElement() {
    if (!this._element) {
      const backdrop = document.createElement("div");
      backdrop.className = this._config.className;
      if (this._config.isAnimated) {
        backdrop.classList.add("opacity-50");
      }
      this._element = backdrop;
    }
    return this._element;
  }
  _getConfig(config) {
    config = {
      ...Default3,
      ...typeof config === "object" ? config : {}
    };
    config.rootElement = getElement(config.rootElement);
    typeCheckConfig(NAME4, config, DefaultType3);
    return config;
  }
  _append() {
    if (this._isAppended) {
      return;
    }
    this._config.rootElement.append(this._getElement());
    event_handler_default.on(this._getElement(), EVENT_MOUSEDOWN, () => {
      execute(this._config.clickCallback);
    });
    this._isAppended = true;
  }
  dispose() {
    if (!this._isAppended) {
      return;
    }
    event_handler_default.off(this._element, EVENT_MOUSEDOWN);
    this._element.remove();
    this._isAppended = false;
  }
  _emulateAnimation(callback) {
    executeAfterTransition(
      callback,
      this._getElement(),
      this._config.isAnimated
    );
  }
};
var backdrop_default = Backdrop;

// node_modules/tw-elements/dist/src/js/util/focusTrap.js
var FocusTrap = class {
  constructor(element2, options = {}, toggler) {
    this._element = element2;
    this._toggler = toggler;
    this._event = options.event || "blur";
    this._condition = options.condition || (() => true);
    this._selector = options.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex="-1"])';
    this._onlyVisible = options.onlyVisible || false;
    this._focusableElements = [];
    this._firstElement = null;
    this._lastElement = null;
    this.handler = (e) => {
      if (this._condition(e) && !e.shiftKey && e.target === this._lastElement) {
        e.preventDefault();
        this._firstElement.focus();
      } else if (this._condition(e) && e.shiftKey && e.target === this._firstElement) {
        e.preventDefault();
        this._lastElement.focus();
      }
    };
  }
  trap() {
    this._setElements();
    this._init();
    this._setFocusTrap();
  }
  disable() {
    this._focusableElements.forEach((element2) => {
      element2.removeEventListener(this._event, this.handler);
    });
    if (this._toggler) {
      this._toggler.focus();
    }
  }
  update() {
    this._setElements();
    this._setFocusTrap();
  }
  _init() {
    const handler = (e) => {
      if (!this._firstElement || e.key !== "Tab" || this._focusableElements.includes(e.target)) {
        return;
      }
      e.preventDefault();
      this._firstElement.focus();
      window.removeEventListener("keydown", handler);
    };
    window.addEventListener("keydown", handler);
  }
  _filterVisible(elements) {
    return elements.filter((el) => {
      if (!isVisible(el))
        return false;
      const ancestors = selector_engine_default.parents(el, "*");
      for (let i = 0; i < ancestors.length; i++) {
        const style = window.getComputedStyle(ancestors[i]);
        if (style && (style.display === "none" || style.visibility === "hidden"))
          return false;
      }
      return true;
    });
  }
  _setElements() {
    this._focusableElements = selector_engine_default.focusableChildren(this._element);
    if (this._onlyVisible) {
      this._focusableElements = this._filterVisible(this._focusableElements);
    }
    this._firstElement = this._focusableElements[0];
    this._lastElement = this._focusableElements[this._focusableElements.length - 1];
  }
  _setFocusTrap() {
    this._focusableElements.forEach((element2, i) => {
      if (i === this._focusableElements.length - 1 || i === 0) {
        element2.addEventListener(this._event, this.handler);
      } else {
        element2.removeEventListener(this._event, this.handler);
      }
    });
  }
};
var focusTrap_default = FocusTrap;

// node_modules/tw-elements/dist/src/js/util/component-functions.js
var enableDismissTrigger = (component, method = "hide") => {
  const clickEvent = `click.dismiss${component.EVENT_KEY}`;
  const name = component.NAME;
  event_handler_default.on(
    document,
    clickEvent,
    `[data-te-${name}-dismiss]`,
    function(event) {
      if (["A", "AREA"].includes(this.tagName)) {
        event.preventDefault();
      }
      if (isDisabled(this)) {
        return;
      }
      const target = getElementFromSelector(this) || this.closest(`.${name}`) || this.closest(`[data-te-${name}-init]`);
      const instance = component.getOrCreateInstance(target);
      instance[method]();
    }
  );
};

// node_modules/tw-elements/dist/src/js/components/offcanvas.js
var NAME5 = "offcanvas";
var DATA_KEY4 = "te.offcanvas";
var EVENT_KEY4 = `.${DATA_KEY4}`;
var DATA_API_KEY4 = ".data-api";
var EVENT_LOAD_DATA_API = `load${EVENT_KEY4}${DATA_API_KEY4}`;
var ESCAPE_KEY2 = "Escape";
var Default4 = {
  backdrop: true,
  keyboard: true,
  scroll: false
};
var DefaultType4 = {
  backdrop: "boolean",
  keyboard: "boolean",
  scroll: "boolean"
};
var CLASS_NAME_SHOW2 = "show";
var OPEN_SELECTOR = "[data-te-offcanvas-init][data-te-offcanvas-show]";
var EVENT_SHOW3 = `show${EVENT_KEY4}`;
var EVENT_SHOWN3 = `shown${EVENT_KEY4}`;
var EVENT_HIDE3 = `hide${EVENT_KEY4}`;
var EVENT_HIDDEN3 = `hidden${EVENT_KEY4}`;
var EVENT_CLICK_DATA_API4 = `click${EVENT_KEY4}${DATA_API_KEY4}`;
var EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY4}`;
var SELECTOR_DATA_TOGGLE3 = "[data-te-offcanvas-toggle]";
var Offcanvas = class extends base_component_default {
  constructor(element2, config) {
    super(element2);
    this._config = this._getConfig(config);
    this._isShown = false;
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._addEventListeners();
  }
  // Getters
  static get NAME() {
    return NAME5;
  }
  static get Default() {
    return Default4;
  }
  // Public
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown) {
      return;
    }
    const showEvent = event_handler_default.trigger(this._element, EVENT_SHOW3, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    this._element.style.visibility = "visible";
    this._backdrop.show();
    if (!this._config.scroll) {
      new scrollbar_default().hide();
    }
    this._element.removeAttribute("aria-hidden");
    this._element.setAttribute("aria-modal", true);
    this._element.setAttribute("role", "dialog");
    this._element.setAttribute(`data-te-offcanvas-${CLASS_NAME_SHOW2}`, "");
    const completeCallBack = () => {
      if (!this._config.scroll) {
        this._focustrap.trap();
      }
      event_handler_default.trigger(this._element, EVENT_SHOWN3, { relatedTarget });
    };
    this._queueCallback(completeCallBack, this._element, true);
  }
  hide() {
    if (!this._isShown) {
      return;
    }
    const hideEvent = event_handler_default.trigger(this._element, EVENT_HIDE3);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._focustrap.disable();
    this._element.blur();
    this._isShown = false;
    this._element.removeAttribute(`data-te-offcanvas-${CLASS_NAME_SHOW2}`);
    this._backdrop.hide();
    const completeCallback = () => {
      this._element.setAttribute("aria-hidden", true);
      this._element.removeAttribute("aria-modal");
      this._element.removeAttribute("role");
      this._element.style.visibility = "hidden";
      if (!this._config.scroll) {
        new scrollbar_default().reset();
      }
      event_handler_default.trigger(this._element, EVENT_HIDDEN3);
    };
    this._queueCallback(completeCallback, this._element, true);
  }
  dispose() {
    this._backdrop.dispose();
    this._focustrap.disable();
    super.dispose();
  }
  // Private
  _getConfig(config) {
    config = {
      ...Default4,
      ...manipulator_default.getDataAttributes(this._element),
      ...typeof config === "object" ? config : {}
    };
    typeCheckConfig(NAME5, config, DefaultType4);
    return config;
  }
  _initializeBackDrop() {
    return new backdrop_default({
      isVisible: this._config.backdrop,
      isAnimated: true,
      rootElement: this._element.parentNode,
      clickCallback: () => this.hide()
    });
  }
  _initializeFocusTrap() {
    return new focusTrap_default(this._element, {
      event: "keydown",
      condition: (event) => event.key === "Tab"
    });
  }
  _addEventListeners() {
    event_handler_default.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {
      if (this._config.keyboard && event.key === ESCAPE_KEY2) {
        this.hide();
      }
    });
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Offcanvas.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config](this);
    });
  }
};
event_handler_default.on(
  document,
  EVENT_CLICK_DATA_API4,
  SELECTOR_DATA_TOGGLE3,
  function(event) {
    const target = getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    event_handler_default.one(target, EVENT_HIDDEN3, () => {
      if (isVisible(this)) {
        this.focus();
      }
    });
    const allReadyOpen = selector_engine_default.findOne(OPEN_SELECTOR);
    if (allReadyOpen && allReadyOpen !== target) {
      Offcanvas.getInstance(allReadyOpen).hide();
    }
    const data = Offcanvas.getOrCreateInstance(target);
    data.toggle(this);
  }
);
event_handler_default.on(
  window,
  EVENT_LOAD_DATA_API,
  () => selector_engine_default.find(OPEN_SELECTOR).forEach(
    (el) => Offcanvas.getOrCreateInstance(el).show()
  )
);
enableDismissTrigger(Offcanvas);
defineJQueryPlugin(Offcanvas);
var offcanvas_default = Offcanvas;

// node_modules/tw-elements/dist/src/js/components/alert.js
var NAME6 = "alert";
var DATA_KEY5 = "te.alert";
var EVENT_KEY5 = `.${DATA_KEY5}`;
var EVENT_CLOSE = `close${EVENT_KEY5}`;
var EVENT_CLOSED = `closed${EVENT_KEY5}`;
var SHOW_DATA_ATTRIBUTE = "data-te-alert-show";
var SELECTOR_ALERT = "[data-te-alert-init]";
var DefaultType5 = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
};
var Default5 = {
  animation: true,
  autohide: true,
  delay: 1e3
};
var DefaultClasses2 = {
  fadeIn: "animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none",
  fadeOut: "animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none"
};
var DefaultClassesType2 = {
  fadeIn: "string",
  fadeOut: "string"
};
var Alert = class extends base_component_default {
  constructor(element2, config, classes) {
    super(element2);
    this._element = element2;
    this._config = this._getConfig(config);
    this._classes = this._getClasses(classes);
  }
  // Getters
  static get DefaultType() {
    return DefaultType5;
  }
  static get Default() {
    return Default5;
  }
  static get NAME() {
    return NAME6;
  }
  // Public
  close() {
    const closeEvent = event_handler_default.trigger(this._element, EVENT_CLOSE);
    if (closeEvent.defaultPrevented) {
      return;
    }
    let timeout = 0;
    if (this._config.animation) {
      timeout = 300;
      manipulator_default.addClass(this._element, this._classes.fadeOut);
    }
    this._element.removeAttribute(SHOW_DATA_ATTRIBUTE);
    setTimeout(() => {
      this._queueCallback(
        () => this._destroyElement(),
        this._element,
        this._config.animation
      );
    }, timeout);
  }
  show() {
    if (!this._element) {
      return;
    }
    if (this._config.autohide) {
      this._setupAutohide();
    }
    if (!this._element.hasAttribute(SHOW_DATA_ATTRIBUTE)) {
      Object.assign(this._element.style, {
        display: "block"
      });
      if (isVisible(this._element)) {
        const handler = (e) => {
          Object.assign(e.target.style, {
            display: "block"
          });
          event_handler_default.off(e.target, "animationend", handler);
        };
        this._element.setAttribute(SHOW_DATA_ATTRIBUTE, "");
        event_handler_default.on(this._element, "animationend", handler);
      }
    }
    if (this._config.animation) {
      manipulator_default.removeClass(this._element, this._classes.fadeOut);
      manipulator_default.addClass(this._element, this._classes.fadeIn);
    }
  }
  hide() {
    if (!this._element) {
      return;
    }
    if (this._element.hasAttribute(SHOW_DATA_ATTRIBUTE)) {
      this._element.removeAttribute(SHOW_DATA_ATTRIBUTE);
      const handler = (e) => {
        Object.assign(e.target.style, {
          display: "none"
        });
        if (this._timeout !== null) {
          clearTimeout(this._timeout);
          this._timeout = null;
        }
        event_handler_default.off(e.target, "animationend", handler);
      };
      event_handler_default.on(this._element, "animationend", handler);
      manipulator_default.removeClass(this._element, this._classes.fadeIn);
      manipulator_default.addClass(this._element, this._classes.fadeOut);
    }
  }
  // Private
  _getConfig(config) {
    config = {
      ...Default5,
      ...manipulator_default.getDataAttributes(this._element),
      ...typeof config === "object" && config ? config : {}
    };
    typeCheckConfig(NAME6, config, this.constructor.DefaultType);
    return config;
  }
  _getClasses(classes) {
    const dataAttributes = manipulator_default.getDataClassAttributes(this._element);
    classes = {
      ...DefaultClasses2,
      ...dataAttributes,
      ...classes
    };
    typeCheckConfig(NAME6, classes, DefaultClassesType2);
    return classes;
  }
  _setupAutohide() {
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }
  _destroyElement() {
    this._element.remove();
    event_handler_default.trigger(this._element, EVENT_CLOSED);
    this.dispose();
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Alert.getOrCreateInstance(this);
      if (typeof config !== "string") {
        return;
      }
      if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config](this);
    });
  }
};
selector_engine_default.find(SELECTOR_ALERT).forEach((alert) => {
  let instance = Alert.getInstance(alert);
  if (!instance) {
    instance = new Alert(alert);
  }
  return instance;
});
enableDismissTrigger(Alert, "close");
defineJQueryPlugin(Alert);
var alert_default = Alert;

// node_modules/tw-elements/dist/src/js/components/carousel.js
var NAME7 = "carousel";
var DATA_KEY6 = "te.carousel";
var EVENT_KEY6 = `.${DATA_KEY6}`;
var DATA_API_KEY5 = ".data-api";
var ARROW_LEFT_KEY = "ArrowLeft";
var ARROW_RIGHT_KEY = "ArrowRight";
var TOUCHEVENT_COMPAT_WAIT = 500;
var SWIPE_THRESHOLD = 40;
var Default6 = {
  interval: 5e3,
  keyboard: true,
  slide: false,
  pause: "hover",
  wrap: true,
  touch: true
};
var DefaultType6 = {
  interval: "(number|boolean)",
  keyboard: "boolean",
  slide: "(boolean|string)",
  pause: "(string|boolean)",
  wrap: "boolean",
  touch: "boolean"
};
var DefaultClasses3 = {
  pointer: "touch-pan-y",
  block: "!block",
  visible: "data-[te-carousel-fade]:opacity-100 data-[te-carousel-fade]:z-[1]",
  invisible: "data-[te-carousel-fade]:z-0 data-[te-carousel-fade]:opacity-0 data-[te-carousel-fade]:duration-0 data-[te-carousel-fade]:delay-600",
  slideRight: "translate-x-full",
  slideLeft: "-translate-x-full"
};
var DefaultClassesType3 = {
  pointer: "string",
  block: "string",
  visible: "string",
  invisible: "string",
  slideRight: "string",
  slideLeft: "string"
};
var ORDER_NEXT = "next";
var ORDER_PREV = "prev";
var DIRECTION_LEFT = "left";
var DIRECTION_RIGHT = "right";
var KEY_TO_DIRECTION = {
  [ARROW_LEFT_KEY]: DIRECTION_RIGHT,
  [ARROW_RIGHT_KEY]: DIRECTION_LEFT
};
var EVENT_SLIDE = `slide${EVENT_KEY6}`;
var EVENT_SLID = `slid${EVENT_KEY6}`;
var EVENT_KEYDOWN = `keydown${EVENT_KEY6}`;
var EVENT_MOUSEENTER = `mouseenter${EVENT_KEY6}`;
var EVENT_MOUSELEAVE = `mouseleave${EVENT_KEY6}`;
var EVENT_TOUCHSTART = `touchstart${EVENT_KEY6}`;
var EVENT_TOUCHMOVE = `touchmove${EVENT_KEY6}`;
var EVENT_TOUCHEND = `touchend${EVENT_KEY6}`;
var EVENT_POINTERDOWN = `pointerdown${EVENT_KEY6}`;
var EVENT_POINTERUP = `pointerup${EVENT_KEY6}`;
var EVENT_DRAG_START = `dragstart${EVENT_KEY6}`;
var EVENT_LOAD_DATA_API2 = `load${EVENT_KEY6}${DATA_API_KEY5}`;
var EVENT_CLICK_DATA_API5 = `click${EVENT_KEY6}${DATA_API_KEY5}`;
var ATTR_CAROUSEL = "data-te-carousel-init";
var ATTR_ACTIVE = "data-te-carousel-active";
var ATTR_SLIDE = "data-te-carousel-slide";
var ATTR_END = "data-te-carousel-item-end";
var ATTR_START = "data-te-carousel-item-start";
var ATTR_NEXT = "data-te-carousel-item-next";
var ATTR_PREV = "data-te-carousel-item-prev";
var ATTR_POINTER_EVENT = "data-te-carousel-pointer-event";
var SELECTOR_DATA_CAROUSEL_INIT = "[data-te-carousel-init]";
var SELECTOR_DATA_ACTIVE = "[data-te-carousel-active]";
var SELECTOR_DATA_ITEM = "[data-te-carousel-item]";
var SELECTOR_DATA_ACTIVE_ITEM = `${SELECTOR_DATA_ACTIVE}${SELECTOR_DATA_ITEM}`;
var SELECTOR_DATA_ITEM_IMG = `${SELECTOR_DATA_ITEM} img`;
var SELECTOR_DATA_NEXT_PREV = "[data-te-carousel-item-next], [data-te-carousel-item-prev]";
var SELECTOR_DATA_INDICATORS = "[data-te-carousel-indicators]";
var SELECTOR_INDICATOR = "[data-te-target]";
var SELECTOR_DATA_SLIDE = "[data-te-slide], [data-te-slide-to]";
var POINTER_TYPE_TOUCH = "touch";
var POINTER_TYPE_PEN = "pen";
var Carousel = class extends base_component_default {
  constructor(element2, config, classes) {
    super(element2);
    this._items = null;
    this._interval = null;
    this._activeElement = null;
    this._isPaused = false;
    this._isSliding = false;
    this.touchTimeout = null;
    this.touchStartX = 0;
    this.touchDeltaX = 0;
    this._config = this._getConfig(config);
    this._classes = this._getClasses(classes);
    this._indicatorsElement = selector_engine_default.findOne(
      SELECTOR_DATA_INDICATORS,
      this._element
    );
    this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
    this._pointerEvent = Boolean(window.PointerEvent);
    this._setActiveElementClass();
    this._addEventListeners();
  }
  // Getters
  static get Default() {
    return Default6;
  }
  static get NAME() {
    return NAME7;
  }
  // Public
  next() {
    this._slide(ORDER_NEXT);
  }
  nextWhenVisible() {
    if (!document.hidden && isVisible(this._element)) {
      this.next();
    }
  }
  prev() {
    this._slide(ORDER_PREV);
  }
  pause(event) {
    if (!event) {
      this._isPaused = true;
    }
    if (selector_engine_default.findOne(SELECTOR_DATA_NEXT_PREV, this._element)) {
      triggerTransitionEnd(this._element);
      this.cycle(true);
    }
    clearInterval(this._interval);
    this._interval = null;
  }
  cycle(event) {
    if (!event) {
      this._isPaused = false;
    }
    if (this._interval) {
      clearInterval(this._interval);
      this._interval = null;
    }
    if (this._config && this._config.interval && !this._isPaused) {
      this._updateInterval();
      this._interval = setInterval(
        (document.visibilityState ? this.nextWhenVisible : this.next).bind(
          this
        ),
        this._config.interval
      );
    }
  }
  to(index) {
    this._activeElement = selector_engine_default.findOne(
      SELECTOR_DATA_ACTIVE_ITEM,
      this._element
    );
    const activeIndex = this._getItemIndex(this._activeElement);
    if (index > this._items.length - 1 || index < 0) {
      return;
    }
    if (this._isSliding) {
      event_handler_default.one(this._element, EVENT_SLID, () => this.to(index));
      return;
    }
    if (activeIndex === index) {
      this.pause();
      this.cycle();
      return;
    }
    const order2 = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
    this._slide(order2, this._items[index]);
  }
  // Private
  _getConfig(config) {
    config = {
      ...Default6,
      ...manipulator_default.getDataAttributes(this._element),
      ...typeof config === "object" ? config : {}
    };
    typeCheckConfig(NAME7, config, DefaultType6);
    return config;
  }
  _getClasses(classes) {
    const dataAttributes = manipulator_default.getDataClassAttributes(this._element);
    classes = {
      ...DefaultClasses3,
      ...dataAttributes,
      ...classes
    };
    typeCheckConfig(NAME7, classes, DefaultClassesType3);
    return classes;
  }
  _applyInitialClasses() {
    const activeElement = selector_engine_default.findOne(
      SELECTOR_DATA_ACTIVE_ITEM,
      this._element
    );
    activeElement.classList.add(
      this._classes.block,
      ...this._classes.visible.split(" ")
    );
    this._setActiveIndicatorElement(activeElement);
  }
  _handleSwipe() {
    const absDeltax = Math.abs(this.touchDeltaX);
    if (absDeltax <= SWIPE_THRESHOLD) {
      return;
    }
    const direction = absDeltax / this.touchDeltaX;
    this.touchDeltaX = 0;
    if (!direction) {
      return;
    }
    this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);
  }
  _setActiveElementClass() {
    this._activeElement = selector_engine_default.findOne(
      SELECTOR_DATA_ACTIVE_ITEM,
      this._element
    );
    manipulator_default.addClass(this._activeElement, "hidden");
  }
  _addEventListeners() {
    if (this._config.keyboard) {
      event_handler_default.on(
        this._element,
        EVENT_KEYDOWN,
        (event) => this._keydown(event)
      );
    }
    if (this._config.pause === "hover") {
      event_handler_default.on(
        this._element,
        EVENT_MOUSEENTER,
        (event) => this.pause(event)
      );
      event_handler_default.on(
        this._element,
        EVENT_MOUSELEAVE,
        (event) => this.cycle(event)
      );
    }
    if (this._config.touch && this._touchSupported) {
      this._addTouchEventListeners();
    }
    this._applyInitialClasses();
  }
  _addTouchEventListeners() {
    const hasPointerPenTouch = (event) => {
      return this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
    };
    const start2 = (event) => {
      if (hasPointerPenTouch(event)) {
        this.touchStartX = event.clientX;
      } else if (!this._pointerEvent) {
        this.touchStartX = event.touches[0].clientX;
      }
    };
    const move = (event) => {
      this.touchDeltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this.touchStartX;
    };
    const end2 = (event) => {
      if (hasPointerPenTouch(event)) {
        this.touchDeltaX = event.clientX - this.touchStartX;
      }
      this._handleSwipe();
      if (this._config.pause === "hover") {
        this.pause();
        if (this.touchTimeout) {
          clearTimeout(this.touchTimeout);
        }
        this.touchTimeout = setTimeout(
          (event2) => this.cycle(event2),
          TOUCHEVENT_COMPAT_WAIT + this._config.interval
        );
      }
    };
    selector_engine_default.find(SELECTOR_DATA_ITEM_IMG, this._element).forEach(
      (itemImg) => {
        event_handler_default.on(
          itemImg,
          EVENT_DRAG_START,
          (event) => event.preventDefault()
        );
      }
    );
    if (this._pointerEvent) {
      event_handler_default.on(
        this._element,
        EVENT_POINTERDOWN,
        (event) => start2(event)
      );
      event_handler_default.on(this._element, EVENT_POINTERUP, (event) => end2(event));
      this._element.classList.add(this._classes.pointer);
      this._element.setAttribute(`${ATTR_POINTER_EVENT}`, "");
    } else {
      event_handler_default.on(this._element, EVENT_TOUCHSTART, (event) => start2(event));
      event_handler_default.on(this._element, EVENT_TOUCHMOVE, (event) => move(event));
      event_handler_default.on(this._element, EVENT_TOUCHEND, (event) => end2(event));
    }
  }
  _keydown(event) {
    if (/input|textarea/i.test(event.target.tagName)) {
      return;
    }
    const direction = KEY_TO_DIRECTION[event.key];
    if (direction) {
      event.preventDefault();
      this._slide(direction);
    }
  }
  _getItemIndex(element2) {
    this._items = element2 && element2.parentNode ? selector_engine_default.find(SELECTOR_DATA_ITEM, element2.parentNode) : [];
    return this._items.indexOf(element2);
  }
  _getItemByOrder(order2, activeElement) {
    const isNext = order2 === ORDER_NEXT;
    return getNextActiveElement(
      this._items,
      activeElement,
      isNext,
      this._config.wrap
    );
  }
  _triggerSlideEvent(relatedTarget, eventDirectionName) {
    const targetIndex = this._getItemIndex(relatedTarget);
    const fromIndex = this._getItemIndex(
      selector_engine_default.findOne(SELECTOR_DATA_ACTIVE_ITEM, this._element)
    );
    return event_handler_default.trigger(this._element, EVENT_SLIDE, {
      relatedTarget,
      direction: eventDirectionName,
      from: fromIndex,
      to: targetIndex
    });
  }
  _setActiveIndicatorElement(element2) {
    if (this._indicatorsElement) {
      const activeIndicator = selector_engine_default.findOne(
        SELECTOR_DATA_ACTIVE,
        this._indicatorsElement
      );
      activeIndicator.removeAttribute(ATTR_ACTIVE);
      activeIndicator.removeAttribute("aria-current");
      activeIndicator.classList.remove("!opacity-100");
      const indicators = selector_engine_default.find(
        SELECTOR_INDICATOR,
        this._indicatorsElement
      );
      for (let i = 0; i < indicators.length; i++) {
        if (Number.parseInt(
          indicators[i].getAttribute("data-te-slide-to"),
          10
        ) === this._getItemIndex(element2)) {
          indicators[i].setAttribute(`${ATTR_ACTIVE}`, "");
          indicators[i].setAttribute("aria-current", "true");
          indicators[i].classList.add("!opacity-100");
          break;
        }
      }
    }
  }
  _updateInterval() {
    const element2 = this._activeElement || selector_engine_default.findOne(SELECTOR_DATA_ACTIVE_ITEM, this._element);
    if (!element2) {
      return;
    }
    const elementInterval = Number.parseInt(
      element2.getAttribute("data-te-interval"),
      10
    );
    if (elementInterval) {
      this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
      this._config.interval = elementInterval;
    } else {
      this._config.interval = this._config.defaultInterval || this._config.interval;
    }
  }
  _slide(directionOrOrder, element2) {
    const order2 = this._directionToOrder(directionOrOrder);
    const activeElement = selector_engine_default.findOne(
      SELECTOR_DATA_ACTIVE_ITEM,
      this._element
    );
    const activeElementIndex = this._getItemIndex(activeElement);
    const nextElement = element2 || this._getItemByOrder(order2, activeElement);
    const nextElementIndex = this._getItemIndex(nextElement);
    const isCycling = Boolean(this._interval);
    const isNext = order2 === ORDER_NEXT;
    const directionalAttr = isNext ? ATTR_START : ATTR_END;
    const orderAttr = isNext ? ATTR_NEXT : ATTR_PREV;
    const eventDirectionName = this._orderToDirection(order2);
    const activeClass = directionalAttr === ATTR_START ? this._classes.slideLeft : this._classes.slideRight;
    const nextClass = directionalAttr !== ATTR_START ? this._classes.slideLeft : this._classes.slideRight;
    if (nextElement && nextElement.hasAttribute(ATTR_ACTIVE)) {
      this._isSliding = false;
      return;
    }
    if (this._isSliding) {
      return;
    }
    const slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);
    if (slideEvent.defaultPrevented) {
      return;
    }
    if (!activeElement || !nextElement) {
      return;
    }
    this._isSliding = true;
    if (isCycling) {
      this.pause();
    }
    this._setActiveIndicatorElement(nextElement);
    this._activeElement = nextElement;
    const triggerSlidEvent = () => {
      event_handler_default.trigger(this._element, EVENT_SLID, {
        relatedTarget: nextElement,
        direction: eventDirectionName,
        from: activeElementIndex,
        to: nextElementIndex
      });
    };
    if (this._element.hasAttribute(ATTR_SLIDE)) {
      nextElement.setAttribute(`${orderAttr}`, "");
      nextElement.classList.add(this._classes.block, nextClass);
      reflow(nextElement);
      activeElement.setAttribute(`${directionalAttr}`, "");
      activeElement.classList.add(
        activeClass,
        ...this._classes.invisible.split(" ")
      );
      activeElement.classList.remove(...this._classes.visible.split(" "));
      nextElement.setAttribute(`${directionalAttr}`, "");
      nextElement.classList.add(...this._classes.visible.split(" "));
      nextElement.classList.remove(
        this._classes.slideRight,
        this._classes.slideLeft
      );
      const completeCallBack = () => {
        nextElement.removeAttribute(directionalAttr);
        nextElement.removeAttribute(orderAttr);
        nextElement.setAttribute(`${ATTR_ACTIVE}`, "");
        activeElement.removeAttribute(ATTR_ACTIVE);
        activeElement.classList.remove(
          activeClass,
          ...this._classes.invisible.split(" "),
          this._classes.block
        );
        activeElement.removeAttribute(orderAttr);
        activeElement.removeAttribute(directionalAttr);
        this._isSliding = false;
        setTimeout(triggerSlidEvent, 0);
      };
      this._queueCallback(completeCallBack, activeElement, true);
    } else {
      activeElement.removeAttribute(ATTR_ACTIVE);
      activeElement.classList.remove(this._classes.block);
      nextElement.setAttribute(`${ATTR_ACTIVE}`, "");
      nextElement.classList.add(this._classes.block);
      this._isSliding = false;
      triggerSlidEvent();
    }
    if (isCycling) {
      this.cycle();
    }
  }
  _directionToOrder(direction) {
    if (![DIRECTION_RIGHT, DIRECTION_LEFT].includes(direction)) {
      return direction;
    }
    if (isRTL()) {
      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
    }
    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
  }
  _orderToDirection(order2) {
    if (![ORDER_NEXT, ORDER_PREV].includes(order2)) {
      return order2;
    }
    if (isRTL()) {
      return order2 === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return order2 === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
  }
  // Static
  static carouselInterface(element2, config) {
    const data = Carousel.getOrCreateInstance(element2, config);
    let { _config } = data;
    if (typeof config === "object") {
      _config = {
        ..._config,
        ...config
      };
    }
    const action = typeof config === "string" ? config : _config.slide;
    if (typeof config === "number") {
      data.to(config);
    } else if (typeof action === "string") {
      if (typeof data[action] === "undefined") {
        throw new TypeError(`No method named "${action}"`);
      }
      data[action]();
    } else if (_config.interval && _config.carouselInit === null) {
      data.pause();
      data.cycle();
    }
  }
  static jQueryInterface(config) {
    return this.each(function() {
      Carousel.carouselInterface(this, config);
    });
  }
  static dataApiClickHandler(event) {
    const target = getElementFromSelector(this);
    if (!target || !target.hasAttribute(ATTR_CAROUSEL)) {
      return;
    }
    const config = {
      ...manipulator_default.getDataAttributes(target),
      ...manipulator_default.getDataAttributes(this)
    };
    const slideIndex = this.getAttribute("data-te-slide-to");
    if (slideIndex) {
      config.interval = false;
    }
    Carousel.carouselInterface(target, config);
    if (slideIndex) {
      Carousel.getInstance(target).to(slideIndex);
    }
    event.preventDefault();
  }
};
event_handler_default.on(
  document,
  EVENT_CLICK_DATA_API5,
  SELECTOR_DATA_SLIDE,
  Carousel.dataApiClickHandler
);
event_handler_default.on(window, EVENT_LOAD_DATA_API2, () => {
  const carousels = selector_engine_default.find(SELECTOR_DATA_CAROUSEL_INIT);
  for (let i = 0, len = carousels.length; i < len; i++) {
    Carousel.carouselInterface(
      carousels[i],
      Carousel.getInstance(carousels[i])
    );
  }
});
defineJQueryPlugin(Carousel);
var carousel_default = Carousel;

// node_modules/tw-elements/dist/src/js/components/modal.js
var NAME8 = "modal";
var DATA_KEY7 = "te.modal";
var EVENT_KEY7 = `.${DATA_KEY7}`;
var DATA_API_KEY6 = ".data-api";
var ESCAPE_KEY3 = "Escape";
var Default7 = {
  backdrop: true,
  keyboard: true,
  focus: true
};
var DefaultType7 = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  focus: "boolean"
};
var DefaultClasses4 = {
  show: "transform-none",
  static: "scale-[1.02]",
  staticProperties: "transition-scale duration-300 ease-in-out"
};
var DefaultClassesType4 = {
  show: "string",
  static: "string",
  staticProperties: "string"
};
var EVENT_HIDE4 = `hide${EVENT_KEY7}`;
var EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY7}`;
var EVENT_HIDDEN4 = `hidden${EVENT_KEY7}`;
var EVENT_SHOW4 = `show${EVENT_KEY7}`;
var EVENT_SHOWN4 = `shown${EVENT_KEY7}`;
var EVENT_RESIZE = `resize${EVENT_KEY7}`;
var EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY7}`;
var EVENT_KEYDOWN_DISMISS2 = `keydown.dismiss${EVENT_KEY7}`;
var EVENT_MOUSEUP_DISMISS = `mouseup.dismiss${EVENT_KEY7}`;
var EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY7}`;
var EVENT_CLICK_DATA_API6 = `click${EVENT_KEY7}${DATA_API_KEY6}`;
var OPEN_SELECTOR_BODY = "data-te-modal-open";
var OPEN_SELECTOR2 = "data-te-open";
var SELECTOR_DIALOG = "[data-te-modal-dialog-ref]";
var SELECTOR_MODAL_BODY = "[data-te-modal-body-ref]";
var SELECTOR_DATA_TOGGLE4 = '[data-te-toggle="modal"]';
var Modal = class extends base_component_default {
  constructor(element2, config, classes) {
    super(element2);
    this._config = this._getConfig(config);
    this._classes = this._getClasses(classes);
    this._dialog = selector_engine_default.findOne(SELECTOR_DIALOG, this._element);
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._isShown = false;
    this._ignoreBackdropClick = false;
    this._isTransitioning = false;
    this._scrollBar = new scrollbar_default();
  }
  // Getters
  static get Default() {
    return Default7;
  }
  static get NAME() {
    return NAME8;
  }
  // Public
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown || this._isTransitioning) {
      return;
    }
    const showEvent = event_handler_default.trigger(this._element, EVENT_SHOW4, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    if (this._isAnimated()) {
      this._isTransitioning = true;
    }
    this._scrollBar.hide();
    document.body.setAttribute(OPEN_SELECTOR_BODY, "true");
    this._adjustDialog();
    this._setEscapeEvent();
    this._setResizeEvent();
    event_handler_default.on(this._dialog, EVENT_MOUSEDOWN_DISMISS, () => {
      event_handler_default.one(this._element, EVENT_MOUSEUP_DISMISS, (event) => {
        if (event.target === this._element) {
          this._ignoreBackdropClick = true;
        }
      });
    });
    this._showBackdrop(() => this._showElement(relatedTarget));
  }
  hide() {
    if (!this._isShown || this._isTransitioning) {
      return;
    }
    const hideEvent = event_handler_default.trigger(this._element, EVENT_HIDE4);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._isShown = false;
    const isAnimated = this._isAnimated();
    if (isAnimated) {
      this._isTransitioning = true;
    }
    this._setEscapeEvent();
    this._setResizeEvent();
    this._focustrap.disable();
    const modalDialog = selector_engine_default.findOne(SELECTOR_DIALOG, this._element);
    modalDialog.classList.remove(this._classes.show);
    event_handler_default.off(this._element, EVENT_CLICK_DISMISS);
    event_handler_default.off(this._dialog, EVENT_MOUSEDOWN_DISMISS);
    this._queueCallback(() => this._hideModal(), this._element, isAnimated);
    this._element.removeAttribute(OPEN_SELECTOR2);
  }
  dispose() {
    [window, this._dialog].forEach(
      (htmlElement) => event_handler_default.off(htmlElement, EVENT_KEY7)
    );
    this._backdrop.dispose();
    this._focustrap.disable();
    super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }
  // Private
  _initializeBackDrop() {
    return new backdrop_default({
      isVisible: Boolean(this._config.backdrop),
      // 'static' option will be translated to true, and booleans will keep their value
      isAnimated: this._isAnimated()
    });
  }
  _initializeFocusTrap() {
    return new focusTrap_default(this._element, {
      event: "keydown",
      condition: (event) => event.key === "Tab"
    });
  }
  _getConfig(config) {
    config = {
      ...Default7,
      ...manipulator_default.getDataAttributes(this._element),
      ...typeof config === "object" ? config : {}
    };
    typeCheckConfig(NAME8, config, DefaultType7);
    return config;
  }
  _getClasses(classes) {
    const dataAttributes = manipulator_default.getDataClassAttributes(this._element);
    classes = {
      ...DefaultClasses4,
      ...dataAttributes,
      ...classes
    };
    typeCheckConfig(NAME8, classes, DefaultClassesType4);
    return classes;
  }
  _showElement(relatedTarget) {
    const isAnimated = this._isAnimated();
    const modalBody = selector_engine_default.findOne(SELECTOR_MODAL_BODY, this._dialog);
    if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
      document.body.append(this._element);
    }
    this._element.style.display = "block";
    this._element.classList.remove("hidden");
    this._element.removeAttribute("aria-hidden");
    this._element.setAttribute("aria-modal", true);
    this._element.setAttribute("role", "dialog");
    this._element.setAttribute(`${OPEN_SELECTOR2}`, "true");
    this._element.scrollTop = 0;
    const modalDialog = selector_engine_default.findOne(SELECTOR_DIALOG, this._element);
    modalDialog.classList.add(this._classes.show);
    modalDialog.classList.remove("opacity-0");
    modalDialog.classList.add("opacity-100");
    if (modalBody) {
      modalBody.scrollTop = 0;
    }
    if (isAnimated) {
      reflow(this._element);
    }
    const transitionComplete = () => {
      if (this._config.focus) {
        this._focustrap.trap();
      }
      this._isTransitioning = false;
      event_handler_default.trigger(this._element, EVENT_SHOWN4, {
        relatedTarget
      });
    };
    this._queueCallback(transitionComplete, this._dialog, isAnimated);
  }
  _setEscapeEvent() {
    if (this._isShown) {
      event_handler_default.on(document, EVENT_KEYDOWN_DISMISS2, (event) => {
        if (this._config.keyboard && event.key === ESCAPE_KEY3) {
          event.preventDefault();
          this.hide();
        } else if (!this._config.keyboard && event.key === ESCAPE_KEY3) {
          this._triggerBackdropTransition();
        }
      });
    } else {
      event_handler_default.off(this._element, EVENT_KEYDOWN_DISMISS2);
    }
  }
  _setResizeEvent() {
    if (this._isShown) {
      event_handler_default.on(window, EVENT_RESIZE, () => this._adjustDialog());
    } else {
      event_handler_default.off(window, EVENT_RESIZE);
    }
  }
  _hideModal() {
    const modalDialog = selector_engine_default.findOne(SELECTOR_DIALOG, this._element);
    modalDialog.classList.remove(this._classes.show);
    modalDialog.classList.remove("opacity-100");
    modalDialog.classList.add("opacity-0");
    setTimeout(() => {
      this._element.style.display = "none";
    }, 300);
    this._element.setAttribute("aria-hidden", true);
    this._element.removeAttribute("aria-modal");
    this._element.removeAttribute("role");
    this._isTransitioning = false;
    this._backdrop.hide(() => {
      document.body.removeAttribute(OPEN_SELECTOR_BODY);
      this._resetAdjustments();
      this._scrollBar.reset();
      event_handler_default.trigger(this._element, EVENT_HIDDEN4);
    });
  }
  _showBackdrop(callback) {
    event_handler_default.on(this._element, EVENT_CLICK_DISMISS, (event) => {
      if (this._ignoreBackdropClick) {
        this._ignoreBackdropClick = false;
        return;
      }
      if (event.target !== event.currentTarget) {
        return;
      }
      if (this._config.backdrop === true) {
        this.hide();
      } else if (this._config.backdrop === "static") {
        this._triggerBackdropTransition();
      }
    });
    this._backdrop.show(callback);
  }
  _isAnimated() {
    const animate = selector_engine_default.findOne(SELECTOR_DIALOG, this._element);
    return !!animate;
  }
  _triggerBackdropTransition() {
    const hideEvent = event_handler_default.trigger(this._element, EVENT_HIDE_PREVENTED);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const { classList, scrollHeight, style } = this._element;
    const isModalOverflowing = scrollHeight > document.documentElement.clientHeight;
    if (!isModalOverflowing && style.overflowY === "hidden" || classList.contains(this._classes.static)) {
      return;
    }
    if (!isModalOverflowing) {
      style.overflowY = "hidden";
    }
    classList.add(...this._classes.static.split(" "));
    classList.add(...this._classes.staticProperties.split(" "));
    this._queueCallback(() => {
      classList.remove(this._classes.static);
      setTimeout(() => {
        classList.remove(...this._classes.staticProperties.split(" "));
      }, 300);
      if (!isModalOverflowing) {
        this._queueCallback(() => {
          style.overflowY = "";
        }, this._dialog);
      }
    }, this._dialog);
    this._element.focus();
  }
  // ----------------------------------------------------------------------
  // the following methods are used to handle overflowing modals
  // ----------------------------------------------------------------------
  _adjustDialog() {
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const scrollbarWidth = this._scrollBar.getWidth();
    const isBodyOverflowing = scrollbarWidth > 0;
    if (!isBodyOverflowing && isModalOverflowing && !isRTL() || isBodyOverflowing && !isModalOverflowing && isRTL()) {
      this._element.style.paddingLeft = `${scrollbarWidth}px`;
    }
    if (isBodyOverflowing && !isModalOverflowing && !isRTL() || !isBodyOverflowing && isModalOverflowing && isRTL()) {
      this._element.style.paddingRight = `${scrollbarWidth}px`;
    }
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = "";
    this._element.style.paddingRight = "";
  }
  // Static
  static jQueryInterface(config, relatedTarget) {
    return this.each(function() {
      const data = Modal.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (typeof data[config] === "undefined") {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config](relatedTarget);
    });
  }
};
event_handler_default.on(
  document,
  EVENT_CLICK_DATA_API6,
  SELECTOR_DATA_TOGGLE4,
  function(event) {
    const target = getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    event_handler_default.one(target, EVENT_SHOW4, (showEvent) => {
      if (showEvent.defaultPrevented) {
        return;
      }
      event_handler_default.one(target, EVENT_HIDDEN4, () => {
        if (isVisible(this)) {
          this.focus();
        }
      });
    });
    const allReadyOpen = selector_engine_default.findOne(`[${OPEN_SELECTOR2}="true"]`);
    if (allReadyOpen) {
      Modal.getInstance(allReadyOpen).hide();
    }
    const data = Modal.getOrCreateInstance(target);
    data.toggle(this);
  }
);
enableDismissTrigger(Modal);
defineJQueryPlugin(Modal);
var modal_default = Modal;

// node_modules/tw-elements/dist/src/js/util/sanitizer.js
var uriAttributes = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]);
var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
var allowedAttribute = (attribute, allowedAttributeList) => {
  const attributeName = attribute.nodeName.toLowerCase();
  if (allowedAttributeList.includes(attributeName)) {
    if (uriAttributes.has(attributeName)) {
      return Boolean(
        SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue)
      );
    }
    return true;
  }
  const regExp = allowedAttributeList.filter(
    (attributeRegex) => attributeRegex instanceof RegExp
  );
  for (let i = 0, len = regExp.length; i < len; i++) {
    if (regExp[i].test(attributeName)) {
      return true;
    }
  }
  return false;
};
var DefaultAllowlist = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
function sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {
  if (!unsafeHtml.length) {
    return unsafeHtml;
  }
  if (sanitizeFn && typeof sanitizeFn === "function") {
    return sanitizeFn(unsafeHtml);
  }
  const domParser = new window.DOMParser();
  const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
  const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
  for (let i = 0, len = elements.length; i < len; i++) {
    const element2 = elements[i];
    const elementName = element2.nodeName.toLowerCase();
    if (!Object.keys(allowList).includes(elementName)) {
      element2.remove();
      continue;
    }
    const attributeList = [].concat(...element2.attributes);
    const allowedAttributes = [].concat(
      allowList["*"] || [],
      allowList[elementName] || []
    );
    attributeList.forEach((attribute) => {
      if (!allowedAttribute(attribute, allowedAttributes)) {
        element2.removeAttribute(attribute.nodeName);
      }
    });
  }
  return createdDocument.body.innerHTML;
}

// node_modules/tw-elements/dist/src/js/components/tooltip.js
var NAME9 = "tooltip";
var DATA_KEY8 = "te.tooltip";
var EVENT_KEY8 = `.${DATA_KEY8}`;
var CLASS_PREFIX = "te-tooltip";
var DISALLOWED_ATTRIBUTES = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]);
var DefaultType8 = {
  animation: "boolean",
  template: "string",
  title: "(string|element|function)",
  trigger: "string",
  delay: "(number|object)",
  html: "boolean",
  selector: "(string|boolean)",
  placement: "(string|function)",
  offset: "(array|string|function)",
  container: "(string|element|boolean)",
  fallbackPlacements: "array",
  boundary: "(string|element)",
  customClass: "(string|function)",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  allowList: "object",
  popperConfig: "(null|object|function)"
};
var AttachmentMap = {
  AUTO: "auto",
  TOP: "top",
  RIGHT: isRTL() ? "left" : "right",
  BOTTOM: "bottom",
  LEFT: isRTL() ? "right" : "left"
};
var Default8 = {
  animation: true,
  template: '<div class="opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal" role="tooltip"><div data-te-tooltip-inner-ref class="tooltip-inner max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded"></div></div>',
  trigger: "hover focus",
  title: "",
  delay: 0,
  html: false,
  selector: false,
  placement: "top",
  offset: [0, 0],
  container: false,
  fallbackPlacements: ["top", "right", "bottom", "left"],
  boundary: "clippingParents",
  customClass: "",
  sanitize: true,
  sanitizeFn: null,
  allowList: DefaultAllowlist,
  popperConfig: null
};
var Event2 = {
  HIDE: `hide${EVENT_KEY8}`,
  HIDDEN: `hidden${EVENT_KEY8}`,
  SHOW: `show${EVENT_KEY8}`,
  SHOWN: `shown${EVENT_KEY8}`,
  INSERTED: `inserted${EVENT_KEY8}`,
  CLICK: `click${EVENT_KEY8}`,
  FOCUSIN: `focusin${EVENT_KEY8}`,
  FOCUSOUT: `focusout${EVENT_KEY8}`,
  MOUSEENTER: `mouseenter${EVENT_KEY8}`,
  MOUSELEAVE: `mouseleave${EVENT_KEY8}`
};
var CLASS_NAME_FADE = "fade";
var CLASS_NAME_MODAL = "modal";
var CLASS_NAME_SHOW3 = "show";
var HOVER_STATE_SHOW = "show";
var HOVER_STATE_OUT = "out";
var SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
var SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
var EVENT_MODAL_HIDE = "hide.te.modal";
var TRIGGER_HOVER = "hover";
var TRIGGER_FOCUS = "focus";
var TRIGGER_CLICK = "click";
var TRIGGER_MANUAL = "manual";
var Tooltip = class extends base_component_default {
  constructor(element2, config) {
    if (typeof lib_exports === "undefined") {
      throw new TypeError(
        "Bootstrap's tooltips require Popper (https://popper.js.org)"
      );
    }
    super(element2);
    this._isEnabled = true;
    this._timeout = 0;
    this._hoverState = "";
    this._activeTrigger = {};
    this._popper = null;
    this._config = this._getConfig(config);
    this.tip = null;
    this._setListeners();
  }
  // Getters
  static get Default() {
    return Default8;
  }
  static get NAME() {
    return NAME9;
  }
  static get Event() {
    return Event2;
  }
  static get DefaultType() {
    return DefaultType8;
  }
  // Public
  enable() {
    this._isEnabled = true;
  }
  disable() {
    this._isEnabled = false;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle(event) {
    if (!this._isEnabled) {
      return;
    }
    if (event) {
      const context = this._initializeOnDelegatedTarget(event);
      context._activeTrigger.click = !context._activeTrigger.click;
      if (context._isWithActiveTrigger()) {
        context._enter(null, context);
      } else {
        context._leave(null, context);
      }
    } else {
      if (this.getTipElement().classList.contains(CLASS_NAME_SHOW3)) {
        this._leave(null, this);
        return;
      }
      this._enter(null, this);
    }
  }
  dispose() {
    clearTimeout(this._timeout);
    event_handler_default.off(
      this._element.closest(SELECTOR_MODAL),
      EVENT_MODAL_HIDE,
      this._hideModalHandler
    );
    if (this.tip) {
      this.tip.remove();
    }
    this._disposePopper();
    super.dispose();
  }
  show() {
    if (this._element.style.display === "none") {
      throw new Error("Please use show on visible elements");
    }
    if (!(this.isWithContent() && this._isEnabled)) {
      return;
    }
    const showEvent = event_handler_default.trigger(
      this._element,
      this.constructor.Event.SHOW
    );
    const shadowRoot = findShadowRoot(this._element);
    const isInTheDom = shadowRoot === null ? this._element.ownerDocument.documentElement.contains(this._element) : shadowRoot.contains(this._element);
    if (showEvent.defaultPrevented || !isInTheDom) {
      return;
    }
    if (this.constructor.NAME === "tooltip" && this.tip && this.getTitle() !== this.tip.querySelector(SELECTOR_TOOLTIP_INNER).innerHTML) {
      this._disposePopper();
      this.tip.remove();
      this.tip = null;
    }
    const tip = this.getTipElement();
    const tipId = getUID(this.constructor.NAME);
    tip.setAttribute("id", tipId);
    this._element.setAttribute("aria-describedby", tipId);
    if (this._config.animation) {
      setTimeout(() => {
        this.tip.classList.add("opacity-100");
        this.tip.classList.remove("opacity-0");
      }, 100);
    }
    const placement = typeof this._config.placement === "function" ? this._config.placement.call(this, tip, this._element) : this._config.placement;
    const attachment = this._getAttachment(placement);
    this._addAttachmentClass(attachment);
    const { container } = this._config;
    data_default.setData(tip, this.constructor.DATA_KEY, this);
    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
      container.append(tip);
      event_handler_default.trigger(this._element, this.constructor.Event.INSERTED);
    }
    if (this._popper) {
      this._popper.update();
    } else {
      this._popper = createPopper3(
        this._element,
        tip,
        this._getPopperConfig(attachment)
      );
    }
    const notPopover = tip.getAttribute("id").includes("tooltip");
    if (notPopover) {
      switch (placement) {
        case "bottom":
          tip.classList.add("py-[0.4rem]");
          break;
        case "left":
          tip.classList.add("px-[0.4rem]");
          break;
        case "right":
          tip.classList.add("px-[0.4rem]");
          break;
        default:
          tip.classList.add("py-[0.4rem]");
          break;
      }
    }
    const customClass = this._resolvePossibleFunction(this._config.customClass);
    if (customClass) {
      tip.classList.add(...customClass.split(" "));
    }
    if ("ontouchstart" in document.documentElement) {
      [].concat(...document.body.children).forEach((element2) => {
        event_handler_default.on(element2, "mouseover", noop);
      });
    }
    const complete = () => {
      const prevHoverState = this._hoverState;
      this._hoverState = null;
      event_handler_default.trigger(this._element, this.constructor.Event.SHOWN);
      if (prevHoverState === HOVER_STATE_OUT) {
        this._leave(null, this);
      }
    };
    const isAnimated = this.tip.classList.contains("transition-opacity");
    this._queueCallback(complete, this.tip, isAnimated);
  }
  hide() {
    if (!this._popper) {
      return;
    }
    const tip = this.getTipElement();
    const complete = () => {
      if (this._isWithActiveTrigger()) {
        return;
      }
      if (this._hoverState !== HOVER_STATE_SHOW) {
        tip.remove();
      }
      this._cleanTipClass();
      this._element.removeAttribute("aria-describedby");
      event_handler_default.trigger(this._element, this.constructor.Event.HIDDEN);
      this._disposePopper();
    };
    const hideEvent = event_handler_default.trigger(
      this._element,
      this.constructor.Event.HIDE
    );
    if (hideEvent.defaultPrevented) {
      return;
    }
    tip.classList.add("opacity-0");
    tip.classList.remove("opacity-100");
    if ("ontouchstart" in document.documentElement) {
      [].concat(...document.body.children).forEach((element2) => event_handler_default.off(element2, "mouseover", noop));
    }
    this._activeTrigger[TRIGGER_CLICK] = false;
    this._activeTrigger[TRIGGER_FOCUS] = false;
    this._activeTrigger[TRIGGER_HOVER] = false;
    const isAnimated = this.tip.classList.contains("opacity-0");
    this._queueCallback(complete, this.tip, isAnimated);
    this._hoverState = "";
  }
  update() {
    if (this._popper !== null) {
      this._popper.update();
    }
  }
  // Protected
  isWithContent() {
    return Boolean(this.getTitle());
  }
  getTipElement() {
    if (this.tip) {
      return this.tip;
    }
    const element2 = document.createElement("div");
    element2.innerHTML = this._config.template;
    const tip = element2.children[0];
    this.setContent(tip);
    tip.classList.remove(CLASS_NAME_FADE, CLASS_NAME_SHOW3);
    this.tip = tip;
    return this.tip;
  }
  setContent(tip) {
    this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TOOLTIP_INNER);
  }
  _sanitizeAndSetContent(template, content, selector) {
    const templateElement = selector_engine_default.findOne(selector, template);
    if (!content && templateElement) {
      templateElement.remove();
      return;
    }
    this.setElementContent(templateElement, content);
  }
  setElementContent(element2, content) {
    if (element2 === null) {
      return;
    }
    if (isElement(content)) {
      content = getElement(content);
      if (this._config.html) {
        if (content.parentNode !== element2) {
          element2.innerHTML = "";
          element2.append(content);
        }
      } else {
        element2.textContent = content.textContent;
      }
      return;
    }
    if (this._config.html) {
      if (this._config.sanitize) {
        content = sanitizeHtml(
          content,
          this._config.allowList,
          this._config.sanitizeFn
        );
      }
      element2.innerHTML = content;
    } else {
      element2.textContent = content;
    }
  }
  getTitle() {
    const title = this._element.getAttribute("data-te-original-title") || this._config.title;
    return this._resolvePossibleFunction(title);
  }
  updateAttachment(attachment) {
    if (attachment === "right") {
      return "end";
    }
    if (attachment === "left") {
      return "start";
    }
    return attachment;
  }
  // Private
  _initializeOnDelegatedTarget(event, context) {
    return context || this.constructor.getOrCreateInstance(
      event.delegateTarget,
      this._getDelegateConfig()
    );
  }
  _getOffset() {
    const { offset: offset2 } = this._config;
    if (typeof offset2 === "string") {
      return offset2.split(",").map((val) => Number.parseInt(val, 10));
    }
    if (typeof offset2 === "function") {
      return (popperData) => offset2(popperData, this._element);
    }
    return offset2;
  }
  _resolvePossibleFunction(content) {
    return typeof content === "function" ? content.call(this._element) : content;
  }
  _getPopperConfig(attachment) {
    const defaultBsPopperConfig = {
      placement: attachment,
      modifiers: [
        {
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        },
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        },
        {
          name: "onChange",
          enabled: true,
          phase: "afterWrite",
          fn: (data) => this._handlePopperPlacementChange(data)
        }
      ],
      onFirstUpdate: (data) => {
        if (data.options.placement !== data.placement) {
          this._handlePopperPlacementChange(data);
        }
      }
    };
    return {
      ...defaultBsPopperConfig,
      ...typeof this._config.popperConfig === "function" ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
    };
  }
  _addAttachmentClass(attachment) {
    this.getTipElement().classList.add(
      `${this._getBasicClassPrefix()}-${this.updateAttachment(attachment)}`
    );
  }
  _getAttachment(placement) {
    return AttachmentMap[placement.toUpperCase()];
  }
  _setListeners() {
    const triggers = this._config.trigger.split(" ");
    triggers.forEach((trigger) => {
      if (trigger === "click") {
        event_handler_default.on(
          this._element,
          this.constructor.Event.CLICK,
          this._config.selector,
          (event) => this.toggle(event)
        );
      } else if (trigger !== TRIGGER_MANUAL) {
        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN;
        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
        event_handler_default.on(
          this._element,
          eventIn,
          this._config.selector,
          (event) => this._enter(event)
        );
        event_handler_default.on(
          this._element,
          eventOut,
          this._config.selector,
          (event) => this._leave(event)
        );
      }
    });
    this._hideModalHandler = () => {
      if (this._element) {
        this.hide();
      }
    };
    event_handler_default.on(
      this._element.closest(SELECTOR_MODAL),
      EVENT_MODAL_HIDE,
      this._hideModalHandler
    );
    if (this._config.selector) {
      this._config = {
        ...this._config,
        trigger: "manual",
        selector: ""
      };
    } else {
      this._fixTitle();
    }
  }
  _fixTitle() {
    const title = this._element.getAttribute("title");
    const originalTitleType = typeof this._element.getAttribute(
      "data-te-original-title"
    );
    if (title || originalTitleType !== "string") {
      this._element.setAttribute("data-te-original-title", title || "");
      if (title && !this._element.getAttribute("aria-label") && !this._element.textContent) {
        this._element.setAttribute("aria-label", title);
      }
      this._element.setAttribute("title", "");
    }
  }
  _enter(event, context) {
    context = this._initializeOnDelegatedTarget(event, context);
    if (event) {
      context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
    }
    if (context.getTipElement().classList.contains(CLASS_NAME_SHOW3) || context._hoverState === HOVER_STATE_SHOW) {
      context._hoverState = HOVER_STATE_SHOW;
      return;
    }
    clearTimeout(context._timeout);
    context._hoverState = HOVER_STATE_SHOW;
    if (!context._config.delay || !context._config.delay.show) {
      context.show();
      return;
    }
    context._timeout = setTimeout(() => {
      if (context._hoverState === HOVER_STATE_SHOW) {
        context.show();
      }
    }, context._config.delay.show);
  }
  _leave(event, context) {
    context = this._initializeOnDelegatedTarget(event, context);
    if (event) {
      context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
    }
    if (context._isWithActiveTrigger()) {
      return;
    }
    clearTimeout(context._timeout);
    context._hoverState = HOVER_STATE_OUT;
    if (!context._config.delay || !context._config.delay.hide) {
      context.hide();
      return;
    }
    context._timeout = setTimeout(() => {
      if (context._hoverState === HOVER_STATE_OUT) {
        context.hide();
      }
    }, context._config.delay.hide);
  }
  _isWithActiveTrigger() {
    for (const trigger in this._activeTrigger) {
      if (this._activeTrigger[trigger]) {
        return true;
      }
    }
    return false;
  }
  _getConfig(config) {
    const dataAttributes = manipulator_default.getDataAttributes(this._element);
    Object.keys(dataAttributes).forEach((dataAttr) => {
      if (DISALLOWED_ATTRIBUTES.has(dataAttr)) {
        delete dataAttributes[dataAttr];
      }
    });
    config = {
      ...this.constructor.Default,
      ...dataAttributes,
      ...typeof config === "object" && config ? config : {}
    };
    config.container = config.container === false ? document.body : getElement(config.container);
    if (typeof config.delay === "number") {
      config.delay = {
        show: config.delay,
        hide: config.delay
      };
    }
    if (typeof config.title === "number") {
      config.title = config.title.toString();
    }
    if (typeof config.content === "number") {
      config.content = config.content.toString();
    }
    typeCheckConfig(NAME9, config, this.constructor.DefaultType);
    if (config.sanitize) {
      config.template = sanitizeHtml(
        config.template,
        config.allowList,
        config.sanitizeFn
      );
    }
    return config;
  }
  _getDelegateConfig() {
    const config = {};
    for (const key in this._config) {
      if (this.constructor.Default[key] !== this._config[key]) {
        config[key] = this._config[key];
      }
    }
    return config;
  }
  _cleanTipClass() {
    const tip = this.getTipElement();
    const basicClassPrefixRegex = new RegExp(
      `(^|\\s)${this._getBasicClassPrefix()}\\S+`,
      "g"
    );
    const tabClass = tip.getAttribute("class").match(basicClassPrefixRegex);
    if (tabClass !== null && tabClass.length > 0) {
      tabClass.map((token) => token.trim()).forEach((tClass) => tip.classList.remove(tClass));
    }
  }
  _getBasicClassPrefix() {
    return CLASS_PREFIX;
  }
  _handlePopperPlacementChange(popperData) {
    const { state } = popperData;
    if (!state) {
      return;
    }
    this.tip = state.elements.popper;
    this._cleanTipClass();
    this._addAttachmentClass(this._getAttachment(state.placement));
  }
  _disposePopper() {
    if (this._popper) {
      this._popper.destroy();
      this._popper = null;
    }
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Tooltip.getOrCreateInstance(this, config);
      if (typeof config === "string") {
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      }
    });
  }
};
defineJQueryPlugin(Tooltip);
var tooltip_default = Tooltip;

// node_modules/tw-elements/dist/src/js/components/popover.js
var NAME10 = "popover";
var DATA_KEY9 = "te.popover";
var EVENT_KEY9 = `.${DATA_KEY9}`;
var CLASS_PREFIX2 = "te-popover";
var Default9 = {
  ...tooltip_default.Default,
  placement: "right",
  offset: [0, 8],
  trigger: "click",
  content: "",
  template: '<div class="opacity-0 transition-opacity duration-300 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-[0_10px_15px_-3px_rgba(0,0,0,0.1),0_4px_6px_-2px_rgba(0,0,0,0.05)] text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:bg-neutral-700 dark:border-0 dark:text-white" role="tooltip"><h3 class="popover-header py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-neutral-500"></h3><div class="popover-body p-4 text-[#212529] dark:text-white"></div></div>'
};
var DefaultType9 = {
  ...tooltip_default.DefaultType,
  content: "(string|element|function)"
};
var Event3 = {
  HIDE: `hide${EVENT_KEY9}`,
  HIDDEN: `hidden${EVENT_KEY9}`,
  SHOW: `show${EVENT_KEY9}`,
  SHOWN: `shown${EVENT_KEY9}`,
  INSERTED: `inserted${EVENT_KEY9}`,
  CLICK: `click${EVENT_KEY9}`,
  FOCUSIN: `focusin${EVENT_KEY9}`,
  FOCUSOUT: `focusout${EVENT_KEY9}`,
  MOUSEENTER: `mouseenter${EVENT_KEY9}`,
  MOUSELEAVE: `mouseleave${EVENT_KEY9}`
};
var SELECTOR_TITLE = ".popover-header";
var SELECTOR_CONTENT = ".popover-body";
var Popover = class extends tooltip_default {
  // Getters
  static get Default() {
    return Default9;
  }
  static get NAME() {
    return NAME10;
  }
  static get Event() {
    return Event3;
  }
  static get DefaultType() {
    return DefaultType9;
  }
  // Overrides
  isWithContent() {
    return this.getTitle() || this._getContent();
  }
  setContent(tip) {
    this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TITLE);
    this._sanitizeAndSetContent(tip, this._getContent(), SELECTOR_CONTENT);
  }
  // Private
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }
  _getBasicClassPrefix() {
    return CLASS_PREFIX2;
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Popover.getOrCreateInstance(this, config);
      if (typeof config === "string") {
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      }
    });
  }
};
defineJQueryPlugin(Popover);
var popover_default = Popover;

// node_modules/tw-elements/dist/src/js/navigation/scrollspy.js
var NAME11 = "scrollspy";
var DATA_KEY10 = "te.scrollspy";
var EVENT_KEY10 = `.${DATA_KEY10}`;
var DATA_API_KEY7 = ".data-api";
var Default10 = {
  offset: 10,
  method: "auto",
  target: ""
};
var DefaultType10 = {
  offset: "number",
  method: "string",
  target: "(string|element)"
};
var DefaultClasses5 = {
  active: "!text-primary dark:!text-primary-400 font-semibold border-l-[0.125rem] border-solid border-primary dark:border-primary-400"
};
var DefaultClassesType5 = {
  active: "string"
};
var EVENT_ACTIVATE = `activate${EVENT_KEY10}`;
var EVENT_SCROLL = `scroll${EVENT_KEY10}`;
var EVENT_LOAD_DATA_API3 = `load${EVENT_KEY10}${DATA_API_KEY7}`;
var LINK_ACTIVE = "data-te-nav-link-active";
var SELECTOR_DROPDOWN_ITEM = "[data-te-dropdown-item-ref]";
var SELECTOR_DATA_SPY = '[data-te-spy="scroll"]';
var SELECTOR_NAV_LIST_GROUP = "[data-te-nav-list-ref]";
var SELECTOR_NAV_LINKS = "[data-te-nav-link-ref]";
var SELECTOR_NAV_ITEMS = "[data-te-nav-item-ref]";
var SELECTOR_LIST_ITEMS = "[data-te-list-group-item-ref]";
var SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}, ${SELECTOR_DROPDOWN_ITEM}`;
var SELECTOR_DROPDOWN = "[data-te-dropdown-ref]";
var SELECTOR_DROPDOWN_TOGGLE = "[data-te-dropdown-toggle-ref]";
var METHOD_OFFSET = "offset";
var METHOD_POSITION = "position";
var ScrollSpy = class extends base_component_default {
  constructor(element2, config, classes) {
    super(element2);
    this._scrollElement = this._element.tagName === "BODY" ? window : this._element;
    this._config = this._getConfig(config);
    this._classes = this._getClasses(classes);
    this._offsets = [];
    this._targets = [];
    this._activeTarget = null;
    this._scrollHeight = 0;
    event_handler_default.on(this._scrollElement, EVENT_SCROLL, () => this._process());
    this.refresh();
    this._process();
  }
  // Getters
  static get Default() {
    return Default10;
  }
  static get NAME() {
    return NAME11;
  }
  // Public
  refresh() {
    const autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;
    const offsetMethod = this._config.method === "auto" ? autoMethod : this._config.method;
    const offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;
    this._offsets = [];
    this._targets = [];
    this._scrollHeight = this._getScrollHeight();
    const targets = selector_engine_default.find(
      SELECTOR_LINK_ITEMS,
      this._config.target
    );
    targets.map((element2) => {
      const targetSelector = getSelectorFromElement(element2);
      const target = targetSelector ? selector_engine_default.findOne(targetSelector) : null;
      if (target) {
        const targetBCR = target.getBoundingClientRect();
        if (targetBCR.width || targetBCR.height) {
          return [
            manipulator_default[offsetMethod](target).top + offsetBase,
            targetSelector
          ];
        }
      }
      return null;
    }).filter((item) => item).sort((a, b) => a[0] - b[0]).forEach((item) => {
      this._offsets.push(item[0]);
      this._targets.push(item[1]);
    });
  }
  dispose() {
    event_handler_default.off(this._scrollElement, EVENT_KEY10);
    super.dispose();
  }
  // Private
  _getConfig(config) {
    config = {
      ...Default10,
      ...manipulator_default.getDataAttributes(this._element),
      ...typeof config === "object" && config ? config : {}
    };
    config.target = getElement(config.target) || document.documentElement;
    typeCheckConfig(NAME11, config, DefaultType10);
    return config;
  }
  _getClasses(classes) {
    const dataAttributes = manipulator_default.getDataClassAttributes(this._element);
    classes = {
      ...DefaultClasses5,
      ...dataAttributes,
      ...classes
    };
    typeCheckConfig(NAME11, classes, DefaultClassesType5);
    return classes;
  }
  _getScrollTop() {
    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
  }
  _getScrollHeight() {
    return this._scrollElement.scrollHeight || Math.max(
      document.body.scrollHeight,
      document.documentElement.scrollHeight
    );
  }
  _getOffsetHeight() {
    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
  }
  _process() {
    const scrollTop = this._getScrollTop() + this._config.offset;
    const scrollHeight = this._getScrollHeight();
    const maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
    if (this._scrollHeight !== scrollHeight) {
      this.refresh();
    }
    if (scrollTop >= maxScroll) {
      const target = this._targets[this._targets.length - 1];
      if (this._activeTarget !== target) {
        this._activate(target);
      }
      return;
    }
    if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
      this._activeTarget = null;
      this._clear();
      return;
    }
    for (let i = this._offsets.length; i--; ) {
      const isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === "undefined" || scrollTop < this._offsets[i + 1]);
      if (isActiveTarget) {
        this._activate(this._targets[i]);
      }
    }
  }
  _activate(target) {
    this._activeTarget = target;
    this._clear();
    const queries = SELECTOR_LINK_ITEMS.split(",").map(
      (selector) => `${selector}[data-te-target="${target}"],${selector}[href="${target}"]`
    );
    const link = selector_engine_default.findOne(queries.join(","), this._config.target);
    link.classList.add(...this._classes.active.split(" "));
    link.setAttribute(LINK_ACTIVE, "");
    if (link.getAttribute(SELECTOR_DROPDOWN_ITEM)) {
      selector_engine_default.findOne(
        SELECTOR_DROPDOWN_TOGGLE,
        link.closest(SELECTOR_DROPDOWN)
      ).classList.add(...this._classes.active.split(" "));
    } else {
      selector_engine_default.parents(link, SELECTOR_NAV_LIST_GROUP).forEach(
        (listGroup) => {
          selector_engine_default.prev(
            listGroup,
            `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`
          ).forEach((item) => {
            item.classList.add(...this._classes.active.split(" "));
            item.setAttribute(LINK_ACTIVE, "");
          });
          selector_engine_default.prev(listGroup, SELECTOR_NAV_ITEMS).forEach(
            (navItem) => {
              selector_engine_default.children(navItem, SELECTOR_NAV_LINKS).forEach(
                (item) => item.classList.add(...this._classes.active.split(" "))
              );
            }
          );
        }
      );
    }
    event_handler_default.trigger(this._scrollElement, EVENT_ACTIVATE, {
      relatedTarget: target
    });
  }
  _clear() {
    selector_engine_default.find(SELECTOR_LINK_ITEMS, this._config.target).filter(
      (node) => node.classList.contains(...this._classes.active.split(" "))
    ).forEach((node) => {
      node.classList.remove(...this._classes.active.split(" "));
      node.removeAttribute(LINK_ACTIVE);
    });
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = ScrollSpy.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (typeof data[config] === "undefined") {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
};
event_handler_default.on(window, EVENT_LOAD_DATA_API3, () => {
  selector_engine_default.find(SELECTOR_DATA_SPY).forEach((spy) => new ScrollSpy(spy));
});
defineJQueryPlugin(ScrollSpy);
var scrollspy_default = ScrollSpy;

// node_modules/tw-elements/dist/src/js/navigation/tab.js
var NAME12 = "tab";
var DATA_KEY11 = "te.tab";
var EVENT_KEY11 = `.${DATA_KEY11}`;
var DATA_API_KEY8 = ".data-api";
var EVENT_HIDE5 = `hide${EVENT_KEY11}`;
var EVENT_HIDDEN5 = `hidden${EVENT_KEY11}`;
var EVENT_SHOW5 = `show${EVENT_KEY11}`;
var EVENT_SHOWN5 = `shown${EVENT_KEY11}`;
var EVENT_CLICK_DATA_API7 = `click${EVENT_KEY11}${DATA_API_KEY8}`;
var DATA_NAME_DROPDOWN_MENU = "data-te-dropdown-menu-ref";
var TAB_ACTIVE = "data-te-tab-active";
var NAV_ACTIVE = "data-te-nav-active";
var FADE = "opacity-0";
var SELECTOR_DROPDOWN2 = "[data-te-dropdown-ref]";
var SELECTOR_NAV = "[data-te-nav-ref]";
var SELECTOR_TAB_ACTIVE = `[${TAB_ACTIVE}]`;
var SELECTOR_NAV_ACTIVE = `[${NAV_ACTIVE}]`;
var SELECTOR_ACTIVE_UL = ":scope > li > .active";
var SELECTOR_DATA_TOGGLE5 = '[data-te-toggle="tab"], [data-te-toggle="pill"], [data-te-toggle="list"]';
var SELECTOR_DROPDOWN_TOGGLE2 = "[data-te-dropdown-toggle-ref]";
var SELECTOR_DROPDOWN_ACTIVE_CHILD = ":scope > [data-te-dropdown-menu-ref] [data-te-dropdown-show]";
var DefaultClasses6 = {
  show: "opacity-100"
};
var DefaultClassesType6 = {
  show: "string"
};
var Tab = class extends base_component_default {
  constructor(element2, classes) {
    super(element2);
    this._classes = this._getClasses(classes);
  }
  // Getters
  static get NAME() {
    return NAME12;
  }
  // Public
  show() {
    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.getAttribute(NAV_ACTIVE) === "") {
      return;
    }
    let previous;
    const target = getElementFromSelector(this._element);
    const listElement = this._element.closest(SELECTOR_NAV);
    const activeNavElement = selector_engine_default.findOne(
      SELECTOR_NAV_ACTIVE,
      listElement
    );
    if (listElement) {
      const itemSelector = listElement.nodeName === "UL" || listElement.nodeName === "OL" ? SELECTOR_ACTIVE_UL : SELECTOR_TAB_ACTIVE;
      previous = selector_engine_default.find(itemSelector, listElement);
      previous = previous[previous.length - 1];
    }
    const hideEvent = previous ? event_handler_default.trigger(previous, EVENT_HIDE5, {
      relatedTarget: this._element
    }) : null;
    const showEvent = event_handler_default.trigger(this._element, EVENT_SHOW5, {
      relatedTarget: previous
    });
    if (showEvent.defaultPrevented || hideEvent !== null && hideEvent.defaultPrevented) {
      return;
    }
    this._activate(
      this._element,
      listElement,
      null,
      activeNavElement,
      this._element
    );
    const complete = () => {
      event_handler_default.trigger(previous, EVENT_HIDDEN5, {
        relatedTarget: this._element
      });
      event_handler_default.trigger(this._element, EVENT_SHOWN5, {
        relatedTarget: previous
      });
    };
    if (target) {
      this._activate(
        target,
        target.parentNode,
        complete,
        activeNavElement,
        this._element
      );
    } else {
      complete();
    }
  }
  // Private
  _getClasses(classes) {
    const dataAttributes = manipulator_default.getDataClassAttributes(this._element);
    classes = {
      ...DefaultClasses6,
      ...dataAttributes,
      ...classes
    };
    typeCheckConfig(NAME12, classes, DefaultClassesType6);
    return classes;
  }
  _activate(element2, container, callback, activeNavElement, navElement) {
    const activeElements = container && (container.nodeName === "UL" || container.nodeName === "OL") ? selector_engine_default.find(SELECTOR_ACTIVE_UL, container) : selector_engine_default.children(container, SELECTOR_TAB_ACTIVE);
    const active = activeElements[0];
    const isTransitioning = callback && active && active.classList.contains(FADE);
    const complete = () => this._transitionComplete(
      element2,
      active,
      callback,
      activeNavElement,
      navElement
    );
    if (active && isTransitioning) {
      manipulator_default.removeClass(active, this._classes.show);
      this._queueCallback(complete, element2, true);
    } else {
      complete();
    }
  }
  _transitionComplete(element2, active, callback, activeNavElement, navElement) {
    if (active && activeNavElement) {
      active.removeAttribute(TAB_ACTIVE);
      activeNavElement.removeAttribute(NAV_ACTIVE);
      const dropdownChild = selector_engine_default.findOne(
        SELECTOR_DROPDOWN_ACTIVE_CHILD,
        active.parentNode
      );
      if (dropdownChild) {
        dropdownChild.removeAttribute(TAB_ACTIVE);
      }
      if (active.getAttribute("role") === "tab") {
        active.setAttribute("aria-selected", false);
      }
    }
    element2.setAttribute(TAB_ACTIVE, "");
    navElement.setAttribute(NAV_ACTIVE, "");
    if (element2.getAttribute("role") === "tab") {
      element2.setAttribute("aria-selected", true);
    }
    reflow(element2);
    if (element2.classList.contains(FADE)) {
      manipulator_default.addClass(element2, this._classes.show);
    }
    let parent = element2.parentNode;
    if (parent && parent.nodeName === "LI") {
      parent = parent.parentNode;
    }
    if (parent && parent.hasAttribute(DATA_NAME_DROPDOWN_MENU)) {
      const dropdownElement = element2.closest(SELECTOR_DROPDOWN2);
      if (dropdownElement) {
        selector_engine_default.find(SELECTOR_DROPDOWN_TOGGLE2, dropdownElement).forEach(
          (dropdown) => dropdown.setAttribute(TAB_ACTIVE, "")
        );
      }
      element2.setAttribute("aria-expanded", true);
    }
    if (callback) {
      callback();
    }
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Tab.getOrCreateInstance(this);
      if (typeof config === "string") {
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      }
    });
  }
};
event_handler_default.on(
  document,
  EVENT_CLICK_DATA_API7,
  SELECTOR_DATA_TOGGLE5,
  function(event) {
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    const data = Tab.getOrCreateInstance(this);
    data.show();
  }
);
defineJQueryPlugin(Tab);
var tab_default = Tab;

// node_modules/tw-elements/dist/src/js/components/toast.js
var NAME13 = "toast";
var DATA_KEY12 = "te.toast";
var EVENT_KEY12 = `.${DATA_KEY12}`;
var EVENT_MOUSEOVER = `mouseover${EVENT_KEY12}`;
var EVENT_MOUSEOUT = `mouseout${EVENT_KEY12}`;
var EVENT_FOCUSIN = `focusin${EVENT_KEY12}`;
var EVENT_FOCUSOUT = `focusout${EVENT_KEY12}`;
var EVENT_HIDE6 = `hide${EVENT_KEY12}`;
var EVENT_HIDDEN6 = `hidden${EVENT_KEY12}`;
var EVENT_SHOW6 = `show${EVENT_KEY12}`;
var EVENT_SHOWN6 = `shown${EVENT_KEY12}`;
var HIDE_DATA_ATTRIBUTE = "data-te-toast-hide";
var SHOW_DATA_ATTRIBUTE2 = "data-te-toast-show";
var SHOWING_DATA_ATTRIBUTE = "data-te-toast-showing";
var SELECTOR_TOAST = "[data-te-toast-init]";
var DefaultType11 = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
};
var Default11 = {
  animation: true,
  autohide: true,
  delay: 5e3
};
var DefaultClasses7 = {
  fadeIn: "animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none",
  fadeOut: "animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none"
};
var DefaultClassesType7 = {
  fadeIn: "string",
  fadeOut: "string"
};
var Toast = class extends base_component_default {
  constructor(element2, config, classes) {
    super(element2);
    this._config = this._getConfig(config);
    this._classes = this._getClasses(classes);
    this._timeout = null;
    this._hasMouseInteraction = false;
    this._hasKeyboardInteraction = false;
    this._setListeners();
  }
  // Getters
  static get DefaultType() {
    return DefaultType11;
  }
  static get Default() {
    return Default11;
  }
  static get NAME() {
    return NAME13;
  }
  // Public
  show() {
    const showEvent = event_handler_default.trigger(this._element, EVENT_SHOW6);
    if (showEvent.defaultPrevented) {
      return;
    }
    this._clearTimeout();
    if (this._config.animation) {
      manipulator_default.removeClass(this._element, this._classes.fadeOut);
      manipulator_default.addClass(this._element, this._classes.fadeIn);
    }
    const complete = () => {
      this._element.removeAttribute(SHOWING_DATA_ATTRIBUTE);
      event_handler_default.trigger(this._element, EVENT_SHOWN6);
      this._maybeScheduleHide();
    };
    this._element.removeAttribute(HIDE_DATA_ATTRIBUTE);
    reflow(this._element);
    this._element.setAttribute(SHOW_DATA_ATTRIBUTE2, "");
    this._element.setAttribute(SHOWING_DATA_ATTRIBUTE, "");
    this._queueCallback(complete, this._element, this._config.animation);
  }
  hide() {
    if (!this._element || this._element.dataset.teToastShow === void 0) {
      return;
    }
    const hideEvent = event_handler_default.trigger(this._element, EVENT_HIDE6);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const complete = () => {
      let timeout = 0;
      if (this._config.animation) {
        timeout = 300;
        manipulator_default.removeClass(this._element, this._classes.fadeIn);
        manipulator_default.addClass(this._element, this._classes.fadeOut);
      }
      setTimeout(() => {
        this._element.setAttribute(HIDE_DATA_ATTRIBUTE, "");
        this._element.removeAttribute(SHOWING_DATA_ATTRIBUTE);
        this._element.removeAttribute(SHOW_DATA_ATTRIBUTE2);
        event_handler_default.trigger(this._element, EVENT_HIDDEN6);
      }, timeout);
    };
    this._element.setAttribute(SHOWING_DATA_ATTRIBUTE, "");
    this._queueCallback(complete, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout();
    if (this._element.dataset.teToastShow !== void 0) {
      this._element.removeAttribute(SHOW_DATA_ATTRIBUTE2);
    }
    super.dispose();
  }
  // Private
  _getConfig(config) {
    config = {
      ...Default11,
      ...manipulator_default.getDataAttributes(this._element),
      ...typeof config === "object" && config ? config : {}
    };
    typeCheckConfig(NAME13, config, this.constructor.DefaultType);
    return config;
  }
  _getClasses(classes) {
    const dataAttributes = manipulator_default.getDataClassAttributes(this._element);
    classes = {
      ...DefaultClasses7,
      ...dataAttributes,
      ...classes
    };
    typeCheckConfig(NAME13, classes, DefaultClassesType7);
    return classes;
  }
  _maybeScheduleHide() {
    if (!this._config.autohide) {
      return;
    }
    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
      return;
    }
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }
  _onInteraction(event, isInteracting) {
    switch (event.type) {
      case "mouseover":
      case "mouseout":
        this._hasMouseInteraction = isInteracting;
        break;
      case "focusin":
      case "focusout":
        this._hasKeyboardInteraction = isInteracting;
        break;
      default:
        break;
    }
    if (isInteracting) {
      this._clearTimeout();
      return;
    }
    const nextElement = event.relatedTarget;
    if (this._element === nextElement || this._element.contains(nextElement)) {
      return;
    }
    this._maybeScheduleHide();
  }
  _setListeners() {
    event_handler_default.on(
      this._element,
      EVENT_MOUSEOVER,
      (event) => this._onInteraction(event, true)
    );
    event_handler_default.on(
      this._element,
      EVENT_MOUSEOUT,
      (event) => this._onInteraction(event, false)
    );
    event_handler_default.on(
      this._element,
      EVENT_FOCUSIN,
      (event) => this._onInteraction(event, true)
    );
    event_handler_default.on(
      this._element,
      EVENT_FOCUSOUT,
      (event) => this._onInteraction(event, false)
    );
  }
  _clearTimeout() {
    clearTimeout(this._timeout);
    this._timeout = null;
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Toast.getOrCreateInstance(this, config);
      if (typeof config === "string") {
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      }
    });
  }
};
enableDismissTrigger(Toast);
selector_engine_default.find(SELECTOR_TOAST).forEach((el) => {
  let instance = Toast.getInstance(el);
  if (!instance) {
    instance = new Toast(el);
  }
});
defineJQueryPlugin(Toast);
var toast_default = Toast;

// node_modules/detect-autofill/dist/detect-autofill.js
(() => {
  var e = { 454: (e2, t2, n2) => {
    "use strict";
    n2.d(t2, { Z: () => a });
    var r = n2(645), o = n2.n(r)()(function(e3) {
      return e3[1];
    });
    o.push([e2.id, "INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}", ""]);
    const a = o;
  }, 645: (e2) => {
    "use strict";
    e2.exports = function(e3) {
      var t2 = [];
      return t2.toString = function() {
        return this.map(function(t3) {
          var n2 = e3(t3);
          return t3[2] ? "@media ".concat(t3[2], " {").concat(n2, "}") : n2;
        }).join("");
      }, t2.i = function(e4, n2, r) {
        "string" == typeof e4 && (e4 = [[null, e4, ""]]);
        var o = {};
        if (r)
          for (var a = 0; a < this.length; a++) {
            var i = this[a][0];
            null != i && (o[i] = true);
          }
        for (var u = 0; u < e4.length; u++) {
          var c = [].concat(e4[u]);
          r && o[c[0]] || (n2 && (c[2] ? c[2] = "".concat(n2, " and ").concat(c[2]) : c[2] = n2), t2.push(c));
        }
      }, t2;
    };
  }, 810: () => {
    !function() {
      if ("undefined" != typeof window)
        try {
          var e2 = new window.CustomEvent("test", { cancelable: true });
          if (e2.preventDefault(), true !== e2.defaultPrevented)
            throw new Error("Could not prevent default");
        } catch (e3) {
          var t2 = function(e4, t3) {
            var n2, r;
            return (t3 = t3 || {}).bubbles = !!t3.bubbles, t3.cancelable = !!t3.cancelable, (n2 = document.createEvent("CustomEvent")).initCustomEvent(e4, t3.bubbles, t3.cancelable, t3.detail), r = n2.preventDefault, n2.preventDefault = function() {
              r.call(this);
              try {
                Object.defineProperty(this, "defaultPrevented", { get: function() {
                  return true;
                } });
              } catch (e5) {
                this.defaultPrevented = true;
              }
            }, n2;
          };
          t2.prototype = window.Event.prototype, window.CustomEvent = t2;
        }
    }();
  }, 379: (e2, t2, n2) => {
    "use strict";
    var r, o = function() {
      var e3 = {};
      return function(t3) {
        if (void 0 === e3[t3]) {
          var n3 = document.querySelector(t3);
          if (window.HTMLIFrameElement && n3 instanceof window.HTMLIFrameElement)
            try {
              n3 = n3.contentDocument.head;
            } catch (e4) {
              n3 = null;
            }
          e3[t3] = n3;
        }
        return e3[t3];
      };
    }(), a = [];
    function i(e3) {
      for (var t3 = -1, n3 = 0; n3 < a.length; n3++)
        if (a[n3].identifier === e3) {
          t3 = n3;
          break;
        }
      return t3;
    }
    function u(e3, t3) {
      for (var n3 = {}, r2 = [], o2 = 0; o2 < e3.length; o2++) {
        var u2 = e3[o2], c2 = t3.base ? u2[0] + t3.base : u2[0], l2 = n3[c2] || 0, s2 = "".concat(c2, " ").concat(l2);
        n3[c2] = l2 + 1;
        var d2 = i(s2), f2 = { css: u2[1], media: u2[2], sourceMap: u2[3] };
        -1 !== d2 ? (a[d2].references++, a[d2].updater(f2)) : a.push({ identifier: s2, updater: m(f2, t3), references: 1 }), r2.push(s2);
      }
      return r2;
    }
    function c(e3) {
      var t3 = document.createElement("style"), r2 = e3.attributes || {};
      if (void 0 === r2.nonce) {
        var a2 = n2.nc;
        a2 && (r2.nonce = a2);
      }
      if (Object.keys(r2).forEach(function(e4) {
        t3.setAttribute(e4, r2[e4]);
      }), "function" == typeof e3.insert)
        e3.insert(t3);
      else {
        var i2 = o(e3.insert || "head");
        if (!i2)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
        i2.appendChild(t3);
      }
      return t3;
    }
    var l, s = (l = [], function(e3, t3) {
      return l[e3] = t3, l.filter(Boolean).join("\n");
    });
    function d(e3, t3, n3, r2) {
      var o2 = n3 ? "" : r2.media ? "@media ".concat(r2.media, " {").concat(r2.css, "}") : r2.css;
      if (e3.styleSheet)
        e3.styleSheet.cssText = s(t3, o2);
      else {
        var a2 = document.createTextNode(o2), i2 = e3.childNodes;
        i2[t3] && e3.removeChild(i2[t3]), i2.length ? e3.insertBefore(a2, i2[t3]) : e3.appendChild(a2);
      }
    }
    function f(e3, t3, n3) {
      var r2 = n3.css, o2 = n3.media, a2 = n3.sourceMap;
      if (o2 ? e3.setAttribute("media", o2) : e3.removeAttribute("media"), a2 && "undefined" != typeof btoa && (r2 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a2)))), " */")), e3.styleSheet)
        e3.styleSheet.cssText = r2;
      else {
        for (; e3.firstChild; )
          e3.removeChild(e3.firstChild);
        e3.appendChild(document.createTextNode(r2));
      }
    }
    var v = null, p = 0;
    function m(e3, t3) {
      var n3, r2, o2;
      if (t3.singleton) {
        var a2 = p++;
        n3 = v || (v = c(t3)), r2 = d.bind(null, n3, a2, false), o2 = d.bind(null, n3, a2, true);
      } else
        n3 = c(t3), r2 = f.bind(null, n3, t3), o2 = function() {
          !function(e4) {
            if (null === e4.parentNode)
              return false;
            e4.parentNode.removeChild(e4);
          }(n3);
        };
      return r2(e3), function(t4) {
        if (t4) {
          if (t4.css === e3.css && t4.media === e3.media && t4.sourceMap === e3.sourceMap)
            return;
          r2(e3 = t4);
        } else
          o2();
      };
    }
    e2.exports = function(e3, t3) {
      (t3 = t3 || {}).singleton || "boolean" == typeof t3.singleton || (t3.singleton = (void 0 === r && (r = Boolean(window && document && document.all && !window.atob)), r));
      var n3 = u(e3 = e3 || [], t3);
      return function(e4) {
        if (e4 = e4 || [], "[object Array]" === Object.prototype.toString.call(e4)) {
          for (var r2 = 0; r2 < n3.length; r2++) {
            var o2 = i(n3[r2]);
            a[o2].references--;
          }
          for (var c2 = u(e4, t3), l2 = 0; l2 < n3.length; l2++) {
            var s2 = i(n3[l2]);
            0 === a[s2].references && (a[s2].updater(), a.splice(s2, 1));
          }
          n3 = c2;
        }
      };
    };
  } }, t = {};
  function n(r) {
    var o = t[r];
    if (void 0 !== o)
      return o.exports;
    var a = t[r] = { id: r, exports: {} };
    return e[r](a, a.exports, n), a.exports;
  }
  n.n = (e2) => {
    var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
    return n.d(t2, { a: t2 }), t2;
  }, n.d = (e2, t2) => {
    for (var r in t2)
      n.o(t2, r) && !n.o(e2, r) && Object.defineProperty(e2, r, { enumerable: true, get: t2[r] });
  }, n.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), (() => {
    "use strict";
    var e2 = n(379), t2 = n.n(e2), r = n(454);
    function o(e3) {
      if (!e3.hasAttribute("autocompleted")) {
        e3.setAttribute("autocompleted", "");
        var t3 = new window.CustomEvent("onautocomplete", { bubbles: true, cancelable: true, detail: null });
        e3.dispatchEvent(t3) || (e3.value = "");
      }
    }
    function a(e3) {
      e3.hasAttribute("autocompleted") && (e3.removeAttribute("autocompleted"), e3.dispatchEvent(new window.CustomEvent("onautocomplete", { bubbles: true, cancelable: false, detail: null })));
    }
    t2()(r.Z, { insert: "head", singleton: false }), r.Z.locals, n(810), document.addEventListener("animationstart", function(e3) {
      "onautofillstart" === e3.animationName ? o(e3.target) : a(e3.target);
    }, true), document.addEventListener("input", function(e3) {
      "insertReplacementText" !== e3.inputType && "data" in e3 ? a(e3.target) : o(e3.target);
    }, true);
  })();
})();

// node_modules/tw-elements/dist/src/js/forms/input.js
var NAME14 = "input";
var DATA_KEY13 = "te.input";
var DATA_WRAPPER = "data-te-input-wrapper-init";
var DATA_NOTCH = "data-te-input-notch-ref";
var DATA_NOTCH_LEADING = "data-te-input-notch-leading-ref";
var DATA_NOTCH_MIDDLE = "data-te-input-notch-middle-ref";
var DATA_NOTCH_TRAILING = "data-te-input-notch-trailing-ref";
var DATA_HELPER = "data-te-input-helper-ref";
var DATA_PLACEHOLDER_ACTIVE = "data-te-input-placeholder-active";
var DATA_ACTIVE = "data-te-input-state-active";
var DATA_FOCUSED = "data-te-input-focused";
var DATA_FORM_COUNTER = "data-te-input-form-counter";
var SELECTOR_OUTLINE_INPUT = `[${DATA_WRAPPER}] input`;
var SELECTOR_OUTLINE_TEXTAREA = `[${DATA_WRAPPER}] textarea`;
var SELECTOR_NOTCH = `[${DATA_NOTCH}]`;
var SELECTOR_NOTCH_LEADING = `[${DATA_NOTCH_LEADING}]`;
var SELECTOR_NOTCH_MIDDLE = `[${DATA_NOTCH_MIDDLE}]`;
var SELECTOR_HELPER = `[${DATA_HELPER}]`;
var Default12 = {
  inputFormWhite: false
};
var DefaultType12 = {
  inputFormWhite: "(boolean)"
};
var DefaultClasses8 = {
  notch: "group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none",
  notchLeading: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0",
  notchLeadingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchLeadingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[-1px_0_0_#ffffff,_0_1px_0_0_#ffffff,_0_-1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  notchMiddle: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent",
  notchMiddleNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchMiddleWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  notchTrailing: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0",
  notchTrailingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchTrailingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[1px_0_0_#ffffff,_0_-1px_0_0_#ffffff,_0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  counter: "text-right leading-[1.6]"
};
var DefaultClassesType8 = {
  notch: "string",
  notchLeading: "string",
  notchLeadingNormal: "string",
  notchLeadingWhite: "string",
  notchMiddle: "string",
  notchMiddleNormal: "string",
  notchMiddleWhite: "string",
  notchTrailing: "string",
  notchTrailingNormal: "string",
  notchTrailingWhite: "string",
  counter: "string"
};
var Input = class {
  constructor(element2, config, classes) {
    this._config = this._getConfig(config, element2);
    this._element = element2;
    this._classes = this._getClasses(classes);
    this._label = null;
    this._labelWidth = 0;
    this._labelMarginLeft = 0;
    this._notchLeading = null;
    this._notchMiddle = null;
    this._notchTrailing = null;
    this._initiated = false;
    this._helper = null;
    this._counter = false;
    this._counterElement = null;
    this._maxLength = 0;
    this._leadingIcon = null;
    if (this._element) {
      data_default.setData(element2, DATA_KEY13, this);
      this.init();
    }
  }
  // Getters
  static get NAME() {
    return NAME14;
  }
  get input() {
    const inputElement = selector_engine_default.findOne("input", this._element) || selector_engine_default.findOne("textarea", this._element);
    return inputElement;
  }
  // Public
  init() {
    if (this._initiated) {
      return;
    }
    this._getLabelData();
    this._applyDivs();
    this._applyNotch();
    this._activate();
    this._getHelper();
    this._getCounter();
    this._initiated = true;
  }
  update() {
    this._getLabelData();
    this._getNotchData();
    this._applyNotch();
    this._activate();
    this._getHelper();
    this._getCounter();
  }
  forceActive() {
    this.input.setAttribute(DATA_ACTIVE, "");
    selector_engine_default.findOne(SELECTOR_NOTCH, this.input.parentNode).setAttribute(
      DATA_ACTIVE,
      ""
    );
  }
  forceInactive() {
    this.input.removeAttribute(DATA_ACTIVE);
    selector_engine_default.findOne(
      SELECTOR_NOTCH,
      this.input.parentNode
    ).removeAttribute(DATA_ACTIVE);
  }
  dispose() {
    this._removeBorder();
    data_default.removeData(this._element, DATA_KEY13);
    this._element = null;
  }
  // Private
  _getConfig(config, element2) {
    config = {
      ...Default12,
      ...manipulator_default.getDataAttributes(element2),
      ...typeof config === "object" ? config : {}
    };
    typeCheckConfig(NAME14, config, DefaultType12);
    return config;
  }
  _getClasses(classes) {
    const dataAttributes = manipulator_default.getDataClassAttributes(this._element);
    classes = {
      ...DefaultClasses8,
      ...dataAttributes,
      ...classes
    };
    typeCheckConfig(NAME14, classes, DefaultClassesType8);
    return classes;
  }
  _getLabelData() {
    this._label = selector_engine_default.findOne("label", this._element);
    if (this._label === null) {
      this._showPlaceholder();
    } else {
      this._getLabelWidth();
      this._getLabelPositionInInputGroup();
      this._toggleDefaultDatePlaceholder();
    }
  }
  _getHelper() {
    this._helper = selector_engine_default.findOne(SELECTOR_HELPER, this._element);
  }
  _getCounter() {
    this._counter = manipulator_default.getDataAttribute(
      this.input,
      "inputShowcounter"
    );
    if (this._counter) {
      this._maxLength = this.input.maxLength;
      this._showCounter();
    }
  }
  _showCounter() {
    const counters = selector_engine_default.find(
      `[${DATA_FORM_COUNTER}]`,
      this._element
    );
    if (counters.length > 0) {
      return;
    }
    this._counterElement = document.createElement("div");
    manipulator_default.addClass(this._counterElement, this._classes.counter);
    this._counterElement.setAttribute(DATA_FORM_COUNTER, "");
    const actualLength = this.input.value.length;
    this._counterElement.innerHTML = `${actualLength} / ${this._maxLength}`;
    this._helper.appendChild(this._counterElement);
    this._bindCounter();
  }
  _bindCounter() {
    event_handler_default.on(this.input, "input", () => {
      const actualLength = this.input.value.length;
      this._counterElement.innerHTML = `${actualLength} / ${this._maxLength}`;
    });
  }
  _toggleDefaultDatePlaceholder(input = this.input) {
    const isTypeDate = input.getAttribute("type") === "date";
    if (!isTypeDate) {
      return;
    }
    const isInputFocused = document.activeElement === input;
    if (!isInputFocused && !input.value) {
      input.style.opacity = 0;
    } else {
      input.style.opacity = 1;
    }
  }
  _showPlaceholder() {
    this.input.setAttribute(DATA_PLACEHOLDER_ACTIVE, "");
  }
  _getNotchData() {
    this._notchMiddle = selector_engine_default.findOne(
      SELECTOR_NOTCH_MIDDLE,
      this._element
    );
    this._notchLeading = selector_engine_default.findOne(
      SELECTOR_NOTCH_LEADING,
      this._element
    );
  }
  _getLabelWidth() {
    this._labelWidth = this._label.clientWidth * 0.8 + 8;
  }
  _getLabelPositionInInputGroup() {
    this._labelMarginLeft = 0;
    if (!this._element.hasAttribute("data-te-input-group-ref"))
      return;
    const input = this.input;
    const prefix = selector_engine_default.prev(
      input,
      "[data-te-input-group-text-ref]"
    )[0];
    if (prefix === void 0) {
      this._labelMarginLeft = 0;
    } else {
      this._labelMarginLeft = prefix.offsetWidth - 1;
    }
  }
  _applyDivs() {
    const shadowLeading = this._config.inputFormWhite ? this._classes.notchLeadingWhite : this._classes.notchLeadingNormal;
    const shadowMiddle = this._config.inputFormWhite ? this._classes.notchMiddleWhite : this._classes.notchMiddleNormal;
    const shadowTrailing = this._config.inputFormWhite ? this._classes.notchTrailingWhite : this._classes.notchTrailingNormal;
    const allNotchWrappers = selector_engine_default.find(SELECTOR_NOTCH, this._element);
    const notchWrapper = element("div");
    manipulator_default.addClass(notchWrapper, this._classes.notch);
    notchWrapper.setAttribute(DATA_NOTCH, "");
    this._notchLeading = element("div");
    manipulator_default.addClass(
      this._notchLeading,
      `${this._classes.notchLeading} ${shadowLeading}`
    );
    this._notchLeading.setAttribute(DATA_NOTCH_LEADING, "");
    this._notchMiddle = element("div");
    manipulator_default.addClass(
      this._notchMiddle,
      `${this._classes.notchMiddle} ${shadowMiddle}`
    );
    this._notchMiddle.setAttribute(DATA_NOTCH_MIDDLE, "");
    this._notchTrailing = element("div");
    manipulator_default.addClass(
      this._notchTrailing,
      `${this._classes.notchTrailing} ${shadowTrailing}`
    );
    this._notchTrailing.setAttribute(DATA_NOTCH_TRAILING, "");
    if (allNotchWrappers.length >= 1) {
      return;
    }
    notchWrapper.append(this._notchLeading);
    notchWrapper.append(this._notchMiddle);
    notchWrapper.append(this._notchTrailing);
    this._element.append(notchWrapper);
  }
  _applyNotch() {
    this._notchMiddle.style.width = `${this._labelWidth}px`;
    this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`;
    if (this._label === null)
      return;
    this._label.style.marginLeft = `${this._labelMarginLeft}px`;
  }
  _removeBorder() {
    const border = selector_engine_default.findOne(SELECTOR_NOTCH, this._element);
    if (border)
      border.remove();
  }
  _activate(event) {
    onDOMContentLoaded(() => {
      this._getElements(event);
      const input = event ? event.target : this.input;
      const notchWrapper = selector_engine_default.findOne(
        SELECTOR_NOTCH,
        this._element
      );
      if (event && event.type === "focus") {
        notchWrapper.setAttribute(DATA_FOCUSED, "");
      }
      if (input.value !== "") {
        input.setAttribute(DATA_ACTIVE, "");
        notchWrapper.setAttribute(DATA_ACTIVE, "");
      }
      this._toggleDefaultDatePlaceholder(input);
    });
  }
  _getElements(event) {
    if (event) {
      this._element = event.target.parentNode;
      this._label = selector_engine_default.findOne("label", this._element);
    }
    if (event && this._label) {
      const prevLabelWidth = this._labelWidth;
      this._getLabelData();
      if (prevLabelWidth !== this._labelWidth) {
        this._notchMiddle = selector_engine_default.findOne(
          SELECTOR_NOTCH_MIDDLE,
          event.target.parentNode
        );
        this._notchLeading = selector_engine_default.findOne(
          SELECTOR_NOTCH_LEADING,
          event.target.parentNode
        );
        this._applyNotch();
      }
    }
  }
  _deactivate(event) {
    const input = event ? event.target : this.input;
    const notchWrapper = selector_engine_default.findOne(
      SELECTOR_NOTCH,
      input.parentNode
    );
    notchWrapper.removeAttribute(DATA_FOCUSED);
    if (input.value === "") {
      input.removeAttribute(DATA_ACTIVE);
      notchWrapper.removeAttribute(DATA_ACTIVE);
    }
    this._toggleDefaultDatePlaceholder(input);
  }
  static activate(instance) {
    return function(event) {
      instance._activate(event);
    };
  }
  static deactivate(instance) {
    return function(event) {
      instance._deactivate(event);
    };
  }
  static jQueryInterface(config, options) {
    return this.each(function() {
      let data = data_default.getData(this, DATA_KEY13);
      const _config = typeof config === "object" && config;
      if (!data && /dispose/.test(config)) {
        return;
      }
      if (!data) {
        data = new Input(this, _config);
      }
      if (typeof config === "string") {
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](options);
      }
    });
  }
  static getInstance(element2) {
    return data_default.getData(element2, DATA_KEY13);
  }
  static getOrCreateInstance(element2, config = {}) {
    return this.getInstance(element2) || new this(element2, typeof config === "object" ? config : null);
  }
};
event_handler_default.on(
  document,
  "focus",
  SELECTOR_OUTLINE_INPUT,
  Input.activate(new Input())
);
event_handler_default.on(
  document,
  "input",
  SELECTOR_OUTLINE_INPUT,
  Input.activate(new Input())
);
event_handler_default.on(
  document,
  "blur",
  SELECTOR_OUTLINE_INPUT,
  Input.deactivate(new Input())
);
event_handler_default.on(
  document,
  "focus",
  SELECTOR_OUTLINE_TEXTAREA,
  Input.activate(new Input())
);
event_handler_default.on(
  document,
  "input",
  SELECTOR_OUTLINE_TEXTAREA,
  Input.activate(new Input())
);
event_handler_default.on(
  document,
  "blur",
  SELECTOR_OUTLINE_TEXTAREA,
  Input.deactivate(new Input())
);
event_handler_default.on(window, "shown.te.modal", (e) => {
  selector_engine_default.find(SELECTOR_OUTLINE_INPUT, e.target).forEach((element2) => {
    const instance = Input.getInstance(element2.parentNode);
    if (!instance) {
      return;
    }
    instance.update();
  });
  selector_engine_default.find(SELECTOR_OUTLINE_TEXTAREA, e.target).forEach(
    (element2) => {
      const instance = Input.getInstance(element2.parentNode);
      if (!instance) {
        return;
      }
      instance.update();
    }
  );
});
event_handler_default.on(window, "shown.te.dropdown", (e) => {
  const target = e.target.parentNode.querySelector(
    "[data-te-dropdown-menu-ref]"
  );
  if (target) {
    selector_engine_default.find(SELECTOR_OUTLINE_INPUT, target).forEach((element2) => {
      const instance = Input.getInstance(element2.parentNode);
      if (!instance) {
        return;
      }
      instance.update();
    });
    selector_engine_default.find(SELECTOR_OUTLINE_TEXTAREA, target).forEach(
      (element2) => {
        const instance = Input.getInstance(element2.parentNode);
        if (!instance) {
          return;
        }
        instance.update();
      }
    );
  }
});
event_handler_default.on(window, "shown.te.tab", (e) => {
  let targetId;
  if (e.target.href) {
    targetId = e.target.href.split("#")[1];
  } else {
    targetId = manipulator_default.getDataAttribute(e.target, "target").split("#")[1];
  }
  const target = selector_engine_default.findOne(`#${targetId}`);
  selector_engine_default.find(SELECTOR_OUTLINE_INPUT, target).forEach((element2) => {
    const instance = Input.getInstance(element2.parentNode);
    if (!instance) {
      return;
    }
    instance.update();
  });
  selector_engine_default.find(SELECTOR_OUTLINE_TEXTAREA, target).forEach((element2) => {
    const instance = Input.getInstance(element2.parentNode);
    if (!instance) {
      return;
    }
    instance.update();
  });
});
selector_engine_default.find(`[${DATA_WRAPPER}]`).map((element2) => new Input(element2));
event_handler_default.on(window, "reset", (e) => {
  selector_engine_default.find(SELECTOR_OUTLINE_INPUT, e.target).forEach((element2) => {
    const instance = Input.getInstance(element2.parentNode);
    if (!instance) {
      return;
    }
    instance.forceInactive();
  });
  selector_engine_default.find(SELECTOR_OUTLINE_TEXTAREA, e.target).forEach(
    (element2) => {
      const instance = Input.getInstance(element2.parentNode);
      if (!instance) {
        return;
      }
      instance.forceInactive();
    }
  );
});
event_handler_default.on(window, "onautocomplete", (e) => {
  const instance = Input.getInstance(e.target.parentNode);
  if (!instance || !e.cancelable) {
    return;
  }
  instance.forceActive();
});
onDOMContentLoaded(() => {
  const $2 = getjQuery();
  if ($2) {
    const JQUERY_NO_CONFLICT = $2.fn[NAME14];
    $2.fn[NAME14] = Input.jQueryInterface;
    $2.fn[NAME14].Constructor = Input;
    $2.fn[NAME14].noConflict = () => {
      $2.fn[NAME14] = JQUERY_NO_CONFLICT;
      return Input.jQueryInterface;
    };
  }
});
var input_default = Input;

// node_modules/tw-elements/dist/src/js/content-styles/animate.js
var NAME15 = "animation";
var DATA_KEY14 = "te.animation";
var SELECTOR_EXPAND = "[data-te-animation-init]";
var DefaultType13 = {
  animation: "string",
  animationStart: "string",
  animationShowOnLoad: "boolean",
  onStart: "(null|function)",
  onEnd: "(null|function)",
  onHide: "(null|function)",
  onShow: "(null|function)",
  animationOnScroll: "(string)",
  animationWindowHeight: "number",
  animationOffset: "(number|string)",
  animationDelay: "(number|string)",
  animationReverse: "boolean",
  animationInterval: "(number|string)",
  animationRepeat: "(number|boolean)",
  animationReset: "boolean"
};
var Default13 = {
  animation: "fade",
  animationStart: "onClick",
  animationShowOnLoad: true,
  onStart: null,
  onEnd: null,
  onHide: null,
  onShow: null,
  animationOnScroll: "once",
  animationWindowHeight: 0,
  animationOffset: 0,
  animationDelay: 0,
  animationReverse: false,
  animationInterval: 0,
  animationRepeat: false,
  animationReset: false
};
var Animate = class {
  constructor(element2, options) {
    this._element = element2;
    this._animateElement = this._getAnimateElement();
    this._isFirstScroll = true;
    this._repeatAnimateOnScroll = true;
    this._options = this._getConfig(options);
    if (this._element) {
      data_default.setData(element2, DATA_KEY14, this);
    }
  }
  // Getters
  static get NAME() {
    return NAME15;
  }
  // Public
  init() {
    this._init();
  }
  startAnimation() {
    this._startAnimation();
  }
  stopAnimation() {
    this._clearAnimationClass();
  }
  changeAnimationType(animation) {
    this._options.animation = animation;
  }
  dispose() {
    event_handler_default.off(this._element, "mousedown");
    event_handler_default.off(this._animateElement, "animationend");
    event_handler_default.off(window, "scroll");
    event_handler_default.off(this._element, "mouseover");
    data_default.removeData(this._element, DATA_KEY14);
    this._element = null;
    this._animateElement = null;
    this._isFirstScroll = null;
    this._repeatAnimateOnScroll = null;
    this._options = null;
  }
  // Private
  _init() {
    switch (this._options.animationStart) {
      case "onHover":
        this._bindHoverEvents();
        break;
      case "onLoad":
        this._startAnimation();
        break;
      case "onScroll":
        this._bindScrollEvents();
        break;
      case "onClick":
        this._bindClickEvents();
        break;
      default:
        break;
    }
    this._bindTriggerOnEndCallback();
    if (this._options.animationReset) {
      this._bindResetAnimationAfterFinish();
    }
  }
  _getAnimateElement() {
    const targetId = manipulator_default.getDataAttribute(
      this._element,
      "animation-target"
    );
    return targetId ? selector_engine_default.find(targetId)[0] : this._element;
  }
  _getConfig(config) {
    const dataAttributes = manipulator_default.getDataAttributes(this._animateElement);
    config = {
      ...Default13,
      ...dataAttributes,
      ...config
    };
    typeCheckConfig(NAME15, config, DefaultType13);
    return config;
  }
  _animateOnScroll() {
    const elementOffsetTop = manipulator_default.offset(this._animateElement).top;
    const elementHeight = this._animateElement.offsetHeight;
    const windowHeight = window.innerHeight;
    const shouldBeVisible = elementOffsetTop + this._options.animationOffset <= windowHeight && elementOffsetTop + this._options.animationOffset + elementHeight >= 0;
    const isElementVisible = this._animateElement.style.visibility === "visible";
    switch (true) {
      case (shouldBeVisible && this._isFirstScroll):
        this._isFirstScroll = false;
        this._startAnimation();
        break;
      case (!shouldBeVisible && this._isFirstScroll):
        this._isFirstScroll = false;
        this._hideAnimateElement();
        break;
      case (shouldBeVisible && !isElementVisible && this._repeatAnimateOnScroll):
        if (this._options.animationOnScroll !== "repeat") {
          this._repeatAnimateOnScroll = false;
        }
        this._callback(this._options.onShow);
        this._showAnimateElement();
        this._startAnimation();
        break;
      case (!shouldBeVisible && isElementVisible && this._repeatAnimateOnScroll):
        this._hideAnimateElement();
        this._clearAnimationClass();
        this._callback(this._options.onHide);
        break;
      default:
        break;
    }
  }
  _addAnimatedClass() {
    manipulator_default.addClass(
      this._animateElement,
      `animate-${this._options.animation}`
    );
  }
  _clearAnimationClass() {
    this._animateElement.classList.remove(`animate-${this._options.animation}`);
  }
  _startAnimation() {
    this._callback(this._options.onStart);
    this._addAnimatedClass();
    if (this._options.animationRepeat && !this._options.animationInterval) {
      this._setAnimationRepeat();
    }
    if (this._options.animationReverse) {
      this._setAnimationReverse();
    }
    if (this._options.animationDelay) {
      this._setAnimationDelay();
    }
    if (this._options.animationDuration) {
      this._setAnimationDuration();
    }
    if (this._options.animationInterval) {
      this._setAnimationInterval();
    }
  }
  _setAnimationReverse() {
    manipulator_default.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === true ? "infinite" : "2",
      animationDirection: "alternate"
    });
  }
  _setAnimationDuration() {
    manipulator_default.style(this._animateElement, {
      animationDuration: `${this._options.animationDuration}ms`
    });
  }
  _setAnimationDelay() {
    manipulator_default.style(this._animateElement, {
      animationDelay: `${this._options.animationDelay}ms`
    });
  }
  _setAnimationRepeat() {
    manipulator_default.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === true ? "infinite" : this._options.animationRepeat
    });
  }
  _setAnimationInterval() {
    event_handler_default.on(this._animateElement, "click", () => {
      this._clearAnimationClass();
      setTimeout(() => {
        this._addAnimatedClass();
      }, this._options.animationInterval);
    });
  }
  _hideAnimateElement() {
    manipulator_default.style(this._animateElement, { visibility: "hidden" });
  }
  _showAnimateElement() {
    manipulator_default.style(this._animateElement, { visibility: "visible" });
  }
  _bindResetAnimationAfterFinish() {
    event_handler_default.on(this._animateElement, "animationend", () => {
      this._clearAnimationClass();
    });
  }
  _bindTriggerOnEndCallback() {
    event_handler_default.on(this._animateElement, "animationend", () => {
      this._callback(this._options.onEnd);
    });
  }
  _bindScrollEvents() {
    if (!this._options.animationShowOnLoad) {
      this._animateOnScroll();
    }
    event_handler_default.on(window, "scroll", () => {
      this._animateOnScroll();
    });
  }
  _bindClickEvents() {
    event_handler_default.on(this._element, "mousedown", () => {
      this._startAnimation();
    });
  }
  _bindHoverEvents() {
    event_handler_default.one(this._element, "mouseover", () => {
      this._startAnimation();
    });
    event_handler_default.one(this._animateElement, "animationend", () => {
      setTimeout(() => {
        this._bindHoverEvents();
      }, 100);
    });
  }
  _callback(fn2) {
    if (fn2 instanceof Function) {
      fn2();
    }
  }
  // Static
  static autoInit(instance) {
    instance._init();
  }
  static jQueryInterface(options) {
    const animate = new Animate(this[0], options);
    animate.init();
  }
  static getInstance(element2) {
    return data_default.getData(element2, DATA_KEY14);
  }
  static getOrCreateInstance(element2, config = {}) {
    return this.getInstance(element2) || new this(element2, typeof config === "object" ? config : null);
  }
};
selector_engine_default.find(SELECTOR_EXPAND).forEach((el) => {
  Animate.autoInit(new Animate(el));
});
onDOMContentLoaded(() => {
  const $2 = getjQuery();
  if ($2) {
    const JQUERY_NO_CONFLICT = $2.fn[NAME15];
    $2.fn[NAME15] = Animate.jQueryInterface;
    $2.fn[NAME15].Constructor = Animate;
    $2.fn[NAME15].noConflict = () => {
      $2.fn[NAME15] = JQUERY_NO_CONFLICT;
      return Animate.jQueryInterface;
    };
  }
});
var animate_default = Animate;

// node_modules/tw-elements/dist/src/js/methods/ripple.js
var NAME16 = "ripple";
var DATA_KEY15 = "te.ripple";
var GRADIENT = "rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%";
var SELECTOR_COMPONENT = ["[data-te-ripple-init]"];
var DEFAULT_RIPPLE_COLOR = [0, 0, 0];
var BOOTSTRAP_COLORS = [
  { name: "primary", gradientColor: "#1268f1" },
  { name: "secondary", gradientColor: "#b33cfd" },
  { name: "success", gradientColor: "#00b749" },
  { name: "danger", gradientColor: "#f93152" },
  { name: "warning", gradientColor: "#ffaa00" },
  { name: "info", gradientColor: "#39c0ed" },
  { name: "light", gradientColor: "#fbfbfb" },
  { name: "dark", gradientColor: "#262626" }
];
var TRANSITION_BREAK_OPACITY = 0.5;
var Default14 = {
  rippleCentered: false,
  rippleColor: "",
  rippleColorDark: "",
  rippleDuration: "500ms",
  rippleRadius: 0,
  rippleUnbound: false
};
var DefaultType14 = {
  rippleCentered: "boolean",
  rippleColor: "string",
  rippleColorDark: "string",
  rippleDuration: "string",
  rippleRadius: "number",
  rippleUnbound: "boolean"
};
var DefaultClasses9 = {
  ripple: "relative overflow-hidden inline-block align-bottom",
  rippleWave: "rounded-[50%] opacity-50 pointer-events-none absolute touch-none scale-0 transition-[transform,_opacity] ease-[cubic-bezier(0,0,0.15,1),_cubic-bezier(0,0,0.15,1)] z-[999]",
  unbound: "overflow-visible"
};
var DefaultClassesType9 = {
  ripple: "string",
  rippleWave: "string",
  unbound: "string"
};
var Ripple = class {
  constructor(element2, options, classes) {
    this._element = element2;
    this._options = this._getConfig(options);
    this._classes = this._getClasses(classes);
    if (this._element) {
      data_default.setData(element2, DATA_KEY15, this);
      manipulator_default.addClass(this._element, this._classes.ripple);
    }
    this._clickHandler = this._createRipple.bind(this);
    this._rippleTimer = null;
    this._isMinWidthSet = false;
    this._initialClasses = null;
    this.init();
  }
  // Getters
  static get NAME() {
    return NAME16;
  }
  // Public
  init() {
    this._addClickEvent(this._element);
  }
  dispose() {
    data_default.removeData(this._element, DATA_KEY15);
    event_handler_default.off(this._element, "click", this._clickHandler);
    this._element = null;
    this._options = null;
  }
  // Private
  _autoInit(event) {
    SELECTOR_COMPONENT.forEach((selector) => {
      const target = selector_engine_default.closest(event.target, selector);
      if (target) {
        this._element = selector_engine_default.closest(event.target, selector);
      }
    });
    if (!this._element.style.minWidth) {
      manipulator_default.style(this._element, {
        "min-width": getComputedStyle(this._element).width
      });
      this._isMinWidthSet = true;
    }
    this._initialClasses = [...this._element.classList];
    manipulator_default.addClass(this._element, this._classes.ripple);
    this._options = this._getConfig();
    this._createRipple(event);
  }
  _addClickEvent(target) {
    event_handler_default.on(target, "mousedown", this._clickHandler);
  }
  _createRipple(event) {
    if (this._element.className.indexOf(this._classes.ripple) < 0) {
      manipulator_default.addClass(this._element, this._classes.ripple);
    }
    const { layerX, layerY } = event;
    const offsetX = layerX;
    const offsetY = layerY;
    const height = this._element.offsetHeight;
    const width = this._element.offsetWidth;
    const duration = this._durationToMsNumber(this._options.rippleDuration);
    const diameterOptions = {
      offsetX: this._options.rippleCentered ? height / 2 : offsetX,
      offsetY: this._options.rippleCentered ? width / 2 : offsetY,
      height,
      width
    };
    const diameter = this._getDiameter(diameterOptions);
    const radiusValue = this._options.rippleRadius || diameter / 2;
    const opacity = {
      delay: duration * TRANSITION_BREAK_OPACITY,
      duration: duration - duration * TRANSITION_BREAK_OPACITY
    };
    const styles = {
      left: this._options.rippleCentered ? `${width / 2 - radiusValue}px` : `${offsetX - radiusValue}px`,
      top: this._options.rippleCentered ? `${height / 2 - radiusValue}px` : `${offsetY - radiusValue}px`,
      height: `${this._options.rippleRadius * 2 || diameter}px`,
      width: `${this._options.rippleRadius * 2 || diameter}px`,
      transitionDelay: `0s, ${opacity.delay}ms`,
      transitionDuration: `${duration}ms, ${opacity.duration}ms`
    };
    const rippleHTML = element("div");
    this._createHTMLRipple({
      wrapper: this._element,
      ripple: rippleHTML,
      styles
    });
    this._removeHTMLRipple({ ripple: rippleHTML, duration });
  }
  _createHTMLRipple({ wrapper, ripple, styles }) {
    Object.keys(styles).forEach(
      (property) => ripple.style[property] = styles[property]
    );
    manipulator_default.addClass(ripple, this._classes.rippleWave);
    ripple.setAttribute("data-te-ripple-ref", "");
    this._addColor(ripple, wrapper);
    this._toggleUnbound(wrapper);
    this._appendRipple(ripple, wrapper);
  }
  _removeHTMLRipple({ ripple, duration }) {
    if (this._rippleTimer) {
      clearTimeout(this._rippleTimer);
      this._rippleTimer = null;
    }
    if (ripple) {
      setTimeout(() => {
        ripple.classList.add("!opacity-0");
      }, 10);
    }
    this._rippleTimer = setTimeout(() => {
      if (ripple) {
        ripple.remove();
        if (this._element) {
          selector_engine_default.find("[data-te-ripple-ref]", this._element).forEach(
            (rippleEl) => {
              rippleEl.remove();
            }
          );
          if (this._isMinWidthSet) {
            manipulator_default.style(this._element, { "min-width": "" });
            this._isMinWidthSet = false;
          }
          const classesToRemove = this._initialClasses ? this._addedNewRippleClasses(
            this._classes.ripple,
            this._initialClasses
          ) : this._classes.ripple.split(" ");
          manipulator_default.removeClass(this._element, classesToRemove);
        }
      }
    }, duration);
  }
  _addedNewRippleClasses(defaultRipple, initialClasses) {
    return defaultRipple.split(" ").filter(
      (item) => initialClasses.findIndex((init) => item === init) === -1
    );
  }
  _durationToMsNumber(time) {
    return Number(time.replace("ms", "").replace("s", "000"));
  }
  _getConfig(config = {}) {
    const dataAttributes = manipulator_default.getDataAttributes(this._element);
    config = {
      ...Default14,
      ...dataAttributes,
      ...config
    };
    typeCheckConfig(NAME16, config, DefaultType14);
    return config;
  }
  _getClasses(classes) {
    const dataAttributes = manipulator_default.getDataClassAttributes(this._element);
    classes = {
      ...DefaultClasses9,
      ...dataAttributes,
      ...classes
    };
    typeCheckConfig(NAME16, classes, DefaultClassesType9);
    return classes;
  }
  _getDiameter({ offsetX, offsetY, height, width }) {
    const top2 = offsetY <= height / 2;
    const left2 = offsetX <= width / 2;
    const pythagorean = (sideA, sideB) => Math.sqrt(sideA ** 2 + sideB ** 2);
    const positionCenter = offsetY === height / 2 && offsetX === width / 2;
    const quadrant = {
      first: top2 === true && left2 === false,
      second: top2 === true && left2 === true,
      third: top2 === false && left2 === true,
      fourth: top2 === false && left2 === false
    };
    const getCorner = {
      topLeft: pythagorean(offsetX, offsetY),
      topRight: pythagorean(width - offsetX, offsetY),
      bottomLeft: pythagorean(offsetX, height - offsetY),
      bottomRight: pythagorean(width - offsetX, height - offsetY)
    };
    let diameter = 0;
    if (positionCenter || quadrant.fourth) {
      diameter = getCorner.topLeft;
    } else if (quadrant.third) {
      diameter = getCorner.topRight;
    } else if (quadrant.second) {
      diameter = getCorner.bottomRight;
    } else if (quadrant.first) {
      diameter = getCorner.bottomLeft;
    }
    return diameter * 2;
  }
  _appendRipple(target, parent) {
    const FIX_ADD_RIPPLE_EFFECT = 50;
    parent.appendChild(target);
    setTimeout(() => {
      manipulator_default.addClass(target, "opacity-0 scale-100");
    }, FIX_ADD_RIPPLE_EFFECT);
  }
  _toggleUnbound(target) {
    if (this._options.rippleUnbound === true) {
      manipulator_default.addClass(target, this._classes.unbound);
    } else {
      manipulator_default.removeClass(target, this._classes.unbound);
    }
  }
  _addColor(target) {
    let rippleColor = this._options.rippleColor || "rgb(0,0,0)";
    if (localStorage.theme === "dark" || !("theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) {
      rippleColor = this._options.rippleColorDark || this._options.rippleColor;
    }
    const IS_BOOTSTRAP_COLOR = BOOTSTRAP_COLORS.find(
      (color) => color.name === rippleColor.toLowerCase()
    );
    const rgbValue = IS_BOOTSTRAP_COLOR ? this._colorToRGB(IS_BOOTSTRAP_COLOR.gradientColor).join(",") : this._colorToRGB(rippleColor).join(",");
    const gradientImage = GRADIENT.split("{{color}}").join(`${rgbValue}`);
    target.style.backgroundImage = `radial-gradient(circle, ${gradientImage})`;
  }
  _colorToRGB(color) {
    function hexToRgb(color2) {
      const HEX_COLOR_LENGTH = 7;
      const IS_SHORT_HEX = color2.length < HEX_COLOR_LENGTH;
      if (IS_SHORT_HEX) {
        color2 = `#${color2[1]}${color2[1]}${color2[2]}${color2[2]}${color2[3]}${color2[3]}`;
      }
      return [
        parseInt(color2.substr(1, 2), 16),
        parseInt(color2.substr(3, 2), 16),
        parseInt(color2.substr(5, 2), 16)
      ];
    }
    function namedColorsToRgba(color2) {
      const tempElem = document.body.appendChild(
        document.createElement("fictum")
      );
      const flag = "rgb(1, 2, 3)";
      tempElem.style.color = flag;
      if (tempElem.style.color !== flag) {
        return DEFAULT_RIPPLE_COLOR;
      }
      tempElem.style.color = color2;
      if (tempElem.style.color === flag || tempElem.style.color === "") {
        return DEFAULT_RIPPLE_COLOR;
      }
      color2 = getComputedStyle(tempElem).color;
      document.body.removeChild(tempElem);
      return color2;
    }
    function rgbaToRgb(color2) {
      color2 = color2.match(/[.\d]+/g).map((a) => +Number(a));
      color2.length = 3;
      return color2;
    }
    if (color.toLowerCase() === "transparent") {
      return DEFAULT_RIPPLE_COLOR;
    }
    if (color[0] === "#") {
      return hexToRgb(color);
    }
    if (color.indexOf("rgb") === -1) {
      color = namedColorsToRgba(color);
    }
    if (color.indexOf("rgb") === 0) {
      return rgbaToRgb(color);
    }
    return DEFAULT_RIPPLE_COLOR;
  }
  // Static
  static autoInitial(instance) {
    return function(event) {
      instance._autoInit(event);
    };
  }
  static jQueryInterface(options) {
    return this.each(function() {
      const data = data_default.getData(this, DATA_KEY15);
      if (!data) {
        return new Ripple(this, options);
      }
      return null;
    });
  }
  static getInstance(element2) {
    return data_default.getData(element2, DATA_KEY15);
  }
  static getOrCreateInstance(element2, config = {}) {
    return this.getInstance(element2) || new this(element2, typeof config === "object" ? config : null);
  }
};
SELECTOR_COMPONENT.forEach((selector) => {
  event_handler_default.one(
    document,
    "mousedown",
    selector,
    Ripple.autoInitial(new Ripple())
  );
});
onDOMContentLoaded(() => {
  const $2 = getjQuery();
  if ($2) {
    const JQUERY_NO_CONFLICT = $2.fn[NAME16];
    $2.fn[NAME16] = Ripple.jQueryInterface;
    $2.fn[NAME16].Constructor = Ripple;
    $2.fn[NAME16].noConflict = () => {
      $2.fn[NAME16] = JQUERY_NO_CONFLICT;
      return Ripple.jQueryInterface;
    };
  }
});
var ripple_default = Ripple;

// node_modules/tw-elements/dist/src/js/forms/datepicker/date-utils.js
function getDate(date) {
  return date.getDate();
}
function getDayNumber(date) {
  return date.getDay();
}
function getMonth(date) {
  return date.getMonth();
}
function getYear(date) {
  return date.getFullYear();
}
function getFirstDayOfWeek(year, month, options) {
  const firstDayIndex = options.startDay;
  const sundayIndex = firstDayIndex > 0 ? 7 - firstDayIndex : 0;
  const date = new Date(year, month);
  const index = date.getDay() + sundayIndex;
  const newIndex = index >= 7 ? index - 7 : index;
  return newIndex;
}
function getDaysInMonth(date) {
  return getMonthEnd(date).getDate();
}
function getMonthEnd(date) {
  return createDate(date.getFullYear(), date.getMonth() + 1, 0);
}
function getToday() {
  return new Date();
}
function addYears(date, years) {
  return addMonths(date, years * 12);
}
function addMonths(date, months) {
  const month = createDate(
    date.getFullYear(),
    date.getMonth() + months,
    date.getDate()
  );
  const dayOfPreviousMonth = getDate(date);
  const dayOfNewMonth = getDate(month);
  if (dayOfPreviousMonth !== dayOfNewMonth) {
    month.setDate(0);
  }
  return month;
}
function addDays(date, days) {
  return createDate(date.getFullYear(), date.getMonth(), date.getDate() + days);
}
function createDate(year, month, day) {
  const result = new Date(year, month, day);
  if (year >= 0 && year < 100) {
    result.setFullYear(result.getFullYear() - 1900);
  }
  return result;
}
function convertStringToDate(dateString) {
  const dateArr = dateString.split("-");
  const year = dateArr[0];
  const month = dateArr[1];
  const day = dateArr[2];
  return createDate(year, month, day);
}
function isValidDate(date) {
  return !Number.isNaN(date.getTime());
}
function isSameDate(date1, date2) {
  date1.setHours(0, 0, 0, 0);
  date2.setHours(0, 0, 0, 0);
  return date1.getTime() === date2.getTime();
}
function getYearsOffset(activeDate, yearsInView) {
  const activeYear = getYear(activeDate);
  const yearsDifference = activeYear - getStartYear();
  return modulo(yearsDifference, yearsInView);
}
function modulo(a, b) {
  return (a % b + b) % b;
}
function getStartYear(yearsInView, minDate, maxDate) {
  let startYear = 0;
  if (maxDate) {
    const maxYear = getYear(maxDate);
    startYear = maxYear - yearsInView + 1;
  } else if (minDate) {
    startYear = getYear(minDate);
  }
  return startYear;
}
function areDatesInSameView(date1, date2, view, lastYearInView, firstYearInView) {
  if (view === "days") {
    return getYear(date1) === getYear(date2) && getMonth(date1) === getMonth(date2);
  }
  if (view === "months") {
    return getYear(date1) === getYear(date2);
  }
  if (view === "years") {
    return getYear(date2) >= firstYearInView && getYear(date2) <= lastYearInView;
  }
  return false;
}

// node_modules/tw-elements/dist/src/js/forms/datepicker/templates.js
var MODAL_CONTAINER_REF = "data-te-datepicker-modal-container-ref";
var BACKDROP_REF = "data-te-dropdown-backdrop-ref";
var DATE_TEXT_REF = "data-te-datepicker-date-text-ref";
var VIEW_REF = "data-te-datepicker-view-ref";
var PREVIOUS_BUTTON_REF = "data-te-datepicker-previous-button-ref";
var NEXT_BUTTON_REF = "data-te-datepicker-next-button-ref";
var OK_BUTTON_REF = "data-te-datepicker-ok-button-ref";
var CANCEL_BUTTON_REF = "data-te-datepicker-cancel-button-ref";
var CLEAR_BUTTON_REF = "data-te-datepicker-clear-button-ref";
var VIEW_CHANGE_BUTTON_REF = "data-te-datepicker-view-change-button-ref";
function getDatepickerTemplate(date, selectedDate, selectedYear, selectedMonth, options, monthsInRow, yearsInView, yearsInRow, id, classes) {
  const month = getMonth(date);
  const year = getYear(date);
  const day = getDate(date);
  const dayNumber = getDayNumber(date);
  const template = element("div");
  const modalContent = `
      ${createHeader(day, dayNumber, month, options, classes)}
      ${createMainContent(
    date,
    month,
    year,
    selectedDate,
    selectedYear,
    selectedMonth,
    options,
    monthsInRow,
    yearsInView,
    yearsInRow,
    classes
  )}
    `;
  manipulator_default.addClass(template, classes.modalContainer);
  template.setAttribute(MODAL_CONTAINER_REF, id);
  template.innerHTML = modalContent;
  return template;
}
function getBackdropTemplate(backdropClasses) {
  const backdrop = element("div");
  manipulator_default.addClass(backdrop, backdropClasses);
  backdrop.setAttribute(BACKDROP_REF, "");
  return backdrop;
}
function createHeader(day, dayNumber, month, options, classes) {
  return `
      <div class="${classes.datepickerHeader}">
        <div class="${classes.datepickerTitle}">
          <span class="${classes.datepickerTitleText}">${options.title}</span>
        </div>
        <div class="${classes.datepickerDate}">
          <span class="${classes.datepickerDateText}" ${DATE_TEXT_REF} >${options.weekdaysShort[dayNumber]}, ${options.monthsShort[month]} ${day}</span>
        </div>
      </div>
    `;
}
function createMainContent(date, month, year, selectedDate, selectedYear, selectedMonth, options, monthsInRow, yearsInView, yearsInRow, classes) {
  const mainContentTemplate = `
    <div class="${classes.datepickerMain}">
      ${createControls(month, year, options, classes)}
      <div class="${classes.datepickerView}" ${VIEW_REF} tabindex="0">
        ${createViewTemplate(
    date,
    year,
    selectedDate,
    selectedYear,
    selectedMonth,
    options,
    monthsInRow,
    yearsInView,
    yearsInRow,
    classes
  )}
      </div>
      ${createFooter(options, classes)}
    </div>
  `;
  return mainContentTemplate;
}
function createViewTemplate(date, year, selectedDate, selectedYear, selectedMonth, options, monthsInRow, yearsInView, yearsInRow, classes) {
  let viewTemplate;
  if (options.view === "days") {
    viewTemplate = createDayViewTemplate(date, selectedDate, options, classes);
  } else if (options.view === "months") {
    viewTemplate = createMonthViewTemplate(
      year,
      selectedYear,
      selectedMonth,
      options,
      monthsInRow,
      classes
    );
  } else {
    viewTemplate = createYearViewTemplate(
      date,
      selectedYear,
      options,
      yearsInView,
      yearsInRow,
      classes
    );
  }
  return viewTemplate;
}
function createControls(month, year, options, classes) {
  return `
    <div class="${classes.datepickerDateControls}">
      <button class="${classes.datepickerViewChangeButton}" aria-label="${options.switchToMultiYearViewLabel}" ${VIEW_CHANGE_BUTTON_REF}>
        ${options.monthsFull[month]} ${year} ${createViewChangeButtonIcon(
    options,
    classes
  )}
      </button>
      <div class="${classes.datepickerArrowControls}">
        <button class="${classes.datepickerPreviousButton}" aria-label="${options.prevMonthLabel}" ${PREVIOUS_BUTTON_REF}>${options.changeMonthIconTemplate}</button>
        <button class="${classes.datepickerNextButton}" aria-label="${options.nextMonthLabel}" ${NEXT_BUTTON_REF}>${options.changeMonthIconTemplate}</button>
      </div>
    </div>
    `;
}
function createViewChangeButtonIcon(options, classes) {
  return `
  <span class="${classes.datepickerViewChangeIcon}">
  ${options.viewChangeIconTemplate}
  </span>
  `;
}
function createFooter(options, classes) {
  return `
        <div class="${classes.datepickerFooter}">
          <button class="${classes.datepickerFooterBtn} ${classes.datepickerClearBtn}" aria-label="${options.clearBtnLabel}" ${CLEAR_BUTTON_REF}>${options.clearBtnText}</button>
          <button class="${classes.datepickerFooterBtn}" aria-label="${options.cancelBtnLabel}" ${CANCEL_BUTTON_REF}>${options.cancelBtnText}</button>
          <button class="${classes.datepickerFooterBtn}" aria-label="${options.okBtnLabel}" ${OK_BUTTON_REF}>${options.okBtnText}</button>
        </div>
      `;
}
function createDayViewTemplate(date, selectedDate, options, classes) {
  const dates = getDatesArray(date, selectedDate, options);
  const dayNames = options.weekdaysNarrow;
  const tableHeadContent = `
      <tr>
        ${dayNames.map((name, i) => {
    return `<th class="${classes.datepickerDayHeading}" scope="col" aria-label="${options.weekdaysFull[i]}">${name}</th>`;
  }).join("")}
      </tr>
    `;
  const tableBodyContent = dates.map((week) => {
    return `
        <tr>
          ${week.map((day) => {
      return `
              <td
              class="${classes.datepickerCell} ${classes.datepickerCellSmall}"
              data-te-date="${getYear(day.date)}-${getMonth(
        day.date
      )}-${getDate(day.date)}"
              aria-label="${day.date}"
              aria-selected="${day.isSelected}"
              ${day.isSelected ? "data-te-datepicker-cell-selected" : ""}
              ${!day.currentMonth || day.disabled ? "data-te-datepicker-cell-disabled" : ""}
              ${day.isToday ? "data-te-datepicker-cell-current" : ""}
              >
                <div
                  class="${classes.datepickerCellContent} ${classes.datepickerCellContentSmall}"
                  style="${day.currentMonth ? "display: block" : "display: none"}"
                  >
                  ${day.dayNumber}
                  </div>
              </td>
            `;
    }).join("")}
        </tr>
      `;
  }).join("");
  return `
      <table class="${classes.datepickerTable}">
        <thead>
          ${tableHeadContent}
        </thead>
        <tbody>
         ${tableBodyContent}
        </tbody>
      </table>
    `;
}
function getDatesArray(activeDate, selectedDate, options) {
  const dates = [];
  const month = getMonth(activeDate);
  const previousMonth = getMonth(addMonths(activeDate, -1));
  const nextMonth = getMonth(addMonths(activeDate, 1));
  const year = getYear(activeDate);
  const firstDay = getFirstDayOfWeek(year, month, options);
  const daysInMonth = getDaysInMonth(activeDate);
  const daysInPreviousMonth = getDaysInMonth(addMonths(activeDate, -1));
  const daysInWeek = 7;
  let dayNumber = 1;
  let isCurrentMonth = false;
  for (let i = 1; i < daysInWeek; i++) {
    const week = [];
    if (i === 1) {
      const previousMonthDay = daysInPreviousMonth - firstDay + 1;
      for (let j = previousMonthDay; j <= daysInPreviousMonth; j++) {
        const date = createDate(year, previousMonth, j);
        week.push({
          date,
          currentMonth: isCurrentMonth,
          isSelected: selectedDate && isSameDate(date, selectedDate),
          isToday: isSameDate(date, getToday()),
          dayNumber: getDate(date)
        });
      }
      isCurrentMonth = true;
      const daysLeft = daysInWeek - week.length;
      for (let j = 0; j < daysLeft; j++) {
        const date = createDate(year, month, dayNumber);
        week.push({
          date,
          currentMonth: isCurrentMonth,
          isSelected: selectedDate && isSameDate(date, selectedDate),
          isToday: isSameDate(date, getToday()),
          dayNumber: getDate(date)
        });
        dayNumber++;
      }
    } else {
      for (let j = 1; j < 8; j++) {
        if (dayNumber > daysInMonth) {
          dayNumber = 1;
          isCurrentMonth = false;
        }
        const date = createDate(
          year,
          isCurrentMonth ? month : nextMonth,
          dayNumber
        );
        week.push({
          date,
          currentMonth: isCurrentMonth,
          isSelected: selectedDate && isSameDate(date, selectedDate),
          isToday: isSameDate(date, getToday()),
          dayNumber: getDate(date)
        });
        dayNumber++;
      }
    }
    dates.push(week);
  }
  return dates;
}
function createMonthViewTemplate(year, selectedYear, selectedMonth, options, monthsInRow, classes) {
  const months = getMonthsArray(options, monthsInRow);
  const currentMonth = getMonth(getToday());
  const tableBodyContent = `
      ${months.map((row) => {
    return `
          <tr>
            ${row.map((month) => {
      const monthIndex = options.monthsShort.indexOf(month);
      return `
                <td class="${classes.datepickerCell} ${classes.datepickerCellLarge}" 
                data-te-month="${monthIndex}" data-te-year="${year}" aria-label="${month}, ${year}"
                ${monthIndex === selectedMonth && year === selectedYear ? "data-te-datepicker-cell-selected" : ""}
                ${monthIndex === currentMonth ? "data-te-datepicker-cell-current" : ""}
                >
                  <div class="${classes.datepickerCellContent} ${classes.datepickerCellContentLarge}">${month}</div>
                </td>
              `;
    }).join("")}
          </tr>
        `;
  }).join("")}
    `;
  return `
      <table class="${classes.datepickerTable}">
        <tbody>
         ${tableBodyContent}
        </tbody>
      </table>
    `;
}
function getMonthsArray(options, monthsInRow) {
  const months = [];
  let row = [];
  for (let i = 0; i < options.monthsShort.length; i++) {
    row.push(options.monthsShort[i]);
    if (row.length === monthsInRow) {
      const monthsRow = row;
      months.push(monthsRow);
      row = [];
    }
  }
  return months;
}
function createYearViewTemplate(date, selectedYear, options, yearsInView, yearsInRow, classes) {
  const years = getYearsArray(date, yearsInView, yearsInRow);
  const currentYear = getYear(getToday());
  const tableBodyContent = `
    ${years.map((row) => {
    return `
        <tr>
          ${row.map((year) => {
      return `
              <td class="${classes.datepickerCell} ${classes.datepickerCellLarge} aria-label="${year}" data-te-year="${year}"
              ${year === selectedYear ? "data-te-datepicker-cell-selected" : ""}
              ${year === currentYear ? "data-te-datepicker-cell-current" : ""}
              >
                <div class="${classes.datepickerCellContent} ${classes.datepickerCellContentLarge}">${year}</div>
              </td>
            `;
    }).join("")}
        </tr>
      `;
  }).join("")}
  `;
  return `
      <table class="${classes.datepickerTable}">
        <tbody>
        ${tableBodyContent}
        </tbody>
      </table>
    `;
}
function getYearsArray(date, yearsInView, yearsInRow) {
  const years = [];
  const activeYear = getYear(date);
  const yearsOffset = getYearsOffset(date, yearsInView);
  const firstYearInView = activeYear - yearsOffset;
  let row = [];
  for (let i = 0; i < yearsInView; i++) {
    row.push(firstYearInView + i);
    if (row.length === yearsInRow) {
      const yearsRow = row;
      years.push(yearsRow);
      row = [];
    }
  }
  return years;
}
function getToggleButtonTemplate(id, toggleBtnClasses) {
  return `
    <button id="${id}" type="button" class="${toggleBtnClasses}" data-te-datepicker-toggle-button-ref data-te-datepicker-toggle-ref>
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
      <path fill-rule="evenodd" d="M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z" clip-rule="evenodd" />
      </svg>  
    </button>
  `;
}

// node_modules/tw-elements/dist/src/js/util/keycodes.js
var LEFT_ARROW = 37;
var UP_ARROW = 38;
var RIGHT_ARROW = 39;
var DOWN_ARROW = 40;
var HOME = 36;
var END = 35;
var PAGE_UP = 33;
var PAGE_DOWN = 34;
var ENTER = 13;
var SPACE = 32;
var ESCAPE = 27;
var TAB = 9;
var BACKSPACE = 8;
var DELETE = 46;

// node_modules/tw-elements/dist/src/js/forms/datepicker/index.js
var NAME17 = "datepicker";
var DATA_KEY16 = "te.datepicker";
var EVENT_KEY13 = `.${DATA_KEY16}`;
var DATA_API_KEY9 = ".data-api";
var EVENT_CLOSE2 = `close${EVENT_KEY13}`;
var EVENT_OPEN = `open${EVENT_KEY13}`;
var EVENT_DATE_CHANGE = `dateChange${EVENT_KEY13}`;
var EVENT_CLICK_DATA_API8 = `click${EVENT_KEY13}${DATA_API_KEY9}`;
var MODAL_CONTAINER_NAME = "data-te-datepicker-modal-container-ref";
var DROPDOWN_CONTAINER_NAME = "data-te-datepicker-dropdown-container-ref";
var DATEPICKER_INIT_SELECTOR = "[data-te-datepicker-init]";
var DATEPICKER_TOGGLE_SELECTOR = "[data-te-datepicker-toggle-ref]";
var MODAL_CONTAINER_SELECTOR = `[${MODAL_CONTAINER_NAME}]`;
var DROPDOWN_CONTAINER_SELECTOR = `[${DROPDOWN_CONTAINER_NAME}]`;
var VIEW_CHANGE_BUTTON_SELECTOR = "[data-te-datepicker-view-change-button-ref]";
var PREVIOUS_BUTTON_SELECTOR = "[data-te-datepicker-previous-button-ref]";
var NEXT_BUTTON_SELECTOR = "[data-te-datepicker-next-button-ref]";
var OK_BUTTON_SELECTOR = "[data-te-datepicker-ok-button-ref]";
var CANCEL_BUTTON_SELECTOR = "[data-te-datepicker-cancel-button-ref]";
var CLEAR_BUTTON_SELECTOR = "[data-te-datepicker-clear-button-ref]";
var VIEW_SELECTOR = "[data-te-datepicker-view-ref]";
var TOGGLE_BUTTON_SELECTOR = "[data-te-datepicker-toggle-button-ref]";
var DATE_TEXT_SELECTOR = "[data-te-datepicker-date-text-ref]";
var BACKDROP_SELECTOR = "[data-te-dropdown-backdrop-ref]";
var FADE_IN_CLASSES = "animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none";
var FADE_OUT_CLASSES = "animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none";
var FADE_IN_SHORT_CLASSES = "animate-[fade-in_0.15s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none";
var FADE_OUT_SHORT_CLASSES = "animate-[fade-out_0.15s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none";
var MODAL_CONTAINER_CLASSES = "flex flex-col fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[328px] h-[512px] bg-white rounded-[0.6rem] shadow-lg z-[1066] xs:max-md:landscape:w-[475px] xs:max-md:landscape:h-[360px] xs:max-md:landscape:flex-row dark:bg-zinc-700";
var DATEPICKER_BACKDROP_CLASSES = "w-full h-full fixed top-0 right-0 left-0 bottom-0 bg-black/40 z-[1065]";
var DATEPICKER_MAIN_CLASSES = "relative h-full";
var DATEPICKER_HEADER_CLASSES = "xs:max-md:landscape:h-full h-[120px] px-6 bg-primary flex flex-col rounded-t-lg dark:bg-zinc-800";
var DATEPICKER_TITLE_CLASSES = "h-8 flex flex-col justify-end";
var DATEPICKER_TITLE_TEXT_CLASSES = "text-[10px] font-normal uppercase tracking-[1.7px] text-white";
var DATEPICKER_DATE_CLASSES = "xs:max-md:landscape:mt-24 h-[72px] flex flex-col justify-end";
var DATEPICKER_DATE_TEXT_CLASSES = "text-[34px] font-normal text-white";
var DATEPICKER_VIEW_CLASSES = "outline-none px-3";
var DATEPICKER_DATE_CONTROLS_CLASSES = "px-3 pt-2.5 pb-0 flex justify-between text-black/[64]";
var DATEPICKER_VIEW_CHANGE_BUTTON_CLASSES = `flex items-center outline-none p-2.5 text-neutral-500 font-medium text-[0.9rem] rounded-xl shadow-none bg-transparent m-0 border-none hover:bg-neutral-200 focus:bg-neutral-200  dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10`;
var DATEPICKER_ARROW_CONTROLS_CLASSES = "mt-2.5";
var DATEPICKER_PREVIOUS_BUTTON_CLASSES = "p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent mr-6 hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:mx-auto";
var DATEPICKER_NEXT_BUTTON_CLASSES = "p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:rotate-180 [&>svg]:mx-auto";
var DATEPICKER_FOOTER_CLASSES = "h-14 flex absolute w-full bottom-0 justify-end items-center px-3";
var DATEPICKER_FOOTER_BTN_CLASSES = "outline-none bg-white text-primary border-none cursor-pointer py-0 px-2.5 uppercase text-[0.8rem] leading-10 font-medium h-10 tracking-[.1rem] rounded-[10px] mb-2.5 hover:bg-neutral-200 focus:bg-neutral-200 dark:bg-transparent dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10";
var DATEPICKER_CLEAR_BTN_CLASSES = "mr-auto";
var DATEPICKER_DAY_HEADING_CLASSES = "w-10 h-10 text-center text-[12px] font-normal";
var DATEPICKER_CELL_CLASSES = "text-center data-[te-datepicker-cell-disabled]:text-neutral-300 data-[te-datepicker-cell-disabled]:cursor-default data-[te-datepicker-cell-disabled]:pointer-events-none data-[te-datepicker-cell-disabled]:hover:cursor-default hover:cursor-pointer group";
var DATEPICKER_CELL_SMALL_CLASSES = "w-10 h-10 xs:max-md:landscape:w-8 xs:max-md:landscape:h-8";
var DATEPICKER_CELL_LARGE_CLASSES = "w-[76px] h-[42px]";
var DATEPICKER_CELL_CONTENT_CLASSES = "mx-auto group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-neutral-300 group-[[data-te-datepicker-cell-selected]]:bg-primary group-[[data-te-datepicker-cell-selected]]:text-white group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-neutral-100 group-[[data-te-datepicker-cell-focused]]:data-[te-datepicker-cell-selected]:bg-primary group-[[data-te-datepicker-cell-current]]:border-solid group-[[data-te-datepicker-cell-current]]:border-black group-[[data-te-datepicker-cell-current]]:border dark:group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-white/10 dark:group-[[data-te-datepicker-cell-current]]:border-white dark:group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-white/10";
var DATEPICKER_CELL_CONTENT_SMALL_CLASSES = "w-9 h-9 leading-9 rounded-[50%] text-[13px]";
var DATEPICKER_CELL_CONTENT_LARGE_CLASSES = "w-[72px] h-10 leading-10 py-[1px] px-0.5 rounded-[999px]";
var DATEPICKER_TABLE_CLASSES = "mx-auto w-[304px]";
var DATEPICKER_TOGGLE_BUTTON_CLASSES = "flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-2.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200";
var DATEPICKER_VIEW_CHANGE_ICON_CLASSES = "inline-block pointer-events-none ml-[3px] [&>svg]:w-4 [&>svg]:h-4 [&>svg]:fill-neutral-500 dark:[&>svg]:fill-white";
var Default15 = {
  title: "Select date",
  monthsFull: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  monthsShort: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  weekdaysFull: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  weekdaysNarrow: ["S", "M", "T", "W", "T", "F", "S"],
  okBtnText: "Ok",
  clearBtnText: "Clear",
  cancelBtnText: "Cancel",
  okBtnLabel: "Confirm selection",
  clearBtnLabel: "Clear selection",
  cancelBtnLabel: "Cancel selection",
  nextMonthLabel: "Next month",
  prevMonthLabel: "Previous month",
  nextYearLabel: "Next year",
  prevYearLabel: "Previous year",
  changeMonthIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
  </svg>
  `,
  nextMultiYearLabel: "Next 24 years",
  prevMultiYearLabel: "Previous 24 years",
  switchToMultiYearViewLabel: "Choose year and month",
  switchToMonthViewLabel: "Choose date",
  switchToDayViewLabel: "Choose date",
  startDate: null,
  startDay: 0,
  format: "dd/mm/yyyy",
  view: "days",
  viewChangeIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="0" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
  </svg>
  `,
  toggleButton: true,
  disableToggleButton: false,
  disableInput: false
};
var DefaultType15 = {
  title: "string",
  monthsFull: "array",
  monthsShort: "array",
  weekdaysFull: "array",
  weekdaysShort: "array",
  weekdaysNarrow: "array",
  okBtnText: "string",
  clearBtnText: "string",
  cancelBtnText: "string",
  okBtnLabel: "string",
  clearBtnLabel: "string",
  cancelBtnLabel: "string",
  nextMonthLabel: "string",
  prevMonthLabel: "string",
  nextYearLabel: "string",
  prevYearLabel: "string",
  nextMultiYearLabel: "string",
  prevMultiYearLabel: "string",
  changeMonthIconTemplate: "string",
  switchToMultiYearViewLabel: "string",
  switchToMonthViewLabel: "string",
  switchToDayViewLabel: "string",
  startDate: "(null|string|date)",
  startDay: "number",
  format: "string",
  view: "string",
  viewChangeIconTemplate: "string",
  toggleButton: "boolean",
  disableToggleButton: "boolean",
  disableInput: "boolean"
};
var DefaultClasses10 = {
  fadeIn: FADE_IN_CLASSES,
  fadeOut: FADE_OUT_CLASSES,
  fadeInShort: FADE_IN_SHORT_CLASSES,
  fadeOutShort: FADE_OUT_SHORT_CLASSES,
  modalContainer: MODAL_CONTAINER_CLASSES,
  datepickerBackdrop: DATEPICKER_BACKDROP_CLASSES,
  datepickerMain: DATEPICKER_MAIN_CLASSES,
  datepickerHeader: DATEPICKER_HEADER_CLASSES,
  datepickerTitle: DATEPICKER_TITLE_CLASSES,
  datepickerTitleText: DATEPICKER_TITLE_TEXT_CLASSES,
  datepickerDate: DATEPICKER_DATE_CLASSES,
  datepickerDateText: DATEPICKER_DATE_TEXT_CLASSES,
  datepickerView: DATEPICKER_VIEW_CLASSES,
  datepickerDateControls: DATEPICKER_DATE_CONTROLS_CLASSES,
  datepickerViewChangeButton: DATEPICKER_VIEW_CHANGE_BUTTON_CLASSES,
  datepickerViewChangeIcon: DATEPICKER_VIEW_CHANGE_ICON_CLASSES,
  datepickerArrowControls: DATEPICKER_ARROW_CONTROLS_CLASSES,
  datepickerPreviousButton: DATEPICKER_PREVIOUS_BUTTON_CLASSES,
  datepickerNextButton: DATEPICKER_NEXT_BUTTON_CLASSES,
  datepickerFooter: DATEPICKER_FOOTER_CLASSES,
  datepickerFooterBtn: DATEPICKER_FOOTER_BTN_CLASSES,
  datepickerClearBtn: DATEPICKER_CLEAR_BTN_CLASSES,
  datepickerDayHeading: DATEPICKER_DAY_HEADING_CLASSES,
  datepickerCell: DATEPICKER_CELL_CLASSES,
  datepickerCellSmall: DATEPICKER_CELL_SMALL_CLASSES,
  datepickerCellLarge: DATEPICKER_CELL_LARGE_CLASSES,
  datepickerCellContent: DATEPICKER_CELL_CONTENT_CLASSES,
  datepickerCellContentSmall: DATEPICKER_CELL_CONTENT_SMALL_CLASSES,
  datepickerCellContentLarge: DATEPICKER_CELL_CONTENT_LARGE_CLASSES,
  datepickerTable: DATEPICKER_TABLE_CLASSES,
  datepickerToggleButton: DATEPICKER_TOGGLE_BUTTON_CLASSES
};
var DefaultClassesType10 = {
  fadeIn: "string",
  fadeOut: "string",
  fadeInShort: "string",
  fadeOutShort: "string",
  modalContainer: "string",
  datepickerBackdrop: "string",
  datepickerMain: "string",
  datepickerHeader: "string",
  datepickerTitle: "string",
  datepickerTitleText: "string",
  datepickerDate: "string",
  datepickerDateText: "string",
  datepickerView: "string",
  datepickerDateControls: "string",
  datepickerViewChangeButton: "string",
  datepickerArrowControls: "string",
  datepickerPreviousButton: "string",
  datepickerNextButton: "string",
  datepickerFooter: "string",
  datepickerFooterBtn: "string",
  datepickerClearBtn: "string",
  datepickerDayHeading: "string",
  datepickerCell: "string",
  datepickerCellSmall: "string",
  datepickerCellLarge: "string",
  datepickerCellContent: "string",
  datepickerCellContentSmall: "string",
  datepickerCellContentLarge: "string",
  datepickerTable: "string",
  datepickerToggleButton: "string"
};
var Datepicker = class {
  constructor(element2, options, classes) {
    this._element = element2;
    this._input = selector_engine_default.findOne("input", this._element);
    this._options = this._getConfig(options);
    this._classes = this._getClasses(classes);
    this._activeDate = new Date();
    this._selectedDate = null;
    this._selectedYear = null;
    this._selectedMonth = null;
    this._view = this._options.view;
    this._popper = null;
    this._focusTrap = null;
    this._isOpen = false;
    this._toggleButtonId = getUID("datepicker-toggle-");
    if (this._element) {
      data_default.setData(element2, DATA_KEY16, this);
    }
    this._init();
    if (this.toggleButton && this._options.disableToggle) {
      this.toggleButton.disabled = "true";
    }
    if (this._options.disableInput) {
      this._input.disabled = "true";
    }
  }
  // Getters
  static get NAME() {
    return NAME17;
  }
  get container() {
    return selector_engine_default.findOne(
      `[${MODAL_CONTAINER_NAME}='${this._toggleButtonId}']`
    ) || selector_engine_default.findOne(
      `[${DROPDOWN_CONTAINER_NAME}='${this._toggleButtonId}']`
    );
  }
  get options() {
    return this._options;
  }
  get activeCell() {
    let activeCell;
    if (this._view === "days") {
      activeCell = this._getActiveDayCell();
    }
    if (this._view === "months") {
      activeCell = this._getActiveMonthCell();
    }
    if (this._view === "years") {
      activeCell = this._getActiveYearCell();
    }
    return activeCell;
  }
  get activeDay() {
    return getDate(this._activeDate);
  }
  get activeMonth() {
    return getMonth(this._activeDate);
  }
  get activeYear() {
    return getYear(this._activeDate);
  }
  get firstYearInView() {
    return this.activeYear - getYearsOffset(this._activeDate, 24);
  }
  get lastYearInView() {
    return this.firstYearInView + 24 - 1;
  }
  get viewChangeButton() {
    return selector_engine_default.findOne(VIEW_CHANGE_BUTTON_SELECTOR, this.container);
  }
  get previousButton() {
    return selector_engine_default.findOne(PREVIOUS_BUTTON_SELECTOR, this.container);
  }
  get nextButton() {
    return selector_engine_default.findOne(NEXT_BUTTON_SELECTOR, this.container);
  }
  get okButton() {
    return selector_engine_default.findOne(OK_BUTTON_SELECTOR, this.container);
  }
  get cancelButton() {
    return selector_engine_default.findOne(CANCEL_BUTTON_SELECTOR, this.container);
  }
  get clearButton() {
    return selector_engine_default.findOne(CLEAR_BUTTON_SELECTOR, this.container);
  }
  get datesContainer() {
    return selector_engine_default.findOne(VIEW_SELECTOR, this.container);
  }
  get toggleButton() {
    return selector_engine_default.findOne(TOGGLE_BUTTON_SELECTOR, this._element);
  }
  _getConfig(config) {
    const dataAttributes = manipulator_default.getDataAttributes(this._element);
    config = {
      ...Default15,
      ...dataAttributes,
      ...config
    };
    typeCheckConfig(NAME17, config, DefaultType15);
    if (config.startDay && config.startDay !== 0) {
      const sortedWeekdaysNarrow = this._getNewDaysOrderArray(config);
      config.weekdaysNarrow = sortedWeekdaysNarrow;
    }
    return config;
  }
  _getClasses(classes) {
    const dataAttributes = manipulator_default.getDataClassAttributes(this._element);
    classes = {
      ...DefaultClasses10,
      ...dataAttributes,
      ...classes
    };
    typeCheckConfig(NAME17, classes, DefaultClassesType10);
    return classes;
  }
  _getNewDaysOrderArray(config) {
    const index = config.startDay;
    const weekdaysNarrow = config.weekdaysNarrow;
    const sortedWeekdays = weekdaysNarrow.slice(index).concat(weekdaysNarrow.slice(0, index));
    return sortedWeekdays;
  }
  _init() {
    if (!this.toggleButton && this._options.toggleButton) {
      this._appendToggleButton();
      if (this._input.readOnly || this._input.disabled) {
        this.toggleButton.style.pointerEvents = "none";
      }
    }
    this._listenToUserInput();
    this._listenToToggleClick();
    this._listenToToggleKeydown();
  }
  _appendToggleButton() {
    const toggleButton = getToggleButtonTemplate(
      this._toggleButtonId,
      this._classes.datepickerToggleButton
    );
    this._element.insertAdjacentHTML("beforeend", toggleButton);
  }
  open() {
    if (this._input.readOnly || this._input.disabled) {
      return;
    }
    const openEvent = event_handler_default.trigger(this._element, EVENT_OPEN);
    if (this._isOpen || openEvent.defaultPrevented) {
      return;
    }
    this._setInitialDate();
    const backdrop = getBackdropTemplate(this._classes.datepickerBackdrop);
    const template = getDatepickerTemplate(
      this._activeDate,
      this._selectedDate,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      4,
      24,
      24,
      this._toggleButtonId,
      this._classes
    );
    this._openModal(backdrop, template);
    manipulator_default.addClass(this.container, this._classes.fadeIn);
    manipulator_default.addClass(backdrop, this._classes.fadeInShort);
    this._setFocusTrap(this.container);
    this._listenToDateSelection();
    this._addControlsListeners();
    this._listenToEscapeClick();
    this._listenToKeyboardNavigation();
    this._listenToDatesContainerFocus();
    this._listenToDatesContainerBlur();
    this._asyncFocusDatesContainer();
    this._updateViewControlsAndAttributes(this._view);
    this._isOpen = true;
    setTimeout(() => {
      this._listenToOutsideClick();
    }, 0);
  }
  _openDropdown(template) {
    this._popper = createPopper3(this._input, template, {
      placement: "bottom-start"
    });
    document.body.appendChild(template);
  }
  _openModal(backdrop, template) {
    document.body.appendChild(backdrop);
    document.body.appendChild(template);
    const hasVerticalScroll = window.innerWidth > document.documentElement.clientWidth;
    const scrollHeight = `${Math.abs(
      window.innerWidth - document.documentElement.clientWidth
    )}px`;
    if (hasVerticalScroll) {
      document.body.style.overflow = "hidden";
      document.body.style.paddingRight = scrollHeight;
    }
  }
  _setFocusTrap(element2) {
    this._focusTrap = new focusTrap_default(element2, {
      event: "keydown",
      condition: (event) => event.key === "Tab"
    });
    this._focusTrap.trap();
  }
  _listenToUserInput() {
    event_handler_default.on(this._input, "input", (event) => {
      this._handleUserInput(event.target.value);
    });
  }
  _listenToToggleClick() {
    event_handler_default.on(
      this._element,
      EVENT_CLICK_DATA_API8,
      DATEPICKER_TOGGLE_SELECTOR,
      (event) => {
        event.preventDefault();
        this.open();
      }
    );
  }
  _listenToToggleKeydown() {
    event_handler_default.on(
      this._element,
      "keydown",
      DATEPICKER_TOGGLE_SELECTOR,
      (event) => {
        if (event.keyCode === ENTER && !this._isOpen) {
          this.open();
        }
      }
    );
  }
  _listenToDateSelection() {
    event_handler_default.on(this.datesContainer, "click", (e) => {
      const dataset = e.target.nodeName === "DIV" ? e.target.parentNode.dataset : e.target.dataset;
      const cell = e.target.nodeName === "DIV" ? e.target.parentNode : e.target;
      if (dataset.teDate) {
        this._pickDay(dataset.teDate, cell);
      }
      if (dataset.teMonth && dataset.teYear) {
        const month = parseInt(dataset.teMonth, 10);
        const year = parseInt(dataset.teYear, 10);
        this._pickMonth(month, year);
      }
      if (dataset.teYear && !dataset.teMonth) {
        const year = parseInt(dataset.teYear, 10);
        this._pickYear(year);
      }
      this._updateHeaderDate(
        this._activeDate,
        this._options.monthsShort,
        this._options.weekdaysShort
      );
    });
  }
  _updateHeaderDate(date, monthNames, dayNames) {
    const headerDateEl = selector_engine_default.findOne(
      DATE_TEXT_SELECTOR,
      this.container
    );
    const month = getMonth(date);
    const day = getDate(date);
    const dayNumber = getDayNumber(date);
    headerDateEl.innerHTML = `${dayNames[dayNumber]}, ${monthNames[month]} ${day}`;
  }
  _addControlsListeners() {
    event_handler_default.on(this.nextButton, "click", () => {
      if (this._view === "days") {
        this.nextMonth();
      } else if (this._view === "years") {
        this.nextYears();
      } else {
        this.nextYear();
      }
    });
    event_handler_default.on(this.previousButton, "click", () => {
      if (this._view === "days") {
        this.previousMonth();
      } else if (this._view === "years") {
        this.previousYears();
      } else {
        this.previousYear();
      }
    });
    event_handler_default.on(this.viewChangeButton, "click", () => {
      if (this._view === "days") {
        this._changeView("years");
      } else if (this._view === "years" || this._view === "months") {
        this._changeView("days");
      }
    });
    this._listenToFooterButtonsClick();
  }
  _listenToFooterButtonsClick() {
    event_handler_default.on(this.okButton, "click", () => this.handleOk());
    event_handler_default.on(this.cancelButton, "click", () => this.handleCancel());
    event_handler_default.on(this.clearButton, "click", () => this.handleClear());
  }
  _listenToOutsideClick() {
    event_handler_default.on(document, EVENT_CLICK_DATA_API8, (e) => {
      const isContainer = e.target === this.container;
      const isContainerContent = this.container && this.container.contains(e.target);
      if (!isContainer && !isContainerContent) {
        this.close();
      }
    });
  }
  _listenToEscapeClick() {
    event_handler_default.on(document, "keydown", (event) => {
      if (event.keyCode === ESCAPE && this._isOpen) {
        this.close();
      }
    });
  }
  _listenToKeyboardNavigation() {
    event_handler_default.on(this.datesContainer, "keydown", (event) => {
      this._handleKeydown(event);
    });
  }
  _listenToDatesContainerFocus() {
    event_handler_default.on(this.datesContainer, "focus", () => {
      this._focusActiveCell(this.activeCell);
    });
  }
  _listenToDatesContainerBlur() {
    event_handler_default.on(this.datesContainer, "blur", () => {
      this._removeCurrentFocusStyles();
    });
  }
  _handleKeydown(event) {
    if (this._view === "days") {
      this._handleDaysViewKeydown(event);
    }
    if (this._view === "months") {
      this._handleMonthsViewKeydown(event);
    }
    if (this._view === "years") {
      this._handleYearsViewKeydown(event);
    }
  }
  _handleDaysViewKeydown(event) {
    const oldActiveDate = this._activeDate;
    const previousActiveCell = this.activeCell;
    switch (event.keyCode) {
      case LEFT_ARROW:
        this._activeDate = addDays(this._activeDate, -1);
        break;
      case RIGHT_ARROW:
        this._activeDate = addDays(this._activeDate, 1);
        break;
      case UP_ARROW:
        this._activeDate = addDays(this._activeDate, -7);
        break;
      case DOWN_ARROW:
        this._activeDate = addDays(this._activeDate, 7);
        break;
      case HOME:
        this._activeDate = addDays(
          this._activeDate,
          1 - getDate(this._activeDate)
        );
        break;
      case END:
        this._activeDate = addDays(
          this._activeDate,
          getDaysInMonth(this._activeDate) - getDate(this._activeDate)
        );
        break;
      case PAGE_UP:
        this._activeDate = addMonths(this._activeDate, -1);
        break;
      case PAGE_DOWN:
        this._activeDate = addMonths(this._activeDate, 1);
        break;
      case ENTER:
      case SPACE:
        this._selectDate(this._activeDate);
        event.preventDefault();
        return;
      default:
        return;
    }
    if (!areDatesInSameView(oldActiveDate, this._activeDate, this._view, 24, 0)) {
      this._changeView("days");
    }
    this._removeHighlightFromCell(previousActiveCell);
    this._focusActiveCell(this.activeCell);
    event.preventDefault();
  }
  _asyncFocusDatesContainer() {
    setTimeout(() => {
      this.datesContainer.focus();
    }, 0);
  }
  _focusActiveCell(cell) {
    if (cell) {
      cell.setAttribute("data-te-datepicker-cell-focused", "");
    }
  }
  _removeHighlightFromCell(cell) {
    if (cell) {
      cell.removeAttribute("data-te-datepicker-cell-focused");
    }
  }
  _getActiveDayCell() {
    const cells = selector_engine_default.find("td", this.datesContainer);
    const activeCell = Array.from(cells).find((cell) => {
      const cellDate = convertStringToDate(cell.dataset.teDate);
      return isSameDate(cellDate, this._activeDate);
    });
    return activeCell;
  }
  _handleMonthsViewKeydown(event) {
    const oldActiveDate = this._activeDate;
    const previousActiveCell = this.activeCell;
    switch (event.keyCode) {
      case LEFT_ARROW:
        this._activeDate = addMonths(this._activeDate, -1);
        break;
      case RIGHT_ARROW:
        this._activeDate = addMonths(this._activeDate, 1);
        break;
      case UP_ARROW:
        this._activeDate = addMonths(this._activeDate, -4);
        break;
      case DOWN_ARROW:
        this._activeDate = addMonths(this._activeDate, 4);
        break;
      case HOME:
        this._activeDate = addMonths(this._activeDate, -this.activeMonth);
        break;
      case END:
        this._activeDate = addMonths(this._activeDate, 11 - this.activeMonth);
        break;
      case PAGE_UP:
        this._activeDate = addYears(this._activeDate, -1);
        break;
      case PAGE_DOWN:
        this._activeDate = addYears(this._activeDate, 1);
        break;
      case ENTER:
      case SPACE:
        this._selectMonth(this.activeMonth);
        return;
      default:
        return;
    }
    if (!areDatesInSameView(oldActiveDate, this._activeDate, this._view, 24, 0)) {
      this._changeView("months");
    }
    this._removeHighlightFromCell(previousActiveCell);
    this._focusActiveCell(this.activeCell);
    event.preventDefault();
  }
  _getActiveMonthCell() {
    const cells = selector_engine_default.find("td", this.datesContainer);
    const activeCell = Array.from(cells).find((cell) => {
      const cellYear = parseInt(cell.dataset.teYear, 10);
      const cellMonth = parseInt(cell.dataset.teMonth, 10);
      return cellYear === this.activeYear && cellMonth === this.activeMonth;
    });
    return activeCell;
  }
  _handleYearsViewKeydown(event) {
    const oldActiveDate = this._activeDate;
    const previousActiveCell = this.activeCell;
    const yearsPerRow = 4;
    const yearsPerPage = 24;
    switch (event.keyCode) {
      case LEFT_ARROW:
        this._activeDate = addYears(this._activeDate, -1);
        break;
      case RIGHT_ARROW:
        this._activeDate = addYears(this._activeDate, 1);
        break;
      case UP_ARROW:
        this._activeDate = addYears(this._activeDate, -yearsPerRow);
        break;
      case DOWN_ARROW:
        this._activeDate = addYears(this._activeDate, yearsPerRow);
        break;
      case HOME:
        this._activeDate = addYears(
          this._activeDate,
          -getYearsOffset(this._activeDate, yearsPerPage)
        );
        break;
      case END:
        this._activeDate = addYears(
          this._activeDate,
          yearsPerPage - getYearsOffset(this._activeDate, yearsPerPage) - 1
        );
        break;
      case PAGE_UP:
        this._activeDate = addYears(this._activeDate, -yearsPerPage);
        break;
      case PAGE_DOWN:
        this._activeDate = addYears(this._activeDate, yearsPerPage);
        break;
      case ENTER:
      case SPACE:
        this._selectYear(this.activeYear);
        return;
      default:
        return;
    }
    if (!areDatesInSameView(oldActiveDate, this._activeDate, this._view, 24, 0)) {
      this._changeView("years");
    }
    this._removeHighlightFromCell(previousActiveCell);
    this._focusActiveCell(this.activeCell);
    event.preventDefault();
  }
  _getActiveYearCell() {
    const cells = selector_engine_default.find("td", this.datesContainer);
    const activeCell = Array.from(cells).find((cell) => {
      const cellYear = parseInt(cell.dataset.teYear, 10);
      return cellYear === this.activeYear;
    });
    return activeCell;
  }
  _setInitialDate() {
    if (this._input.value) {
      this._handleUserInput(this._input.value);
    } else if (this._options.startDate) {
      this._activeDate = new Date(this._options.startDate);
    } else {
      this._activeDate = new Date();
    }
  }
  close() {
    const closeEvent = event_handler_default.trigger(this._element, EVENT_CLOSE2);
    if (!this._isOpen || closeEvent.defaultPrevented) {
      return;
    }
    this._removeDatepickerListeners();
    manipulator_default.addClass(this.container, this._classes.fadeOut);
    this._closeModal();
    this._isOpen = false;
    this._view = this._options.view;
    if (this.toggleButton) {
      this.toggleButton.focus();
    } else {
      this._input.focus();
    }
  }
  _closeDropdown() {
    const datepicker = selector_engine_default.findOne(DROPDOWN_CONTAINER_SELECTOR);
    if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
      if (datepicker) {
        document.body.removeChild(datepicker);
      }
      if (this._popper) {
        this._popper.destroy();
      }
    }
    datepicker.addEventListener("animationend", () => {
      if (datepicker) {
        document.body.removeChild(datepicker);
      }
      if (this._popper) {
        this._popper.destroy();
      }
    });
    this._removeFocusTrap();
  }
  _closeModal() {
    const backdrop = selector_engine_default.findOne(BACKDROP_SELECTOR);
    const datepicker = selector_engine_default.findOne(MODAL_CONTAINER_SELECTOR);
    manipulator_default.addClass(backdrop, this._classes.fadeOutShort);
    if (datepicker && backdrop) {
      if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
        document.body.removeChild(backdrop);
        document.body.removeChild(datepicker);
        document.body.style.overflow = "";
        document.body.style.paddingRight = "";
        return;
      }
      backdrop.addEventListener("animationend", () => {
        document.body.removeChild(backdrop);
        document.body.removeChild(datepicker);
        document.body.style.overflow = "";
        document.body.style.paddingRight = "";
      });
    }
  }
  _removeFocusTrap() {
    if (this._focusTrap) {
      this._focusTrap.disable();
      this._focusTrap = null;
    }
  }
  _removeDatepickerListeners() {
    event_handler_default.off(this.nextButton, "click");
    event_handler_default.off(this.previousButton, "click");
    event_handler_default.off(this.viewChangeButton, "click");
    event_handler_default.off(this.okButton, "click");
    event_handler_default.off(this.cancelButton, "click");
    event_handler_default.off(this.clearButton, "click");
    event_handler_default.off(this.datesContainer, "click");
    event_handler_default.off(this.datesContainer, "keydown");
    event_handler_default.off(this.datesContainer, "focus");
    event_handler_default.off(this.datesContainer, "blur");
    event_handler_default.off(document, EVENT_CLICK_DATA_API8);
  }
  dispose() {
    if (this._isOpen) {
      this.close();
    }
    this._removeInputAndToggleListeners();
    const generatedToggleButton = selector_engine_default.findOne(
      `#${this._toggleButtonId}`
    );
    if (generatedToggleButton) {
      this._element.removeChild(generatedToggleButton);
    }
    data_default.removeData(this._element, DATA_KEY16);
    this._element = null;
    this._input = null;
    this._options = null;
    this._activeDate = null;
    this._selectedDate = null;
    this._selectedYear = null;
    this._selectedMonth = null;
    this._view = null;
    this._popper = null;
    this._focusTrap = null;
  }
  _removeInputAndToggleListeners() {
    event_handler_default.off(this._input, "input");
    event_handler_default.off(
      this._element,
      EVENT_CLICK_DATA_API8,
      DATEPICKER_TOGGLE_SELECTOR
    );
    event_handler_default.off(this._element, "keydown", DATEPICKER_TOGGLE_SELECTOR);
  }
  handleOk() {
    this._confirmSelection(this._selectedDate);
    this.close();
  }
  _selectDate(date, cell = this.activeCell) {
    this._removeCurrentSelectionStyles();
    this._removeCurrentFocusStyles();
    this._addSelectedStyles(cell);
    this._selectedDate = date;
  }
  _selectYear(year, cell = this.activeCell) {
    this._removeCurrentSelectionStyles();
    this._removeCurrentFocusStyles();
    this._addSelectedStyles(cell);
    this._selectedYear = year;
    this._asyncChangeView("months");
  }
  _selectMonth(month, cell = this.activeCell) {
    this._removeCurrentSelectionStyles();
    this._removeCurrentFocusStyles();
    this._addSelectedStyles(cell);
    this._selectedMonth = month;
    this._asyncChangeView("days");
  }
  _removeSelectedStyles(cell) {
    if (cell) {
      cell.removeAttribute("data-te-datepicker-cell-selected");
    }
  }
  _addSelectedStyles(cell) {
    if (cell) {
      cell.setAttribute("data-te-datepicker-cell-selected", "");
    }
  }
  _confirmSelection(date) {
    if (date) {
      const dateString = this.formatDate(date);
      this._input.value = dateString;
      event_handler_default.trigger(this._element, EVENT_DATE_CHANGE, { date });
      event_handler_default.trigger(this._input, "input");
    }
  }
  handleCancel() {
    this._selectedDate = null;
    this._selectedYear = null;
    this._selectedMonth = null;
    this.close();
  }
  handleClear() {
    this._selectedDate = null;
    this._selectedMonth = null;
    this._selectedYear = null;
    this._removeCurrentSelectionStyles();
    this._input.value = "";
    this._setInitialDate();
    this._changeView("days");
  }
  _removeCurrentSelectionStyles() {
    const currentSelected = selector_engine_default.findOne(
      "[data-te-datepicker-cell-selected]",
      this.container
    );
    if (currentSelected) {
      currentSelected.removeAttribute("data-te-datepicker-cell-selected");
    }
  }
  _removeCurrentFocusStyles() {
    const currentFocused = selector_engine_default.findOne(
      "[data-te-datepicker-cell-focused]",
      this.container
    );
    if (currentFocused) {
      currentFocused.removeAttribute("data-te-datepicker-cell-focused");
    }
  }
  formatDate(date) {
    const d = getDate(date);
    const dd = this._addLeadingZero(getDate(date));
    const ddd = this._options.weekdaysShort[getDayNumber(date)];
    const dddd = this._options.weekdaysFull[getDayNumber(date)];
    const m = getMonth(date) + 1;
    const mm = this._addLeadingZero(getMonth(date) + 1);
    const mmm = this._options.monthsShort[getMonth(date)];
    const mmmm = this._options.monthsFull[getMonth(date)];
    const yy = getYear(date).toString().length === 2 ? getYear(date) : getYear(date).toString().slice(2, 4);
    const yyyy = getYear(date);
    const preformatted = this._options.format.split(
      /(d{1,4}|m{1,4}|y{4}|yy|!.)/g
    );
    let formatted = "";
    preformatted.forEach((datePart) => {
      switch (datePart) {
        case "dddd":
          datePart = datePart.replace(datePart, dddd);
          break;
        case "ddd":
          datePart = datePart.replace(datePart, ddd);
          break;
        case "dd":
          datePart = datePart.replace(datePart, dd);
          break;
        case "d":
          datePart = datePart.replace(datePart, d);
          break;
        case "mmmm":
          datePart = datePart.replace(datePart, mmmm);
          break;
        case "mmm":
          datePart = datePart.replace(datePart, mmm);
          break;
        case "mm":
          datePart = datePart.replace(datePart, mm);
          break;
        case "m":
          datePart = datePart.replace(datePart, m);
          break;
        case "yyyy":
          datePart = datePart.replace(datePart, yyyy);
          break;
        case "yy":
          datePart = datePart.replace(datePart, yy);
          break;
        default:
      }
      formatted += datePart;
    });
    return formatted;
  }
  _addLeadingZero(value) {
    return parseInt(value, 10) < 10 ? `0${value}` : value;
  }
  _pickDay(day, el) {
    const date = convertStringToDate(day);
    this._activeDate = date;
    this._selectDate(date, el);
  }
  _pickYear(year) {
    const newDate = createDate(year, this.activeMonth, this.activeDay);
    this._activeDate = newDate;
    this._selectedDate = newDate;
    this._selectYear(year);
  }
  _pickMonth(month, year) {
    const newDate = createDate(year, month, this.activeDay);
    this._activeDate = newDate;
    this._selectMonth(month);
  }
  nextMonth() {
    const nextMonth = addMonths(this._activeDate, 1);
    const template = createDayViewTemplate(
      nextMonth,
      this._selectedDate,
      this._options,
      this._classes
    );
    this._activeDate = nextMonth;
    this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`;
    this.viewChangeButton.innerHTML += createViewChangeButtonIcon(
      this._options,
      this._classes
    );
    this.datesContainer.innerHTML = template;
  }
  previousMonth() {
    const previousMonth = addMonths(this._activeDate, -1);
    this._activeDate = previousMonth;
    const template = createDayViewTemplate(
      previousMonth,
      this._selectedDate,
      this._options,
      this._classes
    );
    this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`;
    this.viewChangeButton.innerHTML += createViewChangeButtonIcon(
      this._options,
      this._classes
    );
    this.datesContainer.innerHTML = template;
  }
  nextYear() {
    const nextYear = addYears(this._activeDate, 1);
    this._activeDate = nextYear;
    this.viewChangeButton.textContent = `${this.activeYear}`;
    this.viewChangeButton.innerHTML += createViewChangeButtonIcon(
      this._options,
      this._classes
    );
    const template = createMonthViewTemplate(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      4,
      this._classes
    );
    this.datesContainer.innerHTML = template;
  }
  previousYear() {
    const previousYear = addYears(this._activeDate, -1);
    this._activeDate = previousYear;
    this.viewChangeButton.textContent = `${this.activeYear}`;
    this.viewChangeButton.innerHTML += createViewChangeButtonIcon(
      this._options,
      this._classes
    );
    const template = createMonthViewTemplate(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      4,
      this._classes
    );
    this.datesContainer.innerHTML = template;
  }
  nextYears() {
    const nextYear = addYears(this._activeDate, 24);
    this._activeDate = nextYear;
    const template = createYearViewTemplate(
      nextYear,
      this._selectedYear,
      this._options,
      24,
      4,
      this._classes
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`;
    this.viewChangeButton.innerHTML += createViewChangeButtonIcon(
      this._options,
      this._classes
    );
    this.datesContainer.innerHTML = template;
  }
  previousYears() {
    const previousYear = addYears(this._activeDate, -24);
    this._activeDate = previousYear;
    const template = createYearViewTemplate(
      previousYear,
      this._selectedYear,
      this._options,
      24,
      4,
      this._classes
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`;
    this.viewChangeButton.innerHTML += createViewChangeButtonIcon(
      this._options,
      this._classes
    );
    this.datesContainer.innerHTML = template;
  }
  _asyncChangeView(view) {
    setTimeout(() => {
      this._changeView(view);
    }, 0);
  }
  _changeView(view) {
    this._view = view;
    this.datesContainer.blur();
    if (view === "days") {
      this.datesContainer.innerHTML = createDayViewTemplate(
        this._activeDate,
        this._selectedDate,
        this._options,
        this._classes
      );
    }
    if (view === "months") {
      this.datesContainer.innerHTML = createMonthViewTemplate(
        this.activeYear,
        this._selectedYear,
        this._selectedMonth,
        this._options,
        4,
        this._classes
      );
    }
    if (view === "years") {
      this.datesContainer.innerHTML = createYearViewTemplate(
        this._activeDate,
        this._selectedYear,
        this._options,
        24,
        4,
        this._classes
      );
    }
    this.datesContainer.focus();
    this._updateViewControlsAndAttributes(view);
  }
  _updateViewControlsAndAttributes(view) {
    if (view === "days") {
      this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`;
      this.viewChangeButton.innerHTML += createViewChangeButtonIcon(
        this._options,
        this._classes
      );
      this.viewChangeButton.setAttribute(
        "aria-label",
        this._options.switchToMultiYearViewLabel
      );
      this.previousButton.setAttribute(
        "aria-label",
        this._options.prevMonthLabel
      );
      this.nextButton.setAttribute("aria-label", this._options.nextMonthLabel);
    }
    if (view === "months") {
      this.viewChangeButton.textContent = `${this.activeYear}`;
      this.viewChangeButton.innerHTML += createViewChangeButtonIcon(
        this._options,
        this._classes
      );
      this.viewChangeButton.setAttribute(
        "aria-label",
        this._options.switchToDayViewLabel
      );
      this.previousButton.setAttribute(
        "aria-label",
        this._options.prevYearLabel
      );
      this.nextButton.setAttribute("aria-label", this._options.nextYearLabel);
    }
    if (view === "years") {
      this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`;
      this.viewChangeButton.innerHTML += createViewChangeButtonIcon(
        this._options,
        this._classes
      );
      this.viewChangeButton.setAttribute(
        "aria-label",
        this._options.switchToMonthViewLabel
      );
      this.previousButton.setAttribute(
        "aria-label",
        this._options.prevMultiYearLabel
      );
      this.nextButton.setAttribute(
        "aria-label",
        this._options.nextMultiYearLabel
      );
    }
  }
  _handleUserInput(input) {
    const delimeters = this._getDelimeters(this._options.format);
    const date = this._parseDate(input, this._options.format, delimeters);
    if (isValidDate(date)) {
      this._activeDate = date;
      this._selectedDate = date;
    } else {
      this._activeDate = new Date();
      this._selectedDate = null;
      this._selectedMonth = null;
      this._selectedYear = null;
    }
  }
  _getDelimeters(format2) {
    return format2.match(/[^(dmy)]{1,}/g);
  }
  _parseDate(dateString, format2, delimeters) {
    let delimeterPattern;
    if (delimeters[0] !== delimeters[1]) {
      delimeterPattern = delimeters[0] + delimeters[1];
    } else {
      delimeterPattern = delimeters[0];
    }
    const regExp = new RegExp(`[${delimeterPattern}]`);
    const dateParts = dateString.split(regExp);
    const formatParts = format2.split(regExp);
    const isMonthString = format2.indexOf("mmm") !== -1;
    const datesArray = [];
    for (let i = 0; i < formatParts.length; i++) {
      if (formatParts[i].indexOf("yy") !== -1) {
        datesArray[0] = { value: dateParts[i], format: formatParts[i] };
      }
      if (formatParts[i].indexOf("m") !== -1) {
        datesArray[1] = { value: dateParts[i], format: formatParts[i] };
      }
      if (formatParts[i].indexOf("d") !== -1 && formatParts[i].length <= 2) {
        datesArray[2] = { value: dateParts[i], format: formatParts[i] };
      }
    }
    let monthsNames;
    if (format2.indexOf("mmmm") !== -1) {
      monthsNames = this._options.monthsFull;
    } else {
      monthsNames = this._options.monthsShort;
    }
    const year = Number(datesArray[0].value);
    const month = isMonthString ? this.getMonthNumberByMonthName(datesArray[1].value, monthsNames) : Number(datesArray[1].value) - 1;
    const day = Number(datesArray[2].value);
    const parsedDate = createDate(year, month, day);
    return parsedDate;
  }
  getMonthNumberByMonthName(monthValue, monthLabels) {
    return monthLabels.findIndex((monthLabel) => monthLabel === monthValue);
  }
  static getInstance(element2) {
    return data_default.getData(element2, DATA_KEY16);
  }
  static getOrCreateInstance(element2, config = {}) {
    return this.getInstance(element2) || new this(element2, typeof config === "object" ? config : null);
  }
};
var datepicker_default = Datepicker;
selector_engine_default.find(DATEPICKER_INIT_SELECTOR).forEach((datepicker) => {
  let instance = Datepicker.getInstance(datepicker);
  if (!instance) {
    instance = new Datepicker(datepicker);
  }
});

// node_modules/tw-elements/dist/src/js/forms/timepicker/templates.js
var getTimepickerTemplate = ({
  format24,
  okLabel,
  cancelLabel,
  headID,
  footerID,
  bodyID,
  pickerID,
  clearLabel,
  inline,
  showClearBtn,
  amLabel,
  pmLabel
}, classes) => {
  const normalTemplate = `<div id='${pickerID}' class='${classes.timepickerWrapper}' data-te-timepicker-wrapper>
      <div class="${classes.timepickerContainer}">
        <div class="${classes.timepickerElements}">
        <div id='${headID}' class='${classes.timepickerHead}' style='padding-right:${format24 ? 50 : 10}px'>
        <div class='${classes.timepickerHeadContent}'>
            <div class="${classes.timepickerCurrentWrapper}">
              <span class="${classes.timepickerCurrentButtonWrapper}">
                <button type='button' class='${classes.timepickerCurrentButton}' tabindex="0" data-te-timepicker-active data-te-timepicker-current data-te-timepicker-hour data-te-ripple-init>21</button>
              </span>
              <button type='button' class='${classes.timepickerDot}' disabled>:</button>
            <span class="${classes.timepickerCurrentButtonWrapper}">
              <button type='button' class='${classes.timepickerCurrentButton}' tabindex="0" data-te-timepicker-current data-te-timepicker-minute data-te-ripple-init>21</button>
            </span>
            </div>
            ${!format24 ? `<div class="${classes.timepickerModeWrapper}">
                  <button type='button' class="${classes.timepickerModeAm}" tabindex="0" data-te-timepicker-am data-te-timepicker-hour-mode data-te-ripple-init>${amLabel}</button>
                  <button class="${classes.timepickerModePm}" tabindex="0" data-te-timepicker-pm data-te-timepicker-hour-mode data-te-ripple-init>${pmLabel}</button>
                </div>` : ""}
        </div>
      </div>
      ${!inline ? `<div id='${bodyID}' class='${classes.timepickerClockWrapper}' data-te-timepicker-clock-wrapper>
            <div class='${classes.timepickerClock}' data-te-timepicker-clock>
              <span class='${classes.timepickerMiddleDot}' data-te-timepicker-middle-dot></span>
              <div class='${classes.timepickerHandPointer}' data-te-timepicker-hand-pointer>
                <div class='${classes.timepickerPointerCircle}' data-te-timepicker-circle></div>
              </div>
              ${format24 ? '<div class="' + classes.timepickerClockInner + '" data-te-timepicker-clock-inner></div>' : ""}
            </div>
          </div>` : ""}
    </div>
    <div id='${footerID}' class='${classes.timepickerFooterWrapper}'>
      <div class="${classes.timepickerFooter}">
        ${showClearBtn ? `<button type='button' class='${classes.timepickerFooterButton}' data-te-timepicker-clear tabindex="0" data-te-ripple-init>${clearLabel}</button>` : ""}
        <button type='button' class='${classes.timepickerFooterButton}' data-te-timepicker-cancel tabindex="0" data-te-ripple-init>${cancelLabel}</button>
        <button type='button' class='${classes.timepickerFooterButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${okLabel}</button>
      </div>
    </div>
  </div>
</div>`;
  const inlineTemplate = `<div id='${pickerID}' class='${classes.timepickerInlineWrapper}' data-te-timepicker-wrapper>
        <div class="${classes.timepickerInlineContainer}">
          <div class="${classes.timepickerInlineElements}">
          <div id='${headID}' class='${classes.timepickerInlineHead}'
          style='padding-right:10px'>
          <div class='${classes.timepickerInlineHeadContent}'>
              <div class="${classes.timepickerCurrentWrapper}">
                <span class="${classes.timepickerInlineHourWrapper}" data-te-timepicker-inline-hour-icons>
                  <span class="${classes.timepickerInlineIconUp}" data-te-timepicker-icon-up data-te-timepicker-icon-inline-hour>
                    <span class="${classes.timepickerInlineIconSvg}">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                      </svg>   
                    </span>
                  </span>
                  <button type='button' class='${classes.timepickerInlineCurrentButton}' data-te-timepicker-hour data-te-timepicker-current data-te-timepicker-current-inline tabindex="0" data-te-ripple-init>21</button>
                  <span class="${classes.timepickerInlineIconDown}" data-te-timepicker-icon-inline-hour data-te-timepicker-icon-down>
                    <span class="${classes.timepickerInlineIconSvg}">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                      </svg>  
                    </span>
                  </span>
                </span>
                <button type='button' class='${classes.timepickerInlineDot}' data-te-timepicker-current-inline disabled>:</button>
              <span class="${classes.timepickerCurrentMinuteWrapper}">
                <span class="${classes.timepickerInlineIconUp}" data-te-timepicker-icon-up data-te-timepicker-icon-inline-minute>
                  <span class="${classes.timepickerInlineIconSvg}">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                    </svg>
                  </span>
                </span>
                <button type='button' class='${classes.timepickerInlineCurrentButton}' data-te-timepicker-minute data-te-timepicker-current data-te-timepicker-current-inline tabindex="0" data-te-ripple-init>21</button>
                <span class="${classes.timepickerInlineIconDown}" data-te-timepicker-icon-inline-minute data-te-timepicker-icon-down>
                  <span class="${classes.timepickerInlineIconSvg}">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                    </svg> 
                  </span>
                </span>
              </span>
              </div>
              ${!format24 ? `<div class="${classes.timepickerInlineModeWrapper}">
                      <button type='button' class="${classes.timepickerInlineModeAm}" data-te-timepicker-am data-te-timepicker-hour-mode tabindex="0" data-te-ripple-init>${amLabel}</button>
                      <button class="${classes.timepickerInlineModePm}" data-te-timepicker-hour-mode data-te-timepicker-pm tabindex="0" data-te-ripple-init>${pmLabel}</button>
                      <button type='button' class='${classes.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${okLabel}</button>
                    </div>` : ""}
              ${format24 ? `<button class='${classes.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${okLabel}</button>` : ""}
          </div>
        </div>
      </div>
    </div>
</div>`;
  return inline ? inlineTemplate : normalTemplate;
};
var getToggleButtonTemplate2 = (options, id, classes) => {
  const { iconSVG } = options;
  return `
  <button id="${id}" tabindex="0" type="button" class="${classes.timepickerToggleButton}" data-te-toggle="timepicker" data-te-timepicker-toggle-button data-te-timepicker-icon>
    ${iconSVG}
  </button>
`;
};

// node_modules/tw-elements/dist/src/js/forms/timepicker/utils.js
var ATTR_TIMEPICKER_DISABLED = "data-te-timepicker-disabled";
var ATTR_TIMEPICKER_ACTIVE = "data-te-timepicker-active";
var formatToAmPm = (date) => {
  if (date === "")
    return;
  let hours;
  let minutes;
  let amOrPm;
  let originalHours;
  if (isValidDate2(date)) {
    hours = date.getHours();
    originalHours = hours;
    minutes = date.getMinutes();
    hours %= 12;
    if (hours === 0) {
      amOrPm = "AM";
    }
    hours = hours || 12;
    if (amOrPm === void 0) {
      amOrPm = hours === 12 ? "PM" : "AM";
    }
    minutes = minutes < 10 ? `0${minutes}` : minutes;
  } else {
    [hours, minutes, amOrPm] = takeValue(date, false);
    originalHours = hours;
    hours %= 12;
    if (hours === 0) {
      amOrPm = "AM";
    }
    hours = hours || 12;
    if (amOrPm === void 0) {
      amOrPm = originalHours >= 12 ? "PM" : "AM";
    }
  }
  return {
    hours,
    minutes,
    amOrPm
  };
};
var isValidDate2 = (date) => {
  return date && Object.prototype.toString.call(date) === "[object Date]" && !Number.isNaN(date);
};
var formatNormalHours = (date) => {
  if (date === "")
    return;
  let hours;
  let minutes;
  if (!isValidDate2(date)) {
    [hours, minutes] = takeValue(date, false);
  } else {
    hours = date.getHours();
    minutes = date.getMinutes();
  }
  minutes = Number(minutes) < 10 ? `0${Number(minutes)}` : minutes;
  return {
    hours,
    minutes
  };
};
var toggleClassHandler = (event, selector, classes) => {
  return event_handler_default.on(document, event, selector, ({ target }) => {
    if (target.hasAttribute(ATTR_TIMEPICKER_ACTIVE))
      return;
    const allElements = document.querySelectorAll(selector);
    allElements.forEach((element2) => {
      if (!element2.hasAttribute(ATTR_TIMEPICKER_ACTIVE))
        return;
      manipulator_default.removeClass(element2, classes.opacity);
      element2.removeAttribute(ATTR_TIMEPICKER_ACTIVE);
    });
    manipulator_default.addClass(target, classes.opacity);
    target.setAttribute(ATTR_TIMEPICKER_ACTIVE, "");
  });
};
var findMousePosition = ({ clientX, clientY, touches }, object, isMobile = false) => {
  const { left: left2, top: top2 } = object.getBoundingClientRect();
  let obj = {};
  if (!isMobile || !touches) {
    obj = {
      x: clientX - left2,
      y: clientY - top2
    };
  } else if (isMobile && Object.keys(touches).length > 0) {
    obj = {
      x: touches[0].clientX - left2,
      y: touches[0].clientY - top2
    };
  }
  return obj;
};
var checkBrowser = () => {
  const isBrowserMatched = navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
    navigator.userAgent
  );
  return isBrowserMatched;
};
var takeValue = (element2, isInput = true) => {
  if (isInput)
    return element2.value.replace(/:/gi, " ").split(" ");
  return element2.replace(/:/gi, " ").split(" ");
};
var compareTimes = (time1, time2) => {
  const [time1Hour, time1Minutes, time1maxTimeFormat] = takeValue(time1, false);
  const [time2Hour, time2Minutes, time2maxTimeFormat] = takeValue(time2, false);
  const bothFormatsEqual = time1maxTimeFormat === time2maxTimeFormat;
  const condition = time1maxTimeFormat === "PM" && time2maxTimeFormat === "AM" || bothFormatsEqual && time1Hour > time2Hour || time1Minutes > time2Minutes;
  return condition;
};
var getCurrentTime = () => {
  const date = new Date();
  const currentHours = date.getHours();
  const currentMinutes = date.getMinutes();
  const currentTime = `${currentHours}:${currentMinutes < 10 ? `0${currentMinutes}` : currentMinutes}`;
  return currentTime;
};
var setMinTime = (minTime, disabledPast, format12) => {
  if (!disabledPast) {
    return minTime;
  }
  let currentTime = getCurrentTime();
  if (format12) {
    currentTime = `${formatToAmPm(currentTime).hours}:${formatToAmPm(currentTime).minutes} ${formatToAmPm(currentTime).amOrPm}`;
  }
  if (minTime !== "" && compareTimes(currentTime, minTime) || minTime === "") {
    minTime = currentTime;
  }
  return minTime;
};
var setMaxTime = (maxTime, disabledFuture, format12) => {
  if (!disabledFuture)
    return maxTime;
  let currentTime = getCurrentTime();
  if (format12) {
    currentTime = `${formatToAmPm(currentTime).hours}:${formatToAmPm(currentTime).minutes} ${formatToAmPm(currentTime).amOrPm}`;
  }
  if (maxTime !== "" && !compareTimes(currentTime, maxTime) || maxTime === "") {
    maxTime = currentTime;
  }
  return maxTime;
};
var checkValueBeforeAccept = ({ format12, maxTime, minTime, disablePast, disableFuture }, input, hourHeader) => {
  const minute = takeValue(input)[1];
  minTime = setMinTime(minTime, disablePast, format12);
  maxTime = setMaxTime(maxTime, disableFuture, format12);
  const [maxTimeHour, maxTimeMin, maxTimeFormat] = takeValue(maxTime, false);
  const [minTimeHour, minTimeMin, minTimeFormat] = takeValue(minTime, false);
  if (maxTimeFormat !== void 0 || minTimeFormat !== void 0)
    return [hourHeader, minute];
  if (maxTimeHour !== "" && minTimeHour === "" && Number(hourHeader) > Number(maxTimeHour))
    return;
  if (maxTimeHour === "" && minTimeHour !== "" && maxTimeMin === void 0 && minTimeMin !== "" && Number(hourHeader) < Number(minTimeHour))
    return;
  return [hourHeader, minute];
};
var _verifyMaxTimeHourAndAddDisabledClass = (tips, maxTimeHour, classes) => {
  tips.forEach((tip) => {
    if (tip.textContent === "00" || Number(tip.textContent) > maxTimeHour) {
      manipulator_default.addClass(tip, classes.tipsDisabled);
      tip.setAttribute(ATTR_TIMEPICKER_DISABLED, "");
    }
  });
};
var _verifyMinTimeHourAndAddDisabledClass = (tips, minTimeHour, classes) => {
  tips.forEach((tip) => {
    if (tip.textContent !== "00" && Number(tip.textContent) < minTimeHour) {
      manipulator_default.addClass(tip, classes.tipsDisabled);
      tip.setAttribute(ATTR_TIMEPICKER_DISABLED, "");
    }
  });
};
var _verifyMaxTimeMinutesTipsAndAddDisabledClass = (tips, maxMinutes, maxHour, currHour, classes) => {
  tips.forEach((tip) => {
    if (Number(tip.textContent) > maxMinutes && Number(currHour) === Number(maxHour)) {
      manipulator_default.addClass(tip, classes.tipsDisabled);
      tip.setAttribute(ATTR_TIMEPICKER_DISABLED, "");
    }
  });
};
var _verifyMinTimeMinutesTipsAndAddDisabledClass = (tips, minMinutes, minHour, currHour, classes) => {
  tips.forEach((tip) => {
    if (Number(tip.textContent) < minMinutes && Number(currHour) === Number(minHour)) {
      manipulator_default.addClass(tip, classes.tipsDisabled);
      tip.setAttribute(ATTR_TIMEPICKER_DISABLED, "");
    }
  });
};
var _convertHourToNumber = (string) => {
  if (string.startsWith("0"))
    return Number(string.slice(1));
  return Number(string);
};

// node_modules/tw-elements/dist/src/js/forms/timepicker/index.js
var NAME18 = "timepicker";
var ATTR_NAME = `data-te-${NAME18}`;
var SELECTOR_ATTR_TIMEPICKER_INIT = `[${ATTR_NAME}-init]`;
var SELECTOR_DATA_TE_TOGGLE = "[data-te-toggle]";
var DATA_KEY17 = `te.${NAME18}`;
var EVENT_KEY14 = `.${DATA_KEY17}`;
var DATA_API_KEY10 = ".data-api";
var EVENT_CLICK_DATA_API9 = `click${EVENT_KEY14}${DATA_API_KEY10}`;
var EVENT_KEYDOWN_DATA_API2 = `keydown${EVENT_KEY14}${DATA_API_KEY10}`;
var EVENT_MOUSEDOWN_DATA_API = `mousedown${EVENT_KEY14}${DATA_API_KEY10}`;
var EVENT_MOUSEUP_DATA_API = `mouseup${EVENT_KEY14}${DATA_API_KEY10}`;
var EVENT_MOUSEMOVE_DATA_API = `mousemove${EVENT_KEY14}${DATA_API_KEY10}`;
var EVENT_MOUSELEAVE_DATA_API = `mouseleave${EVENT_KEY14}${DATA_API_KEY10}`;
var EVENT_MOUSEOVER_DATA_API = `mouseover${EVENT_KEY14}${DATA_API_KEY10}`;
var EVENT_TOUCHMOVE_DATA_API = `touchmove${EVENT_KEY14}${DATA_API_KEY10}`;
var EVENT_TOUCHEND_DATA_API = `touchend${EVENT_KEY14}${DATA_API_KEY10}`;
var EVENT_TOUCHSTART_DATA_API = `touchstart${EVENT_KEY14}${DATA_API_KEY10}`;
var SELECTOR_ATTR_TIMEPICKER_AM = `[${ATTR_NAME}-am]`;
var SELECTOR_ATTR_TIMEPICKER_PM = `[${ATTR_NAME}-pm]`;
var SELECTOR_ATTR_TIMEPICKER_FORMAT24 = `[${ATTR_NAME}-format24]`;
var SELECTOR_ATTR_TIMEPICKER_CURRENT = `[${ATTR_NAME}-current]`;
var SELECTOR_ATTR_TIMEPICKER_HOUR_MODE = `[${ATTR_NAME}-hour-mode]`;
var SELECTOR_ATTR_TIMEPICKER_TOGGLE_BUTTON = `[${ATTR_NAME}-toggle-button]`;
var ATTR_TIMEPICKER_BUTTON_CANCEL = `${ATTR_NAME}-cancel`;
var ATTR_TIMEPICKER_BUTTON_CLEAR = `${ATTR_NAME}-clear`;
var ATTR_TIMEPICKER_BUTTON_SUBMIT = `${ATTR_NAME}-submit`;
var ATTR_TIMEPICKER_ICON = `${ATTR_NAME}-icon`;
var ATTR_TIMEPICKER_ICON_UP = `${ATTR_NAME}-icon-up`;
var ATTR_TIMEPICKER_ICON_DOWN = `${ATTR_NAME}-icon-down`;
var ATTR_TIMEPICKER_ICON_INLINE_HOUR = `${ATTR_NAME}-icon-inline-hour`;
var ATTR_TIMEPICKER_ICON_INLINE_MINUTE = `${ATTR_NAME}-icon-inline-minute`;
var ATTR_TIMEPICKER_ICONS_HOUR_INLINE = `${ATTR_NAME}-inline-hour-icons`;
var ATTR_TIMEPICKER_CURRENT_INLINE = `${ATTR_NAME}-current-inline`;
var ATTR_READONLY = "readonly";
var ATTR_TIMEPICKER_INVALID_FEEDBACK = `${ATTR_NAME}-invalid-feedback`;
var ATTR_TIMEPICKER_IS_INVALID = `${ATTR_NAME}-is-invalid`;
var ATTR_TIMEPICKER_DISABLED2 = `${ATTR_NAME}-disabled`;
var ATTR_TIMEPICKER_ACTIVE2 = `${ATTR_NAME}-active`;
var ATTR_TIMEPICKER_INPUT = `${ATTR_NAME}-input`;
var ATTR_TIMEPICKER_CLOCK = `${ATTR_NAME}-clock`;
var ATTR_TIMEPICKER_CLOCK_INNER = `${ATTR_NAME}-clock-inner`;
var ATTR_TIMEPICKER_WRAPPER = `${ATTR_NAME}-wrapper`;
var ATTR_TIMEPICKER_CLOCK_WRAPPER = `${ATTR_NAME}-clock-wrapper`;
var ATTR_TIMEPICKER_HOUR = `${ATTR_NAME}-hour`;
var ATTR_TIMEPICKER_MINUTE = `${ATTR_NAME}-minute`;
var ATTR_TIMEPICKER_TIPS_ELEMENT = `${ATTR_NAME}-tips-element`;
var ATTR_TIMEPICKER_TIPS_HOURS = `${ATTR_NAME}-tips-hours`;
var ATTR_TIMEPICKER_TIPS_MINUTES = `${ATTR_NAME}-tips-minutes`;
var ATTR_TIMEPICKER_INNER_HOURS = `${ATTR_NAME}-tips-inner`;
var ATTR_TIMEPICKER_TIPS_INNER_ELEMENT = `${ATTR_NAME}-tips-inner-element`;
var ATTR_TIMEPICKER_MIDDLE_DOT = `${ATTR_NAME}-middle-dot`;
var ATTR_TIMEPICKER_HAND_POINTER = `${ATTR_NAME}-hand-pointer`;
var ATTR_TIMEPICKER_CIRCLE = `${ATTR_NAME}-circle`;
var ATTR_TIMEPICKER_MODAL = `${ATTR_NAME}-modal`;
var defaultIcon = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 hover:text-[#3b71ca] focus:text-[#3b71ca] dark:hover:text-[#3b71ca] dark:focus:text-[#3b71ca]">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>`;
var Default16 = {
  appendValidationInfo: true,
  bodyID: "",
  cancelLabel: "Cancel",
  clearLabel: "Clear",
  closeModalOnBackdropClick: true,
  closeModalOnMinutesClick: false,
  container: "body",
  defaultTime: "",
  disabled: false,
  disablePast: false,
  disableFuture: false,
  enableValidation: true,
  focusInputAfterApprove: false,
  footerID: "",
  format12: true,
  format24: false,
  headID: "",
  increment: false,
  inline: false,
  invalidLabel: "Invalid Time Format",
  maxTime: "",
  minTime: "",
  modalID: "",
  okLabel: "Ok",
  overflowHidden: true,
  pickerID: "",
  readOnly: false,
  showClearBtn: true,
  switchHoursToMinutesOnClick: true,
  iconSVG: defaultIcon,
  withIcon: true,
  pmLabel: "PM",
  amLabel: "AM",
  animations: true
};
var DefaultType16 = {
  appendValidationInfo: "boolean",
  bodyID: "string",
  cancelLabel: "string",
  clearLabel: "string",
  closeModalOnBackdropClick: "boolean",
  closeModalOnMinutesClick: "boolean",
  container: "string",
  disabled: "boolean",
  disablePast: "boolean",
  disableFuture: "boolean",
  enableValidation: "boolean",
  footerID: "string",
  format12: "boolean",
  format24: "boolean",
  headID: "string",
  increment: "boolean",
  inline: "boolean",
  invalidLabel: "string",
  modalID: "string",
  okLabel: "string",
  overflowHidden: "boolean",
  pickerID: "string",
  readOnly: "boolean",
  showClearBtn: "boolean",
  switchHoursToMinutesOnClick: "boolean",
  defaultTime: "(string|date|number)",
  iconSVG: "string",
  withIcon: "boolean",
  pmLabel: "string",
  amLabel: "string",
  animations: "boolean"
};
var DefaultClasses11 = {
  tips: "absolute rounded-[100%] w-[32px] h-[32px] text-center cursor-pointer text-[1.1rem] rounded-[100%] bg-transparent flex justify-center items-center font-light focus:outline-none selection:bg-transparent",
  tipsActive: "text-white bg-[#3b71ca] font-normal",
  tipsDisabled: "text-[#b3afaf] pointer-events-none bg-transparent",
  transform: "transition-[transform,height] ease-in-out duration-[400ms]",
  modal: "z-[1065]",
  clockAnimation: "animate-[show-up-clock_350ms_linear]",
  opacity: "!opacity-100",
  timepickerWrapper: "touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col fixed",
  timepickerContainer: "flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)] min-[320px]:max-[825px]:landscape:rounded-lg",
  timepickerElements: "flex flex-col min-w-[310px] min-h-[325px] bg-white rounded-t-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape:min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around",
  timepickerHead: "bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg pr-[24px] pl-[50px] py-[10px] min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center",
  timepickerHeadContent: "min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly",
  timepickerCurrentWrapper: "[direction:ltr] rtl:[direction:rtl]",
  timepickerCurrentButtonWrapper: "relative h-full",
  timepickerCurrentButton: "text-[3.75rem] font-light leading-[1.2] tracking-[-0.00833em] text-white opacity-[.54] border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none ",
  timepickerDot: "font-light leading-[1.2] tracking-[-0.00833em] text-[3.75rem] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal",
  timepickerModeWrapper: "flex flex-col justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row",
  timepickerModeAm: "p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none",
  timepickerModePm: "p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none",
  timepickerClockWrapper: "min-w-[310px] max-w-[325px] min-h-[305px] overflow-x-hidden h-full flex justify-center flex-col items-center dark:bg-zinc-500",
  timepickerClock: "relative rounded-[100%] w-[260px] h-[260px] cursor-default my-0 mx-auto bg-[#00000012] dark:bg-zinc-600/50",
  timepickerMiddleDot: "top-1/2 left-1/2 w-[6px] h-[6px] -translate-y-1/2 -translate-x-1/2 rounded-[50%] bg-[#3b71ca] absolute",
  timepickerHandPointer: "bg-[#3b71ca] bottom-1/2 h-2/5 left-[calc(50%-1px)] rtl:!left-auto origin-[center_bottom_0] rtl:!origin-[50%_50%_0] w-[2px] absolute",
  timepickerPointerCircle: "-top-[21px] -left-[15px] w-[4px] border-[14px] border-solid border-[#3b71ca] h-[4px] box-content rounded-[100%] absolute",
  timepickerClockInner: "absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2 w-[160px] h-[160px] rounded-[100%]",
  timepickerFooterWrapper: "rounded-b-lg flex justify-between items-center w-full h-[56px] px-[12px] bg-white dark:bg-zinc-500",
  timepickerFooter: "w-full flex justify-between",
  timepickerFooterButton: "text-[0.8rem] min-w-[64px] box-border font-medium leading-[40px] rounded-[10px] tracking-[0.1rem] uppercase text-[#3b71ca] dark:text-white border-none bg-transparent transition-[background-color,box-shadow,border] duration-[250ms] ease-[cubic-bezier(0.4,0,0.2,1)] delay-[0ms] outline-none py-0 px-[10px] h-[40px] mb-[10px] hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none",
  timepickerInlineWrapper: "touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col rounded-lg",
  timepickerInlineContainer: "flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)]",
  timepickerInlineElements: "flex flex-col min-h-[auto] min-w-[310px] bg-white rounded-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:rounded-bl-lg min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape::min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around",
  timepickerInlineHead: "bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center p-0 rounded-b-lg",
  timepickerInlineHeadContent: "min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly items-center",
  timepickerInlineHourWrapper: "relative h-full !opacity-100",
  timepickerCurrentMinuteWrapper: "relative h-full",
  timepickerInlineIconUp: "absolute fill-white -top-[35px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center",
  timepickerInlineIconSvg: "h-4 w-4",
  timepickerInlineCurrentButton: "font-light leading-[1.2] tracking-[-0.00833em] text-white border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal !opacity-100 cursor-pointer focus:bg-[#00000026] hover:outline-none focus:outline-none text-[2.5rem] hover:bg-[unset]",
  timepickerInlineIconDown: "absolute fill-white -bottom-[47px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center",
  timepickerInlineDot: "font-light leading-[1.2] tracking-[-0.00833em] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal text-[2.5rem]",
  timepickerInlineModeWrapper: "flex justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row",
  timepickerInlineModeAm: "hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer mr-2 ml-6",
  timepickerInlineModePm: "hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer",
  timepickerInlineSubmitButton: "hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none text-[0.8rem] box-border font-medium leading-[40px] tracking-[.1rem] uppercase border-none bg-transparent [transition:background-color_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,box-shadow_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,border_250ms_cubic-bezier(0.4,0,0.2,1)_0ms] outline-none rounded-[100%] h-[48px] min-w-[48px] inline-block ml-[30px] text-white py-1 px-2 mb-0",
  timepickerToggleButton: "h-4 w-4 ml-auto absolute outline-none border-none bg-transparent right-2.5 top-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)] cursor-pointer hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200"
};
var DefaultClassesType11 = {
  tips: "string",
  tipsActive: "string",
  tipsDisabled: "string",
  transform: "string",
  modal: "string",
  clockAnimation: "string",
  opacity: "string",
  timepickerWrapper: "string",
  timepickerContainer: "string",
  timepickerElements: "string",
  timepickerHead: "string",
  timepickerHeadContent: "string",
  timepickerCurrentWrapper: "string",
  timepickerCurrentButtonWrapper: "string",
  timepickerCurrentButton: "string",
  timepickerDot: "string",
  timepickerModeWrapper: "string",
  timepickerModeAm: "string",
  timepickerModePm: "string",
  timepickerClockWrapper: "string",
  timepickerClock: "string",
  timepickerMiddleDot: "string",
  timepickerHandPointer: "string",
  timepickerPointerCircle: "string",
  timepickerClockInner: "string",
  timepickerFooterWrapper: "string",
  timepickerFooterButton: "string",
  timepickerInlineWrapper: "string",
  timepickerInlineContainer: "string",
  timepickerInlineElements: "string",
  timepickerInlineHead: "string",
  timepickerInlineHeadContent: "string",
  timepickerInlineHourWrapper: "string",
  timepickerCurrentMinuteWrapper: "string",
  timepickerInlineIconUp: "string",
  timepickerInlineIconSvg: "string",
  timepickerInlineCurrentButton: "string",
  timepickerInlineIconDown: "string",
  timepickerInlineDot: "string",
  timepickerInlineModeWrapper: "string",
  timepickerInlineModeAm: "string",
  timepickerInlineModePm: "string",
  timepickerInlineSubmitButton: "string",
  timepickerToggleButton: "string"
};
var Timepicker = class {
  constructor(element2, options = {}, classes) {
    __publicField(this, "_toggleAmPm", (enabled) => {
      if (enabled === "PM") {
        this._isPmEnabled = true;
        this._isAmEnabled = false;
      } else if (enabled === "AM") {
        this._isPmEnabled = false;
        this._isAmEnabled = true;
      }
    });
    __publicField(this, "_toggleBackgroundColorCircle", (classes) => {
      const tips = this._modal.querySelector(`${classes}[${ATTR_TIMEPICKER_ACTIVE2}]`) !== null;
      if (tips) {
        manipulator_default.addStyle(this._circle, {
          backgroundColor: "#1976d2"
        });
        return;
      }
      manipulator_default.addStyle(this._circle, {
        backgroundColor: "transparent"
      });
    });
    __publicField(this, "_toggleClassActive", (array2, { textContent }, tips) => {
      const findInArray = [...array2].find(
        (e) => Number(e) === Number(textContent)
      );
      return tips.forEach((e) => {
        if (e.hasAttribute(ATTR_TIMEPICKER_DISABLED2))
          return;
        if (e.textContent === findInArray) {
          manipulator_default.addClass(e, this._classes.tipsActive);
          e.setAttribute(ATTR_TIMEPICKER_ACTIVE2, "");
          return;
        }
        manipulator_default.removeClass(e, this._classes.tipsActive);
        e.removeAttribute(ATTR_TIMEPICKER_ACTIVE2);
      });
    });
    __publicField(this, "_makeMinutesDegrees", (degrees, minute) => {
      const { increment } = this._options;
      if (degrees < 0) {
        minute = Math.round(360 + degrees / 6) % 60;
        degrees = 360 + Math.round(degrees / 6) * 6;
      } else {
        minute = Math.round(degrees / 6) % 60;
        degrees = Math.round(degrees / 6) * 6;
      }
      if (increment) {
        degrees = Math.round(degrees / 30) * 30;
        minute = Math.round(degrees / 6) * 6 / 6;
        if (minute === 60) {
          minute = "00";
        }
      }
      if (degrees >= 360) {
        degrees = 0;
      }
      return {
        degrees,
        minute,
        addDegrees: increment ? 30 : 6
      };
    });
    __publicField(this, "_makeHourDegrees", (target, degrees, hour) => {
      if (!target) {
        return;
      }
      if (this._hasTargetInnerClass(target)) {
        if (degrees < 0) {
          hour = Math.round(360 + degrees / 30) % 24;
          degrees = 360 + degrees;
        } else {
          hour = Math.round(degrees / 30) + 12;
          if (hour === 12) {
            hour = "00";
          }
        }
      } else if (degrees < 0) {
        hour = Math.round(360 + degrees / 30) % 12;
        degrees = 360 + degrees;
      } else {
        hour = Math.round(degrees / 30) % 12;
        if (hour === 0 || hour > 12) {
          hour = 12;
        }
      }
      if (degrees >= 360) {
        degrees = 0;
      }
      return {
        degrees,
        hour,
        addDegrees: 30
      };
    });
    __publicField(this, "_makeInnerHoursDegrees", (degrees, hour) => {
      if (degrees < 0) {
        hour = Math.round(360 + degrees / 30) % 24;
        degrees = 360 + degrees;
      } else {
        hour = Math.round(degrees / 30) + 12;
        if (hour === 12) {
          hour = "00";
        }
      }
      return {
        degrees,
        hour,
        addDegrees: 30
      };
    });
    __publicField(this, "_getAppendClock", (array2 = [], clockClass = `[${ATTR_TIMEPICKER_CLOCK}]`, tipsClass) => {
      let { minTime, maxTime } = this._options;
      const { inline, format12, disablePast, disableFuture } = this._options;
      minTime = setMinTime(minTime, disablePast, format12);
      maxTime = setMaxTime(maxTime, disableFuture, format12);
      const [maxTimeHour, maxTimeMinutes, maxTimeFormat] = takeValue(
        maxTime,
        false
      );
      const [minTimeHour, minTimeMinutes, minTimeFormat] = takeValue(
        minTime,
        false
      );
      if (!inline && format12 && this._isInvalidTimeFormat && !this._AM.hasAttribute(ATTR_TIMEPICKER_ACTIVE2)) {
        manipulator_default.addClass(this._PM, this._classes.opacity);
        this._PM.setAttribute(ATTR_TIMEPICKER_ACTIVE2, "");
      }
      const clock = selector_engine_default.findOne(clockClass);
      const elements = 360 / array2.length;
      function rad(el) {
        return el * (Math.PI / 180);
      }
      if (clock === null)
        return;
      const clockWidth = (clock.offsetWidth - 32) / 2;
      const clockHeight = (clock.offsetHeight - 32) / 2;
      const radius = clockWidth - 4;
      setTimeout(() => {
        let currentFormat;
        if (format12) {
          currentFormat = selector_engine_default.findOne(
            `${SELECTOR_ATTR_TIMEPICKER_HOUR_MODE}[${ATTR_TIMEPICKER_ACTIVE2}]`
          ).textContent;
        }
        this._handleDisablingTipsMinTime(
          currentFormat,
          minTimeFormat,
          minTimeMinutes,
          minTimeHour
        );
        this._handleDisablingTipsMaxTime(
          currentFormat,
          maxTimeFormat,
          maxTimeMinutes,
          maxTimeHour
        );
      }, 0);
      [...array2].forEach((e, i) => {
        const angle = rad(i * elements);
        const span = element("span");
        const spanToTips = element("span");
        spanToTips.innerHTML = e;
        manipulator_default.addClass(span, this._classes.tips);
        span.setAttribute(tipsClass, "");
        const itemWidth = span.offsetWidth;
        const itemHeight = span.offsetHeight;
        manipulator_default.addStyle(span, {
          left: `${clockWidth + Math.sin(angle) * radius - itemWidth}px`,
          bottom: `${clockHeight + Math.cos(angle) * radius - itemHeight}px`
        });
        if (array2.includes("05")) {
          span.setAttribute(ATTR_TIMEPICKER_TIPS_MINUTES, "");
        }
        if (array2.includes("13")) {
          spanToTips.setAttribute(ATTR_TIMEPICKER_TIPS_INNER_ELEMENT, "");
        } else {
          spanToTips.setAttribute(ATTR_TIMEPICKER_TIPS_ELEMENT, "");
        }
        span.appendChild(spanToTips);
        return clock.appendChild(span);
      });
    });
    this._element = element2;
    if (this._element) {
      data_default.setData(element2, DATA_KEY17, this);
    }
    this._document = document;
    this._options = this._getConfig(options);
    this._classes = this._getClasses(classes);
    this._currentTime = null;
    this._toggleButtonId = getUID("timepicker-toggle-");
    this.hoursArray = [
      "12",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "10",
      "11"
    ];
    this.innerHours = [
      "00",
      "13",
      "14",
      "15",
      "16",
      "17",
      "18",
      "19",
      "20",
      "21",
      "22",
      "23"
    ];
    this.minutesArray = [
      "00",
      "05",
      "10",
      "15",
      "20",
      "25",
      "30",
      "35",
      "40",
      "45",
      "50",
      "55"
    ];
    this.input = selector_engine_default.findOne("input", this._element);
    this.dataWithIcon = element2.dataset.withIcon;
    this.dataToggle = element2.dataset.toggle;
    this.customIcon = selector_engine_default.findOne(
      SELECTOR_ATTR_TIMEPICKER_TOGGLE_BUTTON,
      this._element
    );
    this._checkToggleButton();
    this.inputFormatShow = selector_engine_default.findOne(
      SELECTOR_ATTR_TIMEPICKER_FORMAT24,
      this._element
    );
    this.inputFormat = this.inputFormatShow === null ? "" : Object.values(this.inputFormatShow.dataset)[0];
    this.elementToggle = selector_engine_default.findOne(
      SELECTOR_DATA_TE_TOGGLE,
      this._element
    );
    this.toggleElement = Object.values(
      element2.querySelector(SELECTOR_DATA_TE_TOGGLE).dataset
    )[0];
    this._hour = null;
    this._minutes = null;
    this._AM = null;
    this._PM = null;
    this._wrapper = null;
    this._modal = null;
    this._hand = null;
    this._circle = null;
    this._focusTrap = null;
    this._popper = null;
    this._interval = null;
    this._inputValue = this._options.defaultTime !== "" ? this._options.defaultTime : this.input.value;
    if (this._options.format24) {
      this._options.format12 = false;
      this._currentTime = formatNormalHours(this._inputValue);
    }
    if (this._options.format12) {
      this._options.format24 = false;
      this._currentTime = formatToAmPm(this._inputValue);
    }
    if (this._options.readOnly) {
      this.input.setAttribute(ATTR_READONLY, true);
    }
    if (this.inputFormat === "true" && this.inputFormat !== "") {
      this._options.format12 = false;
      this._options.format24 = true;
      this._currentTime = formatNormalHours(this._inputValue);
    }
    this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations;
    this.init();
    this._isHours = true;
    this._isMinutes = false;
    this._isInvalidTimeFormat = false;
    this._isMouseMove = false;
    this._isInner = false;
    this._isAmEnabled = false;
    this._isPmEnabled = false;
    if (this._options.format12 && !this._options.defaultTime) {
      this._isPmEnabled = true;
    }
    this._objWithDataOnChange = { degrees: null };
    this._scrollBar = new scrollbar_default();
  }
  // Getters
  static get NAME() {
    return NAME18;
  }
  // Public
  init() {
    const { format12, format24, enableValidation } = this._options;
    let zero;
    let hoursFormat;
    let _amOrPm;
    this.input.setAttribute(ATTR_TIMEPICKER_INPUT, "");
    if (this._currentTime !== void 0) {
      const { hours, minutes, amOrPm } = this._currentTime;
      zero = Number(hours) < 10 ? 0 : "";
      hoursFormat = `${zero}${Number(hours)}:${minutes}`;
      _amOrPm = amOrPm;
      if (format12) {
        this.input.value = `${hoursFormat} ${_amOrPm}`;
      } else if (format24) {
        this.input.value = `${hoursFormat}`;
      }
    } else {
      zero = "";
      hoursFormat = "";
      _amOrPm = "";
      this.input.value = "";
    }
    if (this.input.value.length > 0 && this.input.value !== "") {
      this.input.setAttribute(ATTR_TIMEPICKER_ACTIVE2, "");
    }
    if (this._options === null && this._element === null)
      return;
    if (enableValidation) {
      this._getValidate("keydown change blur focus");
    }
    this._handleOpen();
    this._listenToToggleKeydown();
  }
  dispose() {
    this._removeModal();
    if (this._element !== null) {
      data_default.removeData(this._element, DATA_KEY17);
    }
    setTimeout(() => {
      this._element = null;
      this._options = null;
      this.input = null;
      this._focusTrap = null;
    }, 350);
    event_handler_default.off(
      this._document,
      "click",
      `[data-te-toggle='${this.toggleElement}']`
    );
    event_handler_default.off(
      this._element,
      "keydown",
      `[data-te-toggle='${this.toggleElement}']`
    );
  }
  update(options = {}) {
    this._options = this._getConfig({ ...this._options, ...options });
  }
  // private
  _checkToggleButton() {
    if (this.customIcon !== null)
      return;
    if (this.dataWithIcon !== void 0) {
      this._options.withIcon = null;
      if (this.dataWithIcon === "true") {
        this._appendToggleButton(this._options);
      }
    }
    if (this._options.withIcon) {
      this._appendToggleButton(this._options);
    }
  }
  _appendToggleButton() {
    const toggleButton = getToggleButtonTemplate2(
      this._options,
      this._toggleButtonId,
      this._classes
    );
    this.input.insertAdjacentHTML("afterend", toggleButton);
  }
  _getDomElements() {
    this._hour = selector_engine_default.findOne(`[${ATTR_TIMEPICKER_HOUR}]`);
    this._minutes = selector_engine_default.findOne(`[${ATTR_TIMEPICKER_MINUTE}]`);
    this._AM = selector_engine_default.findOne(SELECTOR_ATTR_TIMEPICKER_AM);
    this._PM = selector_engine_default.findOne(SELECTOR_ATTR_TIMEPICKER_PM);
    this._wrapper = selector_engine_default.findOne(`[${ATTR_TIMEPICKER_WRAPPER}]`);
    this._modal = selector_engine_default.findOne(`[${ATTR_TIMEPICKER_MODAL}]`);
    this._hand = selector_engine_default.findOne(`[${ATTR_TIMEPICKER_HAND_POINTER}]`);
    this._circle = selector_engine_default.findOne(`[${ATTR_TIMEPICKER_CIRCLE}]`);
    this._clock = selector_engine_default.findOne(`[${ATTR_TIMEPICKER_CLOCK}]`);
    this._clockInner = selector_engine_default.findOne(
      `[${ATTR_TIMEPICKER_CLOCK_INNER}]`
    );
  }
  _handlerMaxMinHoursOptions(degrees, maxHour, minHour, maxFormat, minFormat, e) {
    if (!maxHour && !minHour)
      return true;
    const { format24, format12, disablePast, disableFuture } = this._options;
    const { _isAmEnabled, _isPmEnabled } = this;
    const key = e.keyCode;
    const _isMouseOnInnerClock = e.target.hasAttribute(ATTR_TIMEPICKER_CLOCK_INNER) || e.target.hasAttribute(ATTR_TIMEPICKER_INNER_HOURS) || e.target.hasAttribute(ATTR_TIMEPICKER_TIPS_INNER_ELEMENT);
    minHour = setMinTime(minHour, disablePast, format12);
    maxHour = setMaxTime(maxHour, disableFuture, format12);
    const maxHourDegrees = maxHour !== "" ? maxHour * 30 : "";
    const minHourDegrees = minHour !== "" ? minHour * 30 : "";
    if (degrees <= 0) {
      degrees = 360 + degrees;
    }
    const _handleKeyboardEvents = () => {
      const tips = document.querySelectorAll(
        `[${ATTR_TIMEPICKER_TIPS_ELEMENT}]`
      );
      const innerTips = document.querySelectorAll(
        `[${ATTR_TIMEPICKER_TIPS_INNER_ELEMENT}]`
      );
      const currentHour = _convertHourToNumber(this._hour.innerText);
      let nextHourTip;
      let numberToAdd;
      let nextHour;
      if (key === UP_ARROW) {
        numberToAdd = 1;
      } else if (key === DOWN_ARROW) {
        numberToAdd = -1;
      }
      if (currentHour === 12 && key === UP_ARROW) {
        nextHour = 1;
      } else if (currentHour === 0 && key === UP_ARROW) {
        nextHour = 13;
      } else if (currentHour === 0 && key === DOWN_ARROW) {
        nextHour = 23;
      } else if (currentHour === 13 && key === DOWN_ARROW) {
        nextHour = 0;
      } else if (currentHour === 1 && key === DOWN_ARROW) {
        nextHour = 12;
      } else {
        nextHour = currentHour + numberToAdd;
      }
      tips.forEach((tip) => {
        if (Number(tip.textContent) === nextHour) {
          nextHourTip = tip;
        }
      });
      innerTips.forEach((innerTip) => {
        if (Number(innerTip.textContent) === nextHour) {
          nextHourTip = innerTip;
        }
      });
      return !nextHourTip.parentElement.hasAttribute(ATTR_TIMEPICKER_DISABLED2);
    };
    const _handle24FormatMouseEvents = () => {
      const minInnerHourDegrees = minHour !== "" && minHour > 12 ? (minHour - 12) * 30 : "";
      const maxInnerHourDegrees = maxHour !== "" && maxHour > 12 ? (maxHour - 12) * 30 : "";
      if (minInnerHourDegrees && degrees < minInnerHourDegrees || maxInnerHourDegrees && degrees > maxInnerHourDegrees || maxHour && maxHour < 12) {
        return;
      }
      return true;
    };
    if (format24 && e.type !== "keydown" && _isMouseOnInnerClock) {
      return _handle24FormatMouseEvents();
    }
    if (e.type === "keydown") {
      return _handleKeyboardEvents(e);
    }
    const minFormatAndCurrentFormatEqual = !minFormat || minFormat === "PM" && _isPmEnabled || minHour !== "" && minFormat === "AM" && _isAmEnabled;
    const maxFormatAndCurrentFormatEqual = !maxFormat || maxFormat === "PM" && _isPmEnabled || maxHour !== "" && maxFormat === "AM" && _isAmEnabled;
    const isMinHourValid = () => {
      if (!minHour) {
        return true;
      } else if (minFormat === "PM" && _isAmEnabled || minFormatAndCurrentFormatEqual && degrees < minHourDegrees) {
        return;
      }
      return true;
    };
    const isMaxHourValid = () => {
      if (!maxHour) {
        return true;
      } else if (maxFormat === "AM" && _isPmEnabled || maxFormatAndCurrentFormatEqual && degrees > maxHourDegrees) {
        return;
      }
      return true;
    };
    return isMinHourValid() && isMaxHourValid();
  }
  _handleKeyboard() {
    event_handler_default.on(this._document, EVENT_KEYDOWN_DATA_API2, "", (e) => {
      let hour;
      let minute;
      let innerHour;
      const {
        increment,
        maxTime,
        minTime,
        format12,
        disablePast,
        disableFuture
      } = this._options;
      let minHour = takeValue(minTime, false)[0];
      let maxHour = takeValue(maxTime, false)[0];
      const minFormat = takeValue(minTime, false)[2];
      const maxFormat = takeValue(maxTime, false)[2];
      minHour = setMinTime(minHour, disablePast, format12);
      maxHour = setMaxTime(maxHour, disableFuture, format12);
      const hoursView = selector_engine_default.findOne(`[${ATTR_TIMEPICKER_TIPS_MINUTES}]`) === null;
      const innerHoursExist = selector_engine_default.findOne(`[${ATTR_TIMEPICKER_INNER_HOURS}]`) !== null;
      const degrees = Number(this._hand.style.transform.replace(/[^\d-]/g, ""));
      const allTipsMinutes = selector_engine_default.find(
        `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`,
        this._modal
      );
      const allTipsHours = selector_engine_default.find(
        `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,
        this._modal
      );
      const allInnerTips = selector_engine_default.find(
        `[${ATTR_TIMEPICKER_INNER_HOURS}]`,
        this._modal
      );
      let hourTime = this._makeHourDegrees(e.target, degrees, hour).hour;
      const { degrees: hourObjDegrees, addDegrees } = this._makeHourDegrees(
        e.target,
        degrees,
        hour
      );
      let { minute: minHourMinutes, degrees: minObjDegrees } = this._makeMinutesDegrees(degrees, minute);
      const addMinDegrees = this._makeMinutesDegrees(
        degrees,
        minute
      ).addDegrees;
      let { hour: innerHourDegrees } = this._makeInnerHoursDegrees(
        degrees,
        innerHour
      );
      if (e.keyCode === ESCAPE) {
        const cancelBtn = selector_engine_default.findOne(
          `[${ATTR_TIMEPICKER_BUTTON_CANCEL}]`,
          this._modal
        );
        event_handler_default.trigger(cancelBtn, "click");
      } else if (hoursView) {
        if (innerHoursExist) {
          if (e.keyCode === RIGHT_ARROW) {
            this._isInner = false;
            manipulator_default.addStyle(this._hand, {
              height: "calc(40% + 1px)"
            });
            this._hour.textContent = this._setHourOrMinute(
              hourTime > 12 ? 1 : hourTime
            );
            this._toggleClassActive(this.hoursArray, this._hour, allTipsHours);
            this._toggleClassActive(this.innerHours, this._hour, allInnerTips);
          }
          if (e.keyCode === LEFT_ARROW) {
            this._isInner = true;
            manipulator_default.addStyle(this._hand, {
              height: "21.5%"
            });
            this._hour.textContent = this._setHourOrMinute(
              innerHourDegrees >= 24 || innerHourDegrees === "00" ? 0 : innerHourDegrees
            );
            this._toggleClassActive(this.innerHours, this._hour, allInnerTips);
            this._toggleClassActive(
              this.hoursArray,
              this._hour - 1,
              allTipsHours
            );
          }
        }
        if (e.keyCode === UP_ARROW) {
          const isNextHourValid = this._handlerMaxMinHoursOptions(
            hourObjDegrees + 30,
            maxHour,
            minHour,
            maxFormat,
            minFormat,
            e
          );
          if (!isNextHourValid)
            return;
          manipulator_default.addStyle(this._hand, {
            transform: `rotateZ(${hourObjDegrees + addDegrees}deg)`
          });
          if (this._isInner) {
            innerHourDegrees += 1;
            if (innerHourDegrees === 24) {
              innerHourDegrees = 0;
            } else if (innerHourDegrees === 25 || innerHourDegrees === "001") {
              innerHourDegrees = 13;
            }
            this._hour.textContent = this._setHourOrMinute(innerHourDegrees);
            this._toggleClassActive(this.innerHours, this._hour, allInnerTips);
          } else {
            hourTime += 1;
            this._hour.textContent = this._setHourOrMinute(
              hourTime > 12 ? 1 : hourTime
            );
            this._toggleClassActive(this.hoursArray, this._hour, allTipsHours);
          }
        }
        if (e.keyCode === DOWN_ARROW) {
          const isNextHourValid = this._handlerMaxMinHoursOptions(
            hourObjDegrees - 30,
            maxHour,
            minHour,
            maxFormat,
            minFormat,
            e
          );
          if (!isNextHourValid)
            return;
          manipulator_default.addStyle(this._hand, {
            transform: `rotateZ(${hourObjDegrees - addDegrees}deg)`
          });
          if (this._isInner) {
            innerHourDegrees -= 1;
            if (innerHourDegrees === 12) {
              innerHourDegrees = 0;
            } else if (innerHourDegrees === -1) {
              innerHourDegrees = 23;
            }
            this._hour.textContent = this._setHourOrMinute(innerHourDegrees);
            this._toggleClassActive(this.innerHours, this._hour, allInnerTips);
          } else {
            hourTime -= 1;
            this._hour.textContent = this._setHourOrMinute(
              hourTime === 0 ? 12 : hourTime
            );
            this._toggleClassActive(this.hoursArray, this._hour, allTipsHours);
          }
        }
      } else {
        if (e.keyCode === UP_ARROW) {
          minObjDegrees += addMinDegrees;
          manipulator_default.addStyle(this._hand, {
            transform: `rotateZ(${minObjDegrees}deg)`
          });
          minHourMinutes += 1;
          if (increment) {
            minHourMinutes += 4;
            if (minHourMinutes === "0014") {
              minHourMinutes = 5;
            }
          }
          this._minutes.textContent = this._setHourOrMinute(
            minHourMinutes > 59 ? 0 : minHourMinutes
          );
          this._toggleClassActive(
            this.minutesArray,
            this._minutes,
            allTipsMinutes
          );
          this._toggleBackgroundColorCircle(
            `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`
          );
        }
        if (e.keyCode === DOWN_ARROW) {
          minObjDegrees -= addMinDegrees;
          manipulator_default.addStyle(this._hand, {
            transform: `rotateZ(${minObjDegrees}deg)`
          });
          if (increment) {
            minHourMinutes -= 5;
          } else {
            minHourMinutes -= 1;
          }
          if (minHourMinutes === -1) {
            minHourMinutes = 59;
          } else if (minHourMinutes === -5) {
            minHourMinutes = 55;
          }
          this._minutes.textContent = this._setHourOrMinute(minHourMinutes);
          this._toggleClassActive(
            this.minutesArray,
            this._minutes,
            allTipsMinutes
          );
          this._toggleBackgroundColorCircle(
            `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`
          );
        }
      }
    });
  }
  _setActiveClassToTipsOnOpen(hour, ...rest) {
    if (this._isInvalidTimeFormat)
      return;
    if (!this._options.format24) {
      [...rest].filter((e) => {
        if (e === "PM") {
          manipulator_default.addClass(this._PM, this._classes.opacity);
          this._PM.setAttribute(ATTR_TIMEPICKER_ACTIVE2, "");
        } else if (e === "AM") {
          manipulator_default.addClass(this._AM, this._classes.opacity);
          this._AM.setAttribute(ATTR_TIMEPICKER_ACTIVE2, "");
        } else {
          manipulator_default.removeClass(this._AM, this._classes.opacity);
          manipulator_default.removeClass(this._PM, this._classes.opacity);
          this._AM.removeAttribute(ATTR_TIMEPICKER_ACTIVE2);
          this._PM.removeAttribute(ATTR_TIMEPICKER_ACTIVE2);
        }
        return e;
      });
      const allTipsHours = selector_engine_default.find(
        `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,
        this._modal
      );
      this._addActiveClassToTip(allTipsHours, hour);
    } else {
      const allTipsHours = selector_engine_default.find(
        `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,
        this._modal
      );
      const allInnerTips = selector_engine_default.find(
        `[${ATTR_TIMEPICKER_INNER_HOURS}]`,
        this._modal
      );
      this._addActiveClassToTip(allTipsHours, hour);
      this._addActiveClassToTip(allInnerTips, hour);
    }
  }
  _setTipsAndTimesDependOnInputValue(hour, minute) {
    const { inline, format12 } = this._options;
    if (!this._isInvalidTimeFormat) {
      const rotateDegrees = hour > 12 ? hour * 30 - 360 : hour * 30;
      this._hour.textContent = hour;
      this._minutes.textContent = minute;
      if (!inline) {
        manipulator_default.addStyle(this._hand, {
          transform: `rotateZ(${rotateDegrees}deg)`
        });
        manipulator_default.addStyle(this._circle, {
          backgroundColor: "#1976d2"
        });
        if (Number(hour) > 12 || hour === "00") {
          manipulator_default.addStyle(this._hand, {
            height: "21.5%"
          });
        }
      }
    } else {
      this._hour.textContent = "12";
      this._minutes.textContent = "00";
      if (!inline) {
        manipulator_default.addStyle(this._hand, {
          transform: "rotateZ(0deg)"
        });
      }
      if (format12) {
        manipulator_default.addClass(this._PM, this._classes.opacity);
        this._PM.setAttribute(ATTR_TIMEPICKER_ACTIVE2, "");
      }
    }
  }
  _listenToToggleKeydown() {
    event_handler_default.on(
      this._element,
      "keydown",
      `[data-te-toggle='${this.toggleElement}']`,
      (e) => {
        if (e.keyCode === ENTER) {
          e.preventDefault();
          event_handler_default.trigger(this.elementToggle, "click");
        }
      }
    );
  }
  _handleOpen() {
    const container = this._getContainer();
    EventHandlerMulti.on(
      this._element,
      "click",
      `[data-te-toggle='${this.toggleElement}']`,
      (e) => {
        if (this._options === null)
          return;
        const fixForInput = manipulator_default.getDataAttribute(this.input, "toggle") !== null ? 200 : 0;
        setTimeout(() => {
          manipulator_default.addStyle(this.elementToggle, {
            pointerEvents: "none"
          });
          this.elementToggle.blur();
          let checkInputValue;
          if (takeValue(this.input)[0] === "") {
            checkInputValue = ["12", "00", "PM"];
          } else {
            checkInputValue = takeValue(this.input);
          }
          const { modalID, inline, format12 } = this._options;
          const [hour, minute, format2] = checkInputValue;
          const div2 = element("div");
          if (Number(hour) > 12 || hour === "00") {
            this._isInner = true;
          }
          this.input.blur();
          e.target.blur();
          div2.innerHTML = getTimepickerTemplate(this._options, this._classes);
          manipulator_default.addClass(div2, this._classes.modal);
          div2.setAttribute(ATTR_TIMEPICKER_MODAL, "");
          div2.setAttribute("role", "dialog");
          div2.setAttribute("tabIndex", "-1");
          div2.setAttribute("id", modalID);
          if (!inline) {
            container.appendChild(div2);
            this._scrollBar.hide();
          } else {
            this._popper = createPopper3(this.input, div2, {
              placement: "bottom-start"
            });
            container.appendChild(div2);
          }
          this._getDomElements();
          if (this._animations) {
            this._toggleBackdropAnimation();
          } else {
            manipulator_default.addClass(this._wrapper, this._classes.opacity);
          }
          this._setActiveClassToTipsOnOpen(hour, minute, format2);
          this._appendTimes();
          this._setActiveClassToTipsOnOpen(hour, minute, format2);
          this._setTipsAndTimesDependOnInputValue(hour, minute);
          if (this.input.value === "") {
            const allTipsHours = selector_engine_default.find(
              `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,
              this._modal
            );
            if (format12) {
              manipulator_default.addClass(this._PM, this._classes.opacity);
              this._PM.setAttribute(ATTR_TIMEPICKER_ACTIVE2, "");
            }
            this._hour.textContent = "12";
            this._minutes.textContent = "00";
            this._addActiveClassToTip(
              allTipsHours,
              Number(this._hour.textContent)
            );
          }
          this._handleSwitchTimeMode();
          this._handleOkButton();
          this._handleClose();
          if (inline) {
            this._handleHoverInlineBtn();
            this._handleDocumentClickInline();
            this._handleInlineClicks();
          } else {
            this._handleSwitchHourMinute();
            this._handleClockClick();
            this._handleKeyboard();
            const initActive = document.querySelector(
              `${SELECTOR_ATTR_TIMEPICKER_CURRENT}[${ATTR_TIMEPICKER_ACTIVE2}]`
            );
            manipulator_default.addClass(initActive, this._classes.opacity);
            manipulator_default.addStyle(this._hour, {
              pointerEvents: "none"
            });
            manipulator_default.addStyle(this._minutes, {
              pointerEvents: ""
            });
          }
          this._focusTrap = new focusTrap_default(this._wrapper, {
            event: "keydown",
            condition: ({ key }) => key === "Tab"
          });
          this._focusTrap.trap();
        }, fixForInput);
      }
    );
  }
  _handleInlineClicks() {
    let selectedHour;
    let minuteNumber;
    const countMinutes = (count) => {
      let minutes = count;
      if (minutes > 59) {
        minutes = 0;
      } else if (minutes < 0) {
        minutes = 59;
      }
      return minutes;
    };
    const countHours = (count) => {
      let hour = count;
      if (this._options.format24) {
        if (hour > 24) {
          hour = 1;
        } else if (hour < 0) {
          hour = 23;
        }
        if (hour > 23) {
          hour = 0;
        }
      } else {
        if (hour > 12) {
          hour = 1;
        } else if (hour < 1) {
          hour = 12;
        }
        if (hour > 12) {
          hour = 1;
        }
      }
      return hour;
    };
    const incrementHours = (hour) => {
      const counteredNumber = countHours(hour);
      this._hour.textContent = this._setHourOrMinute(counteredNumber);
    };
    const incrementMinutes = (minutes) => {
      const counteredNumber = countMinutes(minutes);
      this._minutes.textContent = this._setHourOrMinute(counteredNumber);
    };
    const addHours = () => {
      selectedHour += 1;
      incrementHours(selectedHour);
    };
    const addMinutes = () => {
      minuteNumber += 1;
      incrementMinutes(minuteNumber);
    };
    const subHours = () => {
      selectedHour -= 1;
      incrementHours(selectedHour);
    };
    const subMinutes = () => {
      minuteNumber -= 1;
      incrementMinutes(minuteNumber);
    };
    const _clearAndSetThisInterval = (addHoursOrAddMinutes) => {
      clearInterval(this._interval);
      this._interval = setInterval(addHoursOrAddMinutes, 100);
    };
    EventHandlerMulti.on(
      this._modal,
      "click mousedown mouseup touchstart touchend contextmenu",
      `[${ATTR_TIMEPICKER_ICON_UP}], [${ATTR_TIMEPICKER_ICON_DOWN}]`,
      (e) => {
        selectedHour = Number(this._hour.textContent);
        minuteNumber = Number(this._minutes.textContent);
        const { target, type } = e;
        const isEventTypeMousedownOrTouchstart = type === "mousedown" || type === "touchstart";
        if (target.closest(`[${ATTR_TIMEPICKER_ICON_UP}]`)) {
          if (target.closest(`[${ATTR_TIMEPICKER_ICON_UP}]`).parentNode.hasAttribute(ATTR_TIMEPICKER_ICONS_HOUR_INLINE)) {
            if (isEventTypeMousedownOrTouchstart) {
              _clearAndSetThisInterval(addHours);
            } else if (type === "mouseup" || type === "touchend" || type === "contextmenu") {
              clearInterval(this._interval);
            } else {
              addHours();
            }
          } else {
            if (isEventTypeMousedownOrTouchstart) {
              _clearAndSetThisInterval(addMinutes);
            } else if (type === "mouseup" || type === "touchend" || type === "contextmenu") {
              clearInterval(this._interval);
            } else {
              addMinutes();
            }
          }
        } else if (target.closest(`[${ATTR_TIMEPICKER_ICON_DOWN}]`)) {
          if (target.closest(`[${ATTR_TIMEPICKER_ICON_DOWN}]`).parentNode.hasAttribute(ATTR_TIMEPICKER_ICONS_HOUR_INLINE)) {
            if (isEventTypeMousedownOrTouchstart) {
              _clearAndSetThisInterval(subHours);
            } else if (type === "mouseup" || type === "touchend") {
              clearInterval(this._interval);
            } else {
              subHours();
            }
          } else {
            if (isEventTypeMousedownOrTouchstart) {
              _clearAndSetThisInterval(subMinutes);
            } else if (type === "mouseup" || type === "touchend") {
              clearInterval(this._interval);
            } else {
              subMinutes();
            }
          }
        }
      }
    );
    event_handler_default.on(window, EVENT_KEYDOWN_DATA_API2, (e) => {
      const key = e.code;
      const isHourBtnFocused = document.activeElement.hasAttribute(ATTR_TIMEPICKER_HOUR);
      const isMinuteBtnFocused = document.activeElement.hasAttribute(
        ATTR_TIMEPICKER_MINUTE
      );
      const isBodyFocused = document.activeElement === document.body;
      selectedHour = Number(this._hour.textContent);
      minuteNumber = Number(this._minutes.textContent);
      switch (key) {
        case "ArrowUp":
          e.preventDefault();
          if (isBodyFocused || isHourBtnFocused) {
            this._hour.focus();
            addHours();
          } else if (isMinuteBtnFocused) {
            addMinutes();
          }
          break;
        case "ArrowDown":
          e.preventDefault();
          if (isBodyFocused || isHourBtnFocused) {
            this._hour.focus();
            subHours();
          } else if (isMinuteBtnFocused) {
            subMinutes();
          }
          break;
        default:
          break;
      }
    });
  }
  _handleClose() {
    event_handler_default.on(
      this._modal,
      "click",
      `[${ATTR_TIMEPICKER_WRAPPER}], [${ATTR_TIMEPICKER_BUTTON_CANCEL}], [${ATTR_TIMEPICKER_BUTTON_CLEAR}]`,
      ({ target }) => {
        const { closeModalOnBackdropClick } = this._options;
        const runRemoveFunction = () => {
          manipulator_default.addStyle(this.elementToggle, {
            pointerEvents: "auto"
          });
          if (this._animations) {
            this._toggleBackdropAnimation(true);
          }
          this._removeModal();
          this._focusTrap.disable();
          this._focusTrap = null;
          if (this.elementToggle) {
            this.elementToggle.focus();
          } else if (this.input) {
            this.input.focus();
          }
        };
        if (target.hasAttribute(ATTR_TIMEPICKER_BUTTON_CLEAR)) {
          this._toggleAmPm("PM");
          this.input.value = "";
          this.input.removeAttribute(ATTR_TIMEPICKER_ACTIVE2);
          let checkInputValue;
          if (takeValue(this.input)[0] === "") {
            checkInputValue = ["12", "00", "PM"];
          } else {
            checkInputValue = takeValue(this.input);
          }
          const [hour, minute, format2] = checkInputValue;
          this._setTipsAndTimesDependOnInputValue("12", "00");
          this._setActiveClassToTipsOnOpen(hour, minute, format2);
          this._hour.click();
        } else if (target.hasAttribute(ATTR_TIMEPICKER_BUTTON_CANCEL) || target.hasAttribute(ATTR_TIMEPICKER_BUTTON_SUBMIT)) {
          runRemoveFunction();
        } else if (target.hasAttribute(ATTR_TIMEPICKER_WRAPPER) && closeModalOnBackdropClick) {
          runRemoveFunction();
        }
      }
    );
  }
  showValueInput() {
    return this.input.value;
  }
  _handleOkButton() {
    EventHandlerMulti.on(
      this._modal,
      "click",
      `[${ATTR_TIMEPICKER_BUTTON_SUBMIT}]`,
      () => {
        let { maxTime, minTime } = this._options;
        const {
          format12,
          format24,
          readOnly,
          focusInputAfterApprove,
          disablePast,
          disableFuture
        } = this._options;
        const hourModeActive = this._document.querySelector(
          `${SELECTOR_ATTR_TIMEPICKER_HOUR_MODE}[${ATTR_TIMEPICKER_ACTIVE2}]`
        );
        const currentValue = `${this._hour.textContent}:${this._minutes.textContent}`;
        const selectedHour = Number(this._hour.textContent);
        const selectedMinutes = Number(this._minutes.textContent);
        minTime = setMinTime(minTime, disablePast, format12);
        maxTime = setMaxTime(maxTime, disableFuture, format12);
        const [maxTimeHour, maxTimeMinutes, maxTimeFormat] = takeValue(
          maxTime,
          false
        );
        const [minTimeHour, minTimeMinutes, minTimeFormat] = takeValue(
          minTime,
          false
        );
        const isHourLessThanMinHour = selectedHour < Number(minTimeHour);
        const isHourGreaterThanMaxHour = selectedHour > Number(maxTimeHour);
        let maxFormatAndCurrentFormatEqual = true;
        if (hourModeActive) {
          maxFormatAndCurrentFormatEqual = maxTimeFormat === hourModeActive.textContent;
        }
        let minFormatAndCurrentFormatEqual = true;
        if (hourModeActive) {
          minFormatAndCurrentFormatEqual = minTimeFormat === hourModeActive.textContent;
        }
        const hourEqualToMaxAndMinutesGreaterThanMax = selectedMinutes > maxTimeMinutes && selectedHour === Number(maxTimeHour);
        const hourEqualToMinAndMinutesLessThanMin = selectedMinutes < minTimeMinutes && selectedHour === Number(minTimeHour);
        this.input.setAttribute(ATTR_TIMEPICKER_ACTIVE2, "");
        manipulator_default.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        });
        if (maxTime !== "") {
          if (maxFormatAndCurrentFormatEqual && (isHourGreaterThanMaxHour || hourEqualToMaxAndMinutesGreaterThanMax)) {
            return;
          } else if (maxTimeFormat === "AM" && hourModeActive.textContent === "PM") {
            return;
          }
        }
        if (minTime !== "") {
          if (minFormatAndCurrentFormatEqual && (isHourLessThanMinHour || hourEqualToMinAndMinutesLessThanMin)) {
            return;
          }
          if (minTimeFormat === "PM" && hourModeActive.textContent === "AM") {
            return;
          }
        }
        if (checkValueBeforeAccept(
          this._options,
          this.input,
          this._hour.textContent
        ) === void 0) {
          return;
        }
        if (this._isInvalidTimeFormat) {
          this.input.removeAttribute(ATTR_TIMEPICKER_IS_INVALID);
        }
        if (!readOnly && focusInputAfterApprove) {
          this.input.focus();
        }
        manipulator_default.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        });
        if (format24) {
          this.input.value = currentValue;
        } else if (hourModeActive === null) {
          this.input.value = `${currentValue} PM`;
        } else {
          this.input.value = `${currentValue} ${hourModeActive.textContent}`;
        }
        if (this._animations) {
          this._toggleBackdropAnimation(true);
        }
        this._removeModal();
        event_handler_default.trigger(this.input, "input.te.timepicker");
        event_handler_default.trigger(this.input, "input");
      }
    );
  }
  _handleHoverInlineBtn() {
    EventHandlerMulti.on(
      this._modal,
      "mouseover mouseleave",
      `[${ATTR_TIMEPICKER_CURRENT_INLINE}]`,
      ({ type, target }) => {
        const allIconsInlineHour = selector_engine_default.find(
          `[${ATTR_TIMEPICKER_ICON_INLINE_HOUR}]`,
          this._modal
        );
        const allIconsInlineMinute = selector_engine_default.find(
          `[${ATTR_TIMEPICKER_ICON_INLINE_MINUTE}]`,
          this._modal
        );
        const modifyIcons = (elements, shouldAdd) => {
          return elements.forEach((icon) => {
            if (shouldAdd) {
              manipulator_default.addClass(icon, this._classes.opacity);
              icon.setAttribute(ATTR_TIMEPICKER_ACTIVE2, "");
              return;
            }
            manipulator_default.removeClass(icon, this._classes.opacity);
            icon.removeAttribute(ATTR_TIMEPICKER_ACTIVE2);
          });
        };
        const pickerHasHourAttr = target.hasAttribute(ATTR_TIMEPICKER_HOUR);
        const iconElements = pickerHasHourAttr ? allIconsInlineHour : allIconsInlineMinute;
        modifyIcons(iconElements, type === "mouseover");
      }
    );
  }
  _handleDocumentClickInline() {
    event_handler_default.on(document, EVENT_CLICK_DATA_API9, ({ target }) => {
      if (this._modal && !this._modal.contains(target) && !target.hasAttribute(ATTR_TIMEPICKER_ICON)) {
        clearInterval(this._interval);
        manipulator_default.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        });
        this._removeModal();
        if (!this._animations)
          return;
        this._toggleBackdropAnimation(true);
      }
    });
  }
  _handleSwitchHourMinute() {
    toggleClassHandler(
      "click",
      SELECTOR_ATTR_TIMEPICKER_CURRENT,
      this._classes
    );
    event_handler_default.on(
      this._modal,
      "click",
      SELECTOR_ATTR_TIMEPICKER_CURRENT,
      () => {
        const { format24 } = this._options;
        const current = selector_engine_default.find(
          SELECTOR_ATTR_TIMEPICKER_CURRENT,
          this._modal
        );
        const allTipsMinutes = selector_engine_default.find(
          `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`,
          this._modal
        );
        const allTipsHours = selector_engine_default.find(
          `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,
          this._modal
        );
        const allInnerTips = selector_engine_default.find(
          `[${ATTR_TIMEPICKER_INNER_HOURS}]`,
          this._modal
        );
        const hourValue = Number(this._hour.textContent);
        const minuteValue = Number(this._minutes.textContent);
        const switchTips = (array2, classes) => {
          allTipsHours.forEach((tip) => tip.remove());
          allTipsMinutes.forEach((tip) => tip.remove());
          manipulator_default.addClass(this._hand, this._classes.transform);
          setTimeout(() => {
            manipulator_default.removeClass(this._hand, this._classes.transform);
          }, 401);
          this._getAppendClock(array2, `[${ATTR_TIMEPICKER_CLOCK}]`, classes);
          const toggleActiveClass = () => {
            const allTipsHours2 = selector_engine_default.find(
              `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,
              this._modal
            );
            const allTipsMinutes2 = selector_engine_default.find(
              `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`,
              this._modal
            );
            this._addActiveClassToTip(allTipsHours2, hourValue);
            this._addActiveClassToTip(allTipsMinutes2, minuteValue);
          };
          if (!format24) {
            setTimeout(() => {
              toggleActiveClass();
            }, 401);
          } else {
            const allTipsInnerHours = selector_engine_default.find(
              `[${ATTR_TIMEPICKER_INNER_HOURS}]`,
              this._modal
            );
            setTimeout(() => {
              this._addActiveClassToTip(allTipsInnerHours, hourValue);
              toggleActiveClass();
            }, 401);
          }
        };
        current.forEach((e) => {
          if (e.hasAttribute(ATTR_TIMEPICKER_ACTIVE2)) {
            if (e.hasAttribute(ATTR_TIMEPICKER_MINUTE)) {
              manipulator_default.addClass(this._hand, this._classes.transform);
              manipulator_default.addStyle(this._hand, {
                transform: `rotateZ(${this._minutes.textContent * 6}deg)`,
                height: "calc(40% + 1px)"
              });
              if (format24 && allInnerTips.length > 0) {
                allInnerTips.forEach((innerTip) => innerTip.remove());
              }
              switchTips(
                this.minutesArray,
                ATTR_TIMEPICKER_TIPS_MINUTES,
                allTipsMinutes
              );
              this._hour.style.pointerEvents = "";
              this._minutes.style.pointerEvents = "none";
            } else if (e.hasAttribute(ATTR_TIMEPICKER_HOUR)) {
              manipulator_default.addStyle(this._hand, {
                transform: `rotateZ(${this._hour.textContent * 30}deg)`
              });
              if (Number(this._hour.textContent) > 12) {
                manipulator_default.addStyle(this._hand, {
                  transform: `rotateZ(${this._hour.textContent * 30 - 360}deg)`,
                  height: "21.5%"
                });
                if (Number(this._hour.textContent) > 12) {
                  manipulator_default.addStyle(this._hand, {
                    height: "21.5%"
                  });
                }
              } else {
                manipulator_default.addStyle(this._hand, {
                  height: "calc(40% + 1px)"
                });
              }
              if (format24) {
                this._getAppendClock(
                  this.innerHours,
                  `[${ATTR_TIMEPICKER_CLOCK_INNER}]`,
                  ATTR_TIMEPICKER_INNER_HOURS
                );
              }
              if (allInnerTips.length > 0) {
                allInnerTips.forEach((innerTip) => innerTip.remove());
              }
              switchTips(
                this.hoursArray,
                ATTR_TIMEPICKER_TIPS_HOURS,
                allTipsHours
              );
              manipulator_default.addStyle(this._hour, {
                pointerEvents: "none"
              });
              manipulator_default.addStyle(this._minutes, {
                pointerEvents: ""
              });
            }
          }
        });
      }
    );
  }
  _handleDisablingTipsMaxTime(selectedFormat, maxTimeFormat, maxTimeMinutes, maxTimeHour) {
    if (!this._options.maxTime && !this._options.disableFuture) {
      return;
    }
    const outerHoursTips = selector_engine_default.find(
      `[${ATTR_TIMEPICKER_TIPS_HOURS}]`
    );
    const innerHoursTips = selector_engine_default.find(
      `[${ATTR_TIMEPICKER_INNER_HOURS}]`
    );
    const allTipsMinutes = selector_engine_default.find(
      `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`
    );
    if (!maxTimeFormat || maxTimeFormat === selectedFormat) {
      _verifyMaxTimeHourAndAddDisabledClass(
        innerHoursTips,
        maxTimeHour,
        this._classes
      );
      _verifyMaxTimeHourAndAddDisabledClass(
        outerHoursTips,
        maxTimeHour,
        this._classes
      );
      _verifyMaxTimeMinutesTipsAndAddDisabledClass(
        allTipsMinutes,
        maxTimeMinutes,
        maxTimeHour,
        this._hour.textContent,
        this._classes
      );
      return;
    }
    if (maxTimeFormat === "AM" && selectedFormat === "PM") {
      outerHoursTips.forEach((tip) => {
        manipulator_default.addClass(tip, this._classes.tipsDisabled);
        tip.setAttribute(ATTR_TIMEPICKER_DISABLED2, "");
      });
      allTipsMinutes.forEach((tip) => {
        manipulator_default.addClass(tip, this._classes.tipsDisabled);
        tip.setAttribute(ATTR_TIMEPICKER_DISABLED2, "");
      });
    }
  }
  _handleDisablingTipsMinTime(selectedFormat, minTimeFormat, minTimeMinutes, minTimeHour) {
    if (!this._options.minTime && !this._options.disablePast) {
      return;
    }
    const outerHoursTips = selector_engine_default.find(
      `[${ATTR_TIMEPICKER_TIPS_HOURS}]`
    );
    const innerHoursTips = selector_engine_default.find(
      `[${ATTR_TIMEPICKER_INNER_HOURS}]`
    );
    const allTipsMinutes = selector_engine_default.find(
      `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`
    );
    if (!minTimeFormat || minTimeFormat === selectedFormat) {
      _verifyMinTimeHourAndAddDisabledClass(
        outerHoursTips,
        minTimeHour,
        this._classes
      );
      _verifyMinTimeHourAndAddDisabledClass(
        innerHoursTips,
        minTimeHour,
        this._classes
      );
      _verifyMinTimeMinutesTipsAndAddDisabledClass(
        allTipsMinutes,
        minTimeMinutes,
        minTimeHour,
        this._hour.textContent,
        this._classes
      );
    } else if (minTimeFormat === "PM" && selectedFormat === "AM") {
      outerHoursTips.forEach((tip) => {
        manipulator_default.addClass(tip, this._classes.tipsDisabled);
        tip.setAttribute(ATTR_TIMEPICKER_DISABLED2, "");
      });
      allTipsMinutes.forEach((tip) => {
        manipulator_default.addClass(tip, this._classes.tipsDisabled);
        tip.setAttribute(ATTR_TIMEPICKER_DISABLED2, "");
      });
    }
  }
  _handleSwitchTimeMode() {
    event_handler_default.on(
      document,
      "click",
      SELECTOR_ATTR_TIMEPICKER_HOUR_MODE,
      ({ target }) => {
        let { maxTime, minTime } = this._options;
        const { disablePast, disableFuture, format12 } = this._options;
        minTime = setMinTime(minTime, disablePast, format12);
        maxTime = setMaxTime(maxTime, disableFuture, format12);
        const [maxTimeHour, maxTimeMinutes, maxTimeFormat] = takeValue(
          maxTime,
          false
        );
        const [minTimeHour, minTimeMinutes, minTimeFormat] = takeValue(
          minTime,
          false
        );
        const allTipsHour = selector_engine_default.find(
          `[${ATTR_TIMEPICKER_TIPS_HOURS}]`
        );
        const allTipsMinutes = selector_engine_default.find(
          `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`
        );
        const clearDisabledClassForAllTips = () => {
          allTipsHour.forEach((tip) => {
            manipulator_default.removeClass(tip, this._classes.tipsDisabled);
            tip.removeAttribute(ATTR_TIMEPICKER_DISABLED2);
          });
          allTipsMinutes.forEach((tip) => {
            manipulator_default.removeClass(tip, this._classes.tipsDisabled);
            tip.removeAttribute(ATTR_TIMEPICKER_DISABLED2);
          });
        };
        clearDisabledClassForAllTips();
        this._handleDisablingTipsMinTime(
          target.textContent,
          minTimeFormat,
          minTimeMinutes,
          minTimeHour
        );
        this._handleDisablingTipsMaxTime(
          target.textContent,
          maxTimeFormat,
          maxTimeMinutes,
          maxTimeHour
        );
        this._toggleAmPm(target.textContent);
        if (!target.hasAttribute(ATTR_TIMEPICKER_ACTIVE2)) {
          const allHoursMode = selector_engine_default.find(
            SELECTOR_ATTR_TIMEPICKER_HOUR_MODE
          );
          allHoursMode.forEach((element2) => {
            if (element2.hasAttribute(ATTR_TIMEPICKER_ACTIVE2)) {
              manipulator_default.removeClass(element2, this._classes.opacity);
              element2.removeAttribute(ATTR_TIMEPICKER_ACTIVE2);
            }
          });
          manipulator_default.addClass(target, this._classes.opacity);
          target.setAttribute(ATTR_TIMEPICKER_ACTIVE2, "");
        }
      }
    );
  }
  _handleClockClick() {
    let { maxTime, minTime } = this._options;
    const { disablePast, disableFuture, format12 } = this._options;
    minTime = setMinTime(minTime, disablePast, format12);
    maxTime = setMaxTime(maxTime, disableFuture, format12);
    const maxTimeFormat = takeValue(maxTime, false)[2];
    const minTimeFormat = takeValue(minTime, false)[2];
    const maxTimeHour = takeValue(maxTime, false)[0];
    const minTimeHour = takeValue(minTime, false)[0];
    const clockWrapper = selector_engine_default.findOne(
      `[${ATTR_TIMEPICKER_CLOCK_WRAPPER}]`
    );
    EventHandlerMulti.on(
      document,
      `${EVENT_MOUSEDOWN_DATA_API} ${EVENT_MOUSEUP_DATA_API} ${EVENT_MOUSEMOVE_DATA_API} ${EVENT_MOUSELEAVE_DATA_API} ${EVENT_MOUSEOVER_DATA_API} ${EVENT_TOUCHSTART_DATA_API} ${EVENT_TOUCHMOVE_DATA_API} ${EVENT_TOUCHEND_DATA_API}`,
      "",
      (e) => {
        if (!checkBrowser()) {
          e.preventDefault();
        }
        const { type, target } = e;
        const { closeModalOnMinutesClick, switchHoursToMinutesOnClick } = this._options;
        const minutes = selector_engine_default.findOne(
          `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`,
          this._modal
        ) !== null;
        const hours = selector_engine_default.findOne(
          `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,
          this._modal
        ) !== null;
        const innerHours = selector_engine_default.findOne(
          `[${ATTR_TIMEPICKER_INNER_HOURS}]`,
          this._modal
        ) !== null;
        const allTipsMinutes = selector_engine_default.find(
          `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`,
          this._modal
        );
        const mouseClick = findMousePosition(e, clockWrapper);
        const radius = clockWrapper.offsetWidth / 2;
        let rds = Math.atan2(mouseClick.y - radius, mouseClick.x - radius);
        if (checkBrowser()) {
          const touchClick = findMousePosition(e, clockWrapper, true);
          rds = Math.atan2(touchClick.y - radius, touchClick.x - radius);
        }
        let xPos = null;
        let yPos = null;
        let elFromPoint = null;
        if (type === "mousedown" || type === "mousemove" || type === "touchmove" || type === "touchstart") {
          if (type === "mousedown" || type === "touchstart" || type === "touchmove") {
            if (this._hasTargetInnerClass(target) || target.hasAttribute(ATTR_TIMEPICKER_CLOCK_WRAPPER) || target.hasAttribute(ATTR_TIMEPICKER_CLOCK) || target.hasAttribute(ATTR_TIMEPICKER_TIPS_MINUTES) || target.hasAttribute(ATTR_TIMEPICKER_TIPS_HOURS) || target.hasAttribute(ATTR_TIMEPICKER_CIRCLE) || target.hasAttribute(ATTR_TIMEPICKER_HAND_POINTER) || target.hasAttribute(ATTR_TIMEPICKER_MIDDLE_DOT) || target.hasAttribute(ATTR_TIMEPICKER_TIPS_ELEMENT)) {
              this._isMouseMove = true;
              if (checkBrowser() && e.touches) {
                xPos = e.touches[0].clientX;
                yPos = e.touches[0].clientY;
                elFromPoint = document.elementFromPoint(xPos, yPos);
              }
            }
          }
        } else if (type === "mouseup" || type === "touchend") {
          this._isMouseMove = false;
          if (this._hasTargetInnerClass(target) || target.hasAttribute(ATTR_TIMEPICKER_CLOCK) || target.hasAttribute(ATTR_TIMEPICKER_TIPS_HOURS) || target.hasAttribute(ATTR_TIMEPICKER_CIRCLE) || target.hasAttribute(ATTR_TIMEPICKER_HAND_POINTER) || target.hasAttribute(ATTR_TIMEPICKER_MIDDLE_DOT) || target.hasAttribute(ATTR_TIMEPICKER_TIPS_ELEMENT)) {
            if ((hours || innerHours) && switchHoursToMinutesOnClick) {
              const isHourlessThanMinOrGreaterThanMax = Number(this._hour.textContent) > maxTimeHour || Number(this._hour.textContent) < minTimeHour;
              if (this._options.format24 && maxTimeHour !== "" && minTimeHour !== "" && isHourlessThanMinOrGreaterThanMax) {
                return;
              } else if (this._options.format24 && minTimeHour !== "" && this._hour.textContent < minTimeHour) {
                return;
              }
            }
            event_handler_default.trigger(this._minutes, "click");
          }
          if (minutes && closeModalOnMinutesClick) {
            const submitBtn = selector_engine_default.findOne(
              `[${ATTR_TIMEPICKER_BUTTON_SUBMIT}]`,
              this._modal
            );
            event_handler_default.trigger(submitBtn, "click");
          }
        }
        if (minutes) {
          let minute;
          const degrees = Math.trunc(rds * 180 / Math.PI) + 90;
          const { degrees: minDegrees, minute: minTimeObj } = this._makeMinutesDegrees(degrees, minute);
          if (this._handlerMaxMinMinutesOptions(minDegrees, minTimeObj) === void 0) {
            return;
          }
          const { degrees: _degrees, minute: minuteTimes } = this._handlerMaxMinMinutesOptions(minDegrees, minTimeObj);
          if (this._isMouseMove) {
            manipulator_default.addStyle(this._hand, {
              transform: `rotateZ(${_degrees}deg)`
            });
            if (minuteTimes === void 0) {
              return;
            }
            const changeMinutes = () => {
              return minuteTimes >= 10 || minuteTimes === "00" ? minuteTimes : `0${minuteTimes}`;
            };
            this._minutes.textContent = changeMinutes();
            this._toggleClassActive(
              this.minutesArray,
              this._minutes,
              allTipsMinutes
            );
            this._toggleBackgroundColorCircle(
              `[${ATTR_TIMEPICKER_TIPS_MINUTES}]`
            );
            this._objWithDataOnChange.degreesMinutes = _degrees;
            this._objWithDataOnChange.minutes = minuteTimes;
          }
        }
        if (hours || innerHours) {
          let hour;
          let degrees = Math.trunc(rds * 180 / Math.PI) + 90;
          degrees = Math.round(degrees / 30) * 30;
          manipulator_default.addStyle(this._circle, {
            backgroundColor: "#1976d2"
          });
          if (this._makeHourDegrees(target, degrees, hour) === void 0) {
            return;
          }
          const makeDegrees = () => {
            if (checkBrowser() && degrees && elFromPoint) {
              const { degrees: touchDegrees, hour: touchHours } = this._makeHourDegrees(elFromPoint, degrees, hour);
              return this._handleMoveHand(
                elFromPoint,
                touchHours,
                touchDegrees
              );
            } else {
              const { degrees: movedDegrees, hour: movedHours } = this._makeHourDegrees(target, degrees, hour);
              return this._handleMoveHand(target, movedHours, movedDegrees);
            }
          };
          this._objWithDataOnChange.degreesHours = degrees;
          if (this._handlerMaxMinHoursOptions(
            degrees,
            maxTimeHour,
            minTimeHour,
            maxTimeFormat,
            minTimeFormat,
            e
          )) {
            makeDegrees();
          }
        }
        e.stopPropagation();
      }
    );
  }
  _hasTargetInnerClass(target) {
    return target.hasAttribute(ATTR_TIMEPICKER_CLOCK_INNER) || target.hasAttribute(ATTR_TIMEPICKER_INNER_HOURS) || target.hasAttribute(ATTR_TIMEPICKER_TIPS_INNER_ELEMENT);
  }
  _handleMoveHand(target, hour, degrees) {
    const allTipsHours = selector_engine_default.find(
      `[${ATTR_TIMEPICKER_TIPS_HOURS}]`,
      this._modal
    );
    const allTipsInner = selector_engine_default.find(
      `[${ATTR_TIMEPICKER_INNER_HOURS}]`,
      this._modal
    );
    if (!this._isMouseMove)
      return;
    if (this._hasTargetInnerClass(target)) {
      manipulator_default.addStyle(this._hand, {
        height: "21.5%"
      });
    } else {
      manipulator_default.addStyle(this._hand, {
        height: "calc(40% + 1px)"
      });
    }
    manipulator_default.addStyle(this._hand, {
      transform: `rotateZ(${degrees}deg)`
    });
    this._hour.textContent = hour >= 10 || hour === "00" ? hour : `0${hour}`;
    this._toggleClassActive(this.hoursArray, this._hour, allTipsHours);
    this._toggleClassActive(this.innerHours, this._hour, allTipsInner);
    this._objWithDataOnChange.hour = hour >= 10 || hour === "00" ? hour : `0${hour}`;
  }
  _handlerMaxMinMinutesOptions(degrees, minute) {
    let { maxTime, minTime } = this._options;
    const { format12, increment, disablePast, disableFuture } = this._options;
    minTime = setMinTime(minTime, disablePast, format12);
    maxTime = setMaxTime(maxTime, disableFuture, format12);
    const maxMin = takeValue(maxTime, false)[1];
    const minMin = takeValue(minTime, false)[1];
    const maxHourTime = takeValue(maxTime, false)[0];
    const minHourTime = takeValue(minTime, false)[0];
    const maxTimeFormat = takeValue(maxTime, false)[2];
    const minTimeFormat = takeValue(minTime, false)[2];
    const maxMinDegrees = maxMin !== "" ? maxMin * 6 : "";
    const minMinDegrees = minMin !== "" ? minMin * 6 : "";
    const selectedHour = Number(this._hour.textContent);
    if (!maxTimeFormat && !minTimeFormat) {
      if (maxTime !== "" && minTime !== "") {
        if (maxHourTime === selectedHour && degrees > maxMinDegrees || minHourTime === selectedHour && degrees < minMinDegrees) {
          return degrees;
        }
      } else if (minTime !== "" && selectedHour <= Number(minHourTime)) {
        if (degrees <= minMinDegrees - 6) {
          return degrees;
        }
      } else if (maxTime !== "" && selectedHour >= Number(maxHourTime)) {
        if (degrees >= maxMinDegrees + 6) {
          return degrees;
        }
      }
    } else {
      if (minTime !== "") {
        if (minTimeFormat === "PM" && this._isAmEnabled) {
          return;
        }
        if (minTimeFormat === "PM" && this._isPmEnabled) {
          if (selectedHour < Number(minHourTime)) {
            return;
          }
          if (selectedHour <= Number(minHourTime)) {
            if (degrees <= minMinDegrees - 6) {
              return degrees;
            }
          }
        } else if (minTimeFormat === "AM" && this._isAmEnabled) {
          if (selectedHour < Number(minHourTime)) {
            return;
          }
          if (selectedHour <= Number(minHourTime)) {
            if (degrees <= minMinDegrees - 6) {
              return degrees;
            }
          }
        }
      }
      if (maxTime !== "") {
        if (maxTimeFormat === "AM" && this._isPmEnabled) {
          return;
        }
        if (maxTimeFormat === "PM" && this._isPmEnabled) {
          if (selectedHour >= Number(maxHourTime)) {
            if (degrees >= maxMinDegrees + 6) {
              return degrees;
            }
          }
        } else if (maxTimeFormat === "AM" && this._isAmEnabled) {
          if (selectedHour >= Number(maxHourTime)) {
            if (degrees >= maxMinDegrees + 6) {
              return degrees;
            }
          }
        }
      }
    }
    if (increment) {
      degrees = Math.round(degrees / 30) * 30;
    }
    if (degrees <= 0) {
      degrees = 360 + degrees;
    } else if (degrees >= 360) {
      degrees = 0;
    }
    return {
      degrees,
      minute
    };
  }
  _removeModal() {
    if (this._animations) {
      setTimeout(() => {
        this._removeModalElements();
        this._scrollBar.reset();
      }, 300);
    } else {
      this._removeModalElements();
      this._scrollBar.reset();
    }
    EventHandlerMulti.off(
      this._document,
      `${EVENT_CLICK_DATA_API9} ${EVENT_KEYDOWN_DATA_API2} ${EVENT_MOUSEDOWN_DATA_API} ${EVENT_MOUSEUP_DATA_API} ${EVENT_MOUSEMOVE_DATA_API} ${EVENT_MOUSELEAVE_DATA_API} ${EVENT_MOUSEOVER_DATA_API} ${EVENT_TOUCHSTART_DATA_API} ${EVENT_TOUCHMOVE_DATA_API} ${EVENT_TOUCHEND_DATA_API}`
    );
    event_handler_default.off(window, EVENT_KEYDOWN_DATA_API2);
  }
  _removeModalElements() {
    if (this._modal)
      this._modal.remove();
  }
  _toggleBackdropAnimation(isToRemove = false) {
    if (isToRemove) {
      this._wrapper.classList.add("animate-[fade-out_350ms_ease-in-out]");
    } else {
      this._wrapper.classList.add("animate-[fade-in_350ms_ease-in-out]");
      if (!this._options.inline)
        manipulator_default.addClass(this._clock, this._classes.clockAnimation);
    }
    setTimeout(() => {
      this._wrapper.classList.remove(
        "animate-[fade-out_350ms_ease-in-out]",
        "animate-[fade-in_350ms_ease-in-out]"
      );
    }, 351);
  }
  _addActiveClassToTip(tips, value) {
    tips.forEach((tip) => {
      if (Number(tip.textContent) === Number(value)) {
        manipulator_default.addClass(tip, this._classes.tipsActive);
        tip.setAttribute(ATTR_TIMEPICKER_ACTIVE2, "");
      }
    });
  }
  _setHourOrMinute(number) {
    return number < 10 ? `0${number}` : number;
  }
  _appendTimes() {
    const { format24 } = this._options;
    if (format24) {
      this._getAppendClock(
        this.hoursArray,
        `[${ATTR_TIMEPICKER_CLOCK}]`,
        ATTR_TIMEPICKER_TIPS_HOURS
      );
      this._getAppendClock(
        this.innerHours,
        `[${ATTR_TIMEPICKER_CLOCK_INNER}]`,
        ATTR_TIMEPICKER_INNER_HOURS
      );
      return;
    }
    this._getAppendClock(
      this.hoursArray,
      `[${ATTR_TIMEPICKER_CLOCK}]`,
      ATTR_TIMEPICKER_TIPS_HOURS
    );
  }
  _getConfig(config) {
    const dataAttributes = manipulator_default.getDataAttributes(this._element);
    config = {
      ...Default16,
      ...dataAttributes,
      ...config
    };
    typeCheckConfig(NAME18, config, DefaultType16);
    return config;
  }
  _getClasses(classes) {
    const dataAttributes = manipulator_default.getDataClassAttributes(this._element);
    classes = {
      ...DefaultClasses11,
      ...dataAttributes,
      ...classes
    };
    typeCheckConfig(NAME18, classes, DefaultClassesType11);
    return classes;
  }
  _getContainer() {
    return selector_engine_default.findOne(this._options.container);
  }
  _getValidate(event) {
    const { invalidLabel, format24, format12, appendValidationInfo } = this._options;
    let inValidDiv;
    if (appendValidationInfo) {
      inValidDiv = element("div");
      inValidDiv.setAttribute(ATTR_TIMEPICKER_INVALID_FEEDBACK, "");
      inValidDiv.innerHTML = invalidLabel;
    }
    EventHandlerMulti.on(this.input, event, ({ target }) => {
      if (this._options === null || this.input.value === "")
        return;
      const regexAMFormat = /^(0?[1-9]|1[012])(:[0-5]\d) [APap][mM]$/;
      const regexNormalFormat = /^([01]\d|2[0-3])(:[0-5]\d)$/;
      const testedAMRegex = regexAMFormat.test(target.value);
      const testedNormalRegex = regexNormalFormat.test(target.value);
      if (testedNormalRegex !== true && format24 || testedAMRegex !== true && format12) {
        if (appendValidationInfo) {
          this.input.setAttribute(ATTR_TIMEPICKER_IS_INVALID, "");
          this.input.parentNode.insertBefore(
            inValidDiv,
            this.input.nextSibling
          );
        }
        manipulator_default.addStyle(target, { marginBottom: 0 });
        manipulator_default.addStyle(inValidDiv, { bottom: "-23px" });
        this._isInvalidTimeFormat = true;
        return;
      }
      this.input.removeAttribute(ATTR_TIMEPICKER_IS_INVALID);
      this._isInvalidTimeFormat = false;
      const allInvalid = selector_engine_default.findOne(
        `[${ATTR_TIMEPICKER_INVALID_FEEDBACK}]`
      );
      if (allInvalid === null)
        return;
      allInvalid.remove();
    });
  }
  // Static
  static getInstance(element2) {
    return data_default.getData(element2, DATA_KEY17);
  }
  static getOrCreateInstance(element2, config = {}) {
    return this.getInstance(element2) || new this(element2, typeof config === "object" ? config : null);
  }
};
var timepicker_default = Timepicker;
event_handler_default.on(window, "DOMContentLoaded", () => {
  selector_engine_default.find(SELECTOR_ATTR_TIMEPICKER_INIT).forEach((timepicker) => {
    let instance = Timepicker.getInstance(timepicker);
    const { timepickerFormat24 } = timepicker.dataset;
    if (instance)
      return;
    if (timepickerFormat24 === "true") {
      instance = new Timepicker(timepicker, { format24: true });
      return;
    }
    instance = new Timepicker(timepicker);
  });
});

// node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js
function get(element2) {
  return getComputedStyle(element2);
}
function set(element2, obj) {
  for (var key in obj) {
    var val = obj[key];
    if (typeof val === "number") {
      val = val + "px";
    }
    element2.style[key] = val;
  }
  return element2;
}
function div(className) {
  var div2 = document.createElement("div");
  div2.className = className;
  return div2;
}
var elMatches = typeof Element !== "undefined" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function matches(element2, query) {
  if (!elMatches) {
    throw new Error("No element matching method supported");
  }
  return elMatches.call(element2, query);
}
function remove(element2) {
  if (element2.remove) {
    element2.remove();
  } else {
    if (element2.parentNode) {
      element2.parentNode.removeChild(element2);
    }
  }
}
function queryChildren(element2, selector) {
  return Array.prototype.filter.call(
    element2.children,
    function(child) {
      return matches(child, selector);
    }
  );
}
var cls = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(x) {
      return "ps__thumb-" + x;
    },
    rail: function(x) {
      return "ps__rail-" + x;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(x) {
      return "ps--active-" + x;
    },
    scrolling: function(x) {
      return "ps--scrolling-" + x;
    }
  }
};
var scrollingClassTimeout = { x: null, y: null };
function addScrollingClass(i, x) {
  var classList = i.element.classList;
  var className = cls.state.scrolling(x);
  if (classList.contains(className)) {
    clearTimeout(scrollingClassTimeout[x]);
  } else {
    classList.add(className);
  }
}
function removeScrollingClass(i, x) {
  scrollingClassTimeout[x] = setTimeout(
    function() {
      return i.isAlive && i.element.classList.remove(cls.state.scrolling(x));
    },
    i.settings.scrollingThreshold
  );
}
function setScrollingClassInstantly(i, x) {
  addScrollingClass(i, x);
  removeScrollingClass(i, x);
}
var EventElement = function EventElement2(element2) {
  this.element = element2;
  this.handlers = {};
};
var prototypeAccessors = { isEmpty: { configurable: true } };
EventElement.prototype.bind = function bind(eventName, handler) {
  if (typeof this.handlers[eventName] === "undefined") {
    this.handlers[eventName] = [];
  }
  this.handlers[eventName].push(handler);
  this.element.addEventListener(eventName, handler, false);
};
EventElement.prototype.unbind = function unbind(eventName, target) {
  var this$1 = this;
  this.handlers[eventName] = this.handlers[eventName].filter(function(handler) {
    if (target && handler !== target) {
      return true;
    }
    this$1.element.removeEventListener(eventName, handler, false);
    return false;
  });
};
EventElement.prototype.unbindAll = function unbindAll() {
  for (var name in this.handlers) {
    this.unbind(name);
  }
};
prototypeAccessors.isEmpty.get = function() {
  var this$1 = this;
  return Object.keys(this.handlers).every(
    function(key) {
      return this$1.handlers[key].length === 0;
    }
  );
};
Object.defineProperties(EventElement.prototype, prototypeAccessors);
var EventManager = function EventManager2() {
  this.eventElements = [];
};
EventManager.prototype.eventElement = function eventElement(element2) {
  var ee = this.eventElements.filter(function(ee2) {
    return ee2.element === element2;
  })[0];
  if (!ee) {
    ee = new EventElement(element2);
    this.eventElements.push(ee);
  }
  return ee;
};
EventManager.prototype.bind = function bind2(element2, eventName, handler) {
  this.eventElement(element2).bind(eventName, handler);
};
EventManager.prototype.unbind = function unbind2(element2, eventName, handler) {
  var ee = this.eventElement(element2);
  ee.unbind(eventName, handler);
  if (ee.isEmpty) {
    this.eventElements.splice(this.eventElements.indexOf(ee), 1);
  }
};
EventManager.prototype.unbindAll = function unbindAll2() {
  this.eventElements.forEach(function(e) {
    return e.unbindAll();
  });
  this.eventElements = [];
};
EventManager.prototype.once = function once(element2, eventName, handler) {
  var ee = this.eventElement(element2);
  var onceHandler = function(evt) {
    ee.unbind(eventName, onceHandler);
    handler(evt);
  };
  ee.bind(eventName, onceHandler);
};
function createEvent(name) {
  if (typeof window.CustomEvent === "function") {
    return new CustomEvent(name);
  } else {
    var evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(name, false, false, void 0);
    return evt;
  }
}
function processScrollDiff(i, axis, diff, useScrollingClass, forceFireReachEvent) {
  if (useScrollingClass === void 0)
    useScrollingClass = true;
  if (forceFireReachEvent === void 0)
    forceFireReachEvent = false;
  var fields;
  if (axis === "top") {
    fields = [
      "contentHeight",
      "containerHeight",
      "scrollTop",
      "y",
      "up",
      "down"
    ];
  } else if (axis === "left") {
    fields = [
      "contentWidth",
      "containerWidth",
      "scrollLeft",
      "x",
      "left",
      "right"
    ];
  } else {
    throw new Error("A proper axis should be provided");
  }
  processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);
}
function processScrollDiff$1(i, diff, ref, useScrollingClass, forceFireReachEvent) {
  var contentHeight = ref[0];
  var containerHeight = ref[1];
  var scrollTop = ref[2];
  var y = ref[3];
  var up = ref[4];
  var down = ref[5];
  if (useScrollingClass === void 0)
    useScrollingClass = true;
  if (forceFireReachEvent === void 0)
    forceFireReachEvent = false;
  var element2 = i.element;
  i.reach[y] = null;
  if (element2[scrollTop] < 1) {
    i.reach[y] = "start";
  }
  if (element2[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {
    i.reach[y] = "end";
  }
  if (diff) {
    element2.dispatchEvent(createEvent("ps-scroll-" + y));
    if (diff < 0) {
      element2.dispatchEvent(createEvent("ps-scroll-" + up));
    } else if (diff > 0) {
      element2.dispatchEvent(createEvent("ps-scroll-" + down));
    }
    if (useScrollingClass) {
      setScrollingClassInstantly(i, y);
    }
  }
  if (i.reach[y] && (diff || forceFireReachEvent)) {
    element2.dispatchEvent(createEvent("ps-" + y + "-reach-" + i.reach[y]));
  }
}
function toInt(x) {
  return parseInt(x, 10) || 0;
}
function isEditable(el) {
  return matches(el, "input,[contenteditable]") || matches(el, "select,[contenteditable]") || matches(el, "textarea,[contenteditable]") || matches(el, "button,[contenteditable]");
}
function outerWidth(element2) {
  var styles = get(element2);
  return toInt(styles.width) + toInt(styles.paddingLeft) + toInt(styles.paddingRight) + toInt(styles.borderLeftWidth) + toInt(styles.borderRightWidth);
}
var env = {
  isWebKit: typeof document !== "undefined" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window !== "undefined" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator !== "undefined" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator !== "undefined" && /Chrome/i.test(navigator && navigator.userAgent)
};
function updateGeometry(i) {
  var element2 = i.element;
  var roundedScrollTop = Math.floor(element2.scrollTop);
  var rect = element2.getBoundingClientRect();
  i.containerWidth = Math.round(rect.width);
  i.containerHeight = Math.round(rect.height);
  i.contentWidth = element2.scrollWidth;
  i.contentHeight = element2.scrollHeight;
  if (!element2.contains(i.scrollbarXRail)) {
    queryChildren(element2, cls.element.rail("x")).forEach(
      function(el) {
        return remove(el);
      }
    );
    element2.appendChild(i.scrollbarXRail);
  }
  if (!element2.contains(i.scrollbarYRail)) {
    queryChildren(element2, cls.element.rail("y")).forEach(
      function(el) {
        return remove(el);
      }
    );
    element2.appendChild(i.scrollbarYRail);
  }
  if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
    i.scrollbarXActive = true;
    i.railXWidth = i.containerWidth - i.railXMarginWidth;
    i.railXRatio = i.containerWidth / i.railXWidth;
    i.scrollbarXWidth = getThumbSize(
      i,
      toInt(i.railXWidth * i.containerWidth / i.contentWidth)
    );
    i.scrollbarXLeft = toInt(
      (i.negativeScrollAdjustment + element2.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth)
    );
  } else {
    i.scrollbarXActive = false;
  }
  if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
    i.scrollbarYActive = true;
    i.railYHeight = i.containerHeight - i.railYMarginHeight;
    i.railYRatio = i.containerHeight / i.railYHeight;
    i.scrollbarYHeight = getThumbSize(
      i,
      toInt(i.railYHeight * i.containerHeight / i.contentHeight)
    );
    i.scrollbarYTop = toInt(
      roundedScrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight)
    );
  } else {
    i.scrollbarYActive = false;
  }
  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
  }
  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
  }
  updateCss(element2, i);
  if (i.scrollbarXActive) {
    element2.classList.add(cls.state.active("x"));
  } else {
    element2.classList.remove(cls.state.active("x"));
    i.scrollbarXWidth = 0;
    i.scrollbarXLeft = 0;
    element2.scrollLeft = i.isRtl === true ? i.contentWidth : 0;
  }
  if (i.scrollbarYActive) {
    element2.classList.add(cls.state.active("y"));
  } else {
    element2.classList.remove(cls.state.active("y"));
    i.scrollbarYHeight = 0;
    i.scrollbarYTop = 0;
    element2.scrollTop = 0;
  }
}
function getThumbSize(i, thumbSize) {
  if (i.settings.minScrollbarLength) {
    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
  }
  if (i.settings.maxScrollbarLength) {
    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
  }
  return thumbSize;
}
function updateCss(element2, i) {
  var xRailOffset = { width: i.railXWidth };
  var roundedScrollTop = Math.floor(element2.scrollTop);
  if (i.isRtl) {
    xRailOffset.left = i.negativeScrollAdjustment + element2.scrollLeft + i.containerWidth - i.contentWidth;
  } else {
    xRailOffset.left = element2.scrollLeft;
  }
  if (i.isScrollbarXUsingBottom) {
    xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;
  } else {
    xRailOffset.top = i.scrollbarXTop + roundedScrollTop;
  }
  set(i.scrollbarXRail, xRailOffset);
  var yRailOffset = { top: roundedScrollTop, height: i.railYHeight };
  if (i.isScrollbarYUsingRight) {
    if (i.isRtl) {
      yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element2.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth - 9;
    } else {
      yRailOffset.right = i.scrollbarYRight - element2.scrollLeft;
    }
  } else {
    if (i.isRtl) {
      yRailOffset.left = i.negativeScrollAdjustment + element2.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
    } else {
      yRailOffset.left = i.scrollbarYLeft + element2.scrollLeft;
    }
  }
  set(i.scrollbarYRail, yRailOffset);
  set(i.scrollbarX, {
    left: i.scrollbarXLeft,
    width: i.scrollbarXWidth - i.railBorderXWidth
  });
  set(i.scrollbarY, {
    top: i.scrollbarYTop,
    height: i.scrollbarYHeight - i.railBorderYWidth
  });
}
function clickRail(i) {
  var element2 = i.element;
  i.event.bind(i.scrollbarY, "mousedown", function(e) {
    return e.stopPropagation();
  });
  i.event.bind(i.scrollbarYRail, "mousedown", function(e) {
    var positionTop = e.pageY - window.pageYOffset - i.scrollbarYRail.getBoundingClientRect().top;
    var direction = positionTop > i.scrollbarYTop ? 1 : -1;
    i.element.scrollTop += direction * i.containerHeight;
    updateGeometry(i);
    e.stopPropagation();
  });
  i.event.bind(i.scrollbarX, "mousedown", function(e) {
    return e.stopPropagation();
  });
  i.event.bind(i.scrollbarXRail, "mousedown", function(e) {
    var positionLeft = e.pageX - window.pageXOffset - i.scrollbarXRail.getBoundingClientRect().left;
    var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;
    i.element.scrollLeft += direction * i.containerWidth;
    updateGeometry(i);
    e.stopPropagation();
  });
}
function dragThumb(i) {
  bindMouseScrollHandler(i, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]);
  bindMouseScrollHandler(i, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function bindMouseScrollHandler(i, ref) {
  var containerHeight = ref[0];
  var contentHeight = ref[1];
  var pageY = ref[2];
  var railYHeight = ref[3];
  var scrollbarY = ref[4];
  var scrollbarYHeight = ref[5];
  var scrollTop = ref[6];
  var y = ref[7];
  var scrollbarYRail = ref[8];
  var element2 = i.element;
  var startingScrollTop = null;
  var startingMousePageY = null;
  var scrollBy = null;
  function mouseMoveHandler(e) {
    if (e.touches && e.touches[0]) {
      e[pageY] = e.touches[0].pageY;
    }
    element2[scrollTop] = startingScrollTop + scrollBy * (e[pageY] - startingMousePageY);
    addScrollingClass(i, y);
    updateGeometry(i);
    e.stopPropagation();
    if (e.type.startsWith("touch") && e.changedTouches.length > 1) {
      e.preventDefault();
    }
  }
  function mouseUpHandler() {
    removeScrollingClass(i, y);
    i[scrollbarYRail].classList.remove(cls.state.clicking);
    i.event.unbind(i.ownerDocument, "mousemove", mouseMoveHandler);
  }
  function bindMoves(e, touchMode) {
    startingScrollTop = element2[scrollTop];
    if (touchMode && e.touches) {
      e[pageY] = e.touches[0].pageY;
    }
    startingMousePageY = e[pageY];
    scrollBy = (i[contentHeight] - i[containerHeight]) / (i[railYHeight] - i[scrollbarYHeight]);
    if (!touchMode) {
      i.event.bind(i.ownerDocument, "mousemove", mouseMoveHandler);
      i.event.once(i.ownerDocument, "mouseup", mouseUpHandler);
      e.preventDefault();
    } else {
      i.event.bind(i.ownerDocument, "touchmove", mouseMoveHandler);
    }
    i[scrollbarYRail].classList.add(cls.state.clicking);
    e.stopPropagation();
  }
  i.event.bind(i[scrollbarY], "mousedown", function(e) {
    bindMoves(e);
  });
  i.event.bind(i[scrollbarY], "touchstart", function(e) {
    bindMoves(e, true);
  });
}
function keyboard(i) {
  var element2 = i.element;
  var elementHovered = function() {
    return matches(element2, ":hover");
  };
  var scrollbarFocused = function() {
    return matches(i.scrollbarX, ":focus") || matches(i.scrollbarY, ":focus");
  };
  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = Math.floor(element2.scrollTop);
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if (scrollTop === 0 && deltaY > 0 || scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0) {
        return !i.settings.wheelPropagation;
      }
    }
    var scrollLeft = element2.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }
  i.event.bind(i.ownerDocument, "keydown", function(e) {
    if (e.isDefaultPrevented && e.isDefaultPrevented() || e.defaultPrevented) {
      return;
    }
    if (!elementHovered() && !scrollbarFocused()) {
      return;
    }
    var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
    if (activeElement) {
      if (activeElement.tagName === "IFRAME") {
        activeElement = activeElement.contentDocument.activeElement;
      } else {
        while (activeElement.shadowRoot) {
          activeElement = activeElement.shadowRoot.activeElement;
        }
      }
      if (isEditable(activeElement)) {
        return;
      }
    }
    var deltaX = 0;
    var deltaY = 0;
    switch (e.which) {
      case 37:
        if (e.metaKey) {
          deltaX = -i.contentWidth;
        } else if (e.altKey) {
          deltaX = -i.containerWidth;
        } else {
          deltaX = -30;
        }
        break;
      case 38:
        if (e.metaKey) {
          deltaY = i.contentHeight;
        } else if (e.altKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = 30;
        }
        break;
      case 39:
        if (e.metaKey) {
          deltaX = i.contentWidth;
        } else if (e.altKey) {
          deltaX = i.containerWidth;
        } else {
          deltaX = 30;
        }
        break;
      case 40:
        if (e.metaKey) {
          deltaY = -i.contentHeight;
        } else if (e.altKey) {
          deltaY = -i.containerHeight;
        } else {
          deltaY = -30;
        }
        break;
      case 32:
        if (e.shiftKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = -i.containerHeight;
        }
        break;
      case 33:
        deltaY = i.containerHeight;
        break;
      case 34:
        deltaY = -i.containerHeight;
        break;
      case 36:
        deltaY = i.contentHeight;
        break;
      case 35:
        deltaY = -i.contentHeight;
        break;
      default:
        return;
    }
    if (i.settings.suppressScrollX && deltaX !== 0) {
      return;
    }
    if (i.settings.suppressScrollY && deltaY !== 0) {
      return;
    }
    element2.scrollTop -= deltaY;
    element2.scrollLeft += deltaX;
    updateGeometry(i);
    if (shouldPreventDefault(deltaX, deltaY)) {
      e.preventDefault();
    }
  });
}
function wheel(i) {
  var element2 = i.element;
  function shouldPreventDefault(deltaX, deltaY) {
    var roundedScrollTop = Math.floor(element2.scrollTop);
    var isTop = element2.scrollTop === 0;
    var isBottom = roundedScrollTop + element2.offsetHeight === element2.scrollHeight;
    var isLeft = element2.scrollLeft === 0;
    var isRight = element2.scrollLeft + element2.offsetWidth === element2.scrollWidth;
    var hitsBound;
    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      hitsBound = isTop || isBottom;
    } else {
      hitsBound = isLeft || isRight;
    }
    return hitsBound ? !i.settings.wheelPropagation : true;
  }
  function getDeltaFromEvent(e) {
    var deltaX = e.deltaX;
    var deltaY = -1 * e.deltaY;
    if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
      deltaX = -1 * e.wheelDeltaX / 6;
      deltaY = e.wheelDeltaY / 6;
    }
    if (e.deltaMode && e.deltaMode === 1) {
      deltaX *= 10;
      deltaY *= 10;
    }
    if (deltaX !== deltaX && deltaY !== deltaY) {
      deltaX = 0;
      deltaY = e.wheelDelta;
    }
    if (e.shiftKey) {
      return [-deltaY, -deltaX];
    }
    return [deltaX, deltaY];
  }
  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!env.isWebKit && element2.querySelector("select:focus")) {
      return true;
    }
    if (!element2.contains(target)) {
      return false;
    }
    var cursor = target;
    while (cursor && cursor !== element2) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }
      var style = get(cursor);
      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
        if (maxScrollTop > 0) {
          if (cursor.scrollTop > 0 && deltaY < 0 || cursor.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      }
      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
        if (maxScrollLeft > 0) {
          if (cursor.scrollLeft > 0 && deltaX < 0 || cursor.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }
      cursor = cursor.parentNode;
    }
    return false;
  }
  function mousewheelHandler(e) {
    var ref = getDeltaFromEvent(e);
    var deltaX = ref[0];
    var deltaY = ref[1];
    if (shouldBeConsumedByChild(e.target, deltaX, deltaY)) {
      return;
    }
    var shouldPrevent = false;
    if (!i.settings.useBothWheelAxes) {
      element2.scrollTop -= deltaY * i.settings.wheelSpeed;
      element2.scrollLeft += deltaX * i.settings.wheelSpeed;
    } else if (i.scrollbarYActive && !i.scrollbarXActive) {
      if (deltaY) {
        element2.scrollTop -= deltaY * i.settings.wheelSpeed;
      } else {
        element2.scrollTop += deltaX * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    } else if (i.scrollbarXActive && !i.scrollbarYActive) {
      if (deltaX) {
        element2.scrollLeft += deltaX * i.settings.wheelSpeed;
      } else {
        element2.scrollLeft -= deltaY * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    }
    updateGeometry(i);
    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
    if (shouldPrevent && !e.ctrlKey) {
      e.stopPropagation();
      e.preventDefault();
    }
  }
  if (typeof window.onwheel !== "undefined") {
    i.event.bind(element2, "wheel", mousewheelHandler);
  } else if (typeof window.onmousewheel !== "undefined") {
    i.event.bind(element2, "mousewheel", mousewheelHandler);
  }
}
function touch(i) {
  if (!env.supportsTouch && !env.supportsIePointer) {
    return;
  }
  var element2 = i.element;
  function shouldPrevent(deltaX, deltaY) {
    var scrollTop = Math.floor(element2.scrollTop);
    var scrollLeft = element2.scrollLeft;
    var magnitudeX = Math.abs(deltaX);
    var magnitudeY = Math.abs(deltaY);
    if (magnitudeY > magnitudeX) {
      if (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight || deltaY > 0 && scrollTop === 0) {
        return window.scrollY === 0 && deltaY > 0 && env.isChrome;
      }
    } else if (magnitudeX > magnitudeY) {
      if (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth || deltaX > 0 && scrollLeft === 0) {
        return true;
      }
    }
    return true;
  }
  function applyTouchMove(differenceX, differenceY) {
    element2.scrollTop -= differenceY;
    element2.scrollLeft -= differenceX;
    updateGeometry(i);
  }
  var startOffset = {};
  var startTime = 0;
  var speed = {};
  var easingLoop = null;
  function getTouch(e) {
    if (e.targetTouches) {
      return e.targetTouches[0];
    } else {
      return e;
    }
  }
  function shouldHandle(e) {
    if (e.pointerType && e.pointerType === "pen" && e.buttons === 0) {
      return false;
    }
    if (e.targetTouches && e.targetTouches.length === 1) {
      return true;
    }
    if (e.pointerType && e.pointerType !== "mouse" && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
      return true;
    }
    return false;
  }
  function touchStart(e) {
    if (!shouldHandle(e)) {
      return;
    }
    var touch2 = getTouch(e);
    startOffset.pageX = touch2.pageX;
    startOffset.pageY = touch2.pageY;
    startTime = new Date().getTime();
    if (easingLoop !== null) {
      clearInterval(easingLoop);
    }
  }
  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!element2.contains(target)) {
      return false;
    }
    var cursor = target;
    while (cursor && cursor !== element2) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }
      var style = get(cursor);
      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
        if (maxScrollTop > 0) {
          if (cursor.scrollTop > 0 && deltaY < 0 || cursor.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      }
      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
        if (maxScrollLeft > 0) {
          if (cursor.scrollLeft > 0 && deltaX < 0 || cursor.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }
      cursor = cursor.parentNode;
    }
    return false;
  }
  function touchMove(e) {
    if (shouldHandle(e)) {
      var touch2 = getTouch(e);
      var currentOffset = { pageX: touch2.pageX, pageY: touch2.pageY };
      var differenceX = currentOffset.pageX - startOffset.pageX;
      var differenceY = currentOffset.pageY - startOffset.pageY;
      if (shouldBeConsumedByChild(e.target, differenceX, differenceY)) {
        return;
      }
      applyTouchMove(differenceX, differenceY);
      startOffset = currentOffset;
      var currentTime = new Date().getTime();
      var timeGap = currentTime - startTime;
      if (timeGap > 0) {
        speed.x = differenceX / timeGap;
        speed.y = differenceY / timeGap;
        startTime = currentTime;
      }
      if (shouldPrevent(differenceX, differenceY)) {
        e.preventDefault();
      }
    }
  }
  function touchEnd() {
    if (i.settings.swipeEasing) {
      clearInterval(easingLoop);
      easingLoop = setInterval(function() {
        if (i.isInitialized) {
          clearInterval(easingLoop);
          return;
        }
        if (!speed.x && !speed.y) {
          clearInterval(easingLoop);
          return;
        }
        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
          clearInterval(easingLoop);
          return;
        }
        if (!i.element) {
          clearInterval(easingLoop);
          return;
        }
        applyTouchMove(speed.x * 30, speed.y * 30);
        speed.x *= 0.8;
        speed.y *= 0.8;
      }, 10);
    }
  }
  if (env.supportsTouch) {
    i.event.bind(element2, "touchstart", touchStart);
    i.event.bind(element2, "touchmove", touchMove);
    i.event.bind(element2, "touchend", touchEnd);
  } else if (env.supportsIePointer) {
    if (window.PointerEvent) {
      i.event.bind(element2, "pointerdown", touchStart);
      i.event.bind(element2, "pointermove", touchMove);
      i.event.bind(element2, "pointerup", touchEnd);
    } else if (window.MSPointerEvent) {
      i.event.bind(element2, "MSPointerDown", touchStart);
      i.event.bind(element2, "MSPointerMove", touchMove);
      i.event.bind(element2, "MSPointerUp", touchEnd);
    }
  }
}
var defaultSettings = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: false,
    suppressScrollY: false,
    swipeEasing: true,
    useBothWheelAxes: false,
    wheelPropagation: true,
    wheelSpeed: 1
  };
};
var handlers = {
  "click-rail": clickRail,
  "drag-thumb": dragThumb,
  keyboard,
  wheel,
  touch
};
var PerfectScrollbar = function PerfectScrollbar2(element2, userSettings) {
  var this$1 = this;
  if (userSettings === void 0)
    userSettings = {};
  if (typeof element2 === "string") {
    element2 = document.querySelector(element2);
  }
  if (!element2 || !element2.nodeName) {
    throw new Error("no element is specified to initialize PerfectScrollbar");
  }
  this.element = element2;
  element2.classList.add(cls.main);
  this.settings = defaultSettings();
  for (var key in userSettings) {
    this.settings[key] = userSettings[key];
  }
  this.containerWidth = null;
  this.containerHeight = null;
  this.contentWidth = null;
  this.contentHeight = null;
  var focus = function() {
    return element2.classList.add(cls.state.focus);
  };
  var blur = function() {
    return element2.classList.remove(cls.state.focus);
  };
  this.isRtl = get(element2).direction === "rtl";
  if (this.isRtl === true) {
    element2.classList.add(cls.rtl);
  }
  this.isNegativeScroll = function() {
    var originalScrollLeft = element2.scrollLeft;
    var result = null;
    element2.scrollLeft = -1;
    result = element2.scrollLeft < 0;
    element2.scrollLeft = originalScrollLeft;
    return result;
  }();
  this.negativeScrollAdjustment = this.isNegativeScroll ? element2.scrollWidth - element2.clientWidth : 0;
  this.event = new EventManager();
  this.ownerDocument = element2.ownerDocument || document;
  this.scrollbarXRail = div(cls.element.rail("x"));
  element2.appendChild(this.scrollbarXRail);
  this.scrollbarX = div(cls.element.thumb("x"));
  this.scrollbarXRail.appendChild(this.scrollbarX);
  this.scrollbarX.setAttribute("tabindex", 0);
  this.event.bind(this.scrollbarX, "focus", focus);
  this.event.bind(this.scrollbarX, "blur", blur);
  this.scrollbarXActive = null;
  this.scrollbarXWidth = null;
  this.scrollbarXLeft = null;
  var railXStyle = get(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);
  if (isNaN(this.scrollbarXBottom)) {
    this.isScrollbarXUsingBottom = false;
    this.scrollbarXTop = toInt(railXStyle.top);
  } else {
    this.isScrollbarXUsingBottom = true;
  }
  this.railBorderXWidth = toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);
  set(this.scrollbarXRail, { display: "block" });
  this.railXMarginWidth = toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);
  set(this.scrollbarXRail, { display: "" });
  this.railXWidth = null;
  this.railXRatio = null;
  this.scrollbarYRail = div(cls.element.rail("y"));
  element2.appendChild(this.scrollbarYRail);
  this.scrollbarY = div(cls.element.thumb("y"));
  this.scrollbarYRail.appendChild(this.scrollbarY);
  this.scrollbarY.setAttribute("tabindex", 0);
  this.event.bind(this.scrollbarY, "focus", focus);
  this.event.bind(this.scrollbarY, "blur", blur);
  this.scrollbarYActive = null;
  this.scrollbarYHeight = null;
  this.scrollbarYTop = null;
  var railYStyle = get(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(railYStyle.right, 10);
  if (isNaN(this.scrollbarYRight)) {
    this.isScrollbarYUsingRight = false;
    this.scrollbarYLeft = toInt(railYStyle.left);
  } else {
    this.isScrollbarYUsingRight = true;
  }
  this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
  this.railBorderYWidth = toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);
  set(this.scrollbarYRail, { display: "block" });
  this.railYMarginHeight = toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);
  set(this.scrollbarYRail, { display: "" });
  this.railYHeight = null;
  this.railYRatio = null;
  this.reach = {
    x: element2.scrollLeft <= 0 ? "start" : element2.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: element2.scrollTop <= 0 ? "start" : element2.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  };
  this.isAlive = true;
  this.settings.handlers.forEach(function(handlerName) {
    return handlers[handlerName](this$1);
  });
  this.lastScrollTop = Math.floor(element2.scrollTop);
  this.lastScrollLeft = element2.scrollLeft;
  this.event.bind(this.element, "scroll", function(e) {
    return this$1.onScroll(e);
  });
  updateGeometry(this);
};
PerfectScrollbar.prototype.update = function update() {
  if (!this.isAlive) {
    return;
  }
  this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0;
  set(this.scrollbarXRail, { display: "block" });
  set(this.scrollbarYRail, { display: "block" });
  this.railXMarginWidth = toInt(get(this.scrollbarXRail).marginLeft) + toInt(get(this.scrollbarXRail).marginRight);
  this.railYMarginHeight = toInt(get(this.scrollbarYRail).marginTop) + toInt(get(this.scrollbarYRail).marginBottom);
  set(this.scrollbarXRail, { display: "none" });
  set(this.scrollbarYRail, { display: "none" });
  updateGeometry(this);
  processScrollDiff(this, "top", 0, false, true);
  processScrollDiff(this, "left", 0, false, true);
  set(this.scrollbarXRail, { display: "" });
  set(this.scrollbarYRail, { display: "" });
};
PerfectScrollbar.prototype.onScroll = function onScroll(e) {
  if (!this.isAlive) {
    return;
  }
  updateGeometry(this);
  processScrollDiff(this, "top", this.element.scrollTop - this.lastScrollTop);
  processScrollDiff(
    this,
    "left",
    this.element.scrollLeft - this.lastScrollLeft
  );
  this.lastScrollTop = Math.floor(this.element.scrollTop);
  this.lastScrollLeft = this.element.scrollLeft;
};
PerfectScrollbar.prototype.destroy = function destroy() {
  if (!this.isAlive) {
    return;
  }
  this.event.unbindAll();
  remove(this.scrollbarX);
  remove(this.scrollbarY);
  remove(this.scrollbarXRail);
  remove(this.scrollbarYRail);
  this.removePsClasses();
  this.element = null;
  this.scrollbarX = null;
  this.scrollbarY = null;
  this.scrollbarXRail = null;
  this.scrollbarYRail = null;
  this.isAlive = false;
};
PerfectScrollbar.prototype.removePsClasses = function removePsClasses() {
  this.element.className = this.element.className.split(" ").filter(function(name) {
    return !name.match(/^ps([-_].+|)$/);
  }).join(" ");
};
var perfect_scrollbar_esm_default = PerfectScrollbar;

// node_modules/tw-elements/dist/src/js/util/touch/swipe.js
var DEFAULT_OPTIONS2 = {
  threshold: 10,
  direction: "all"
};
var Swipe = class {
  constructor(element2, options) {
    this._element = element2;
    this._startPosition = null;
    this._options = {
      ...DEFAULT_OPTIONS2,
      ...options
    };
  }
  handleTouchStart(e) {
    this._startPosition = this._getCoordinates(e);
  }
  handleTouchMove(e) {
    if (!this._startPosition)
      return;
    const position = this._getCoordinates(e);
    const displacement = {
      x: position.x - this._startPosition.x,
      y: position.y - this._startPosition.y
    };
    const swipe = this._getDirection(displacement);
    if (this._options.direction === "all") {
      if (swipe.y.value < this._options.threshold && swipe.x.value < this._options.threshold) {
        return;
      }
      const direction = swipe.y.value > swipe.x.value ? swipe.y.direction : swipe.x.direction;
      event_handler_default.trigger(this._element, `swipe${direction}`);
      event_handler_default.trigger(this._element, "swipe", { direction });
      this._startPosition = null;
      return;
    }
    const axis = this._options.direction === "left" || this._options === "right" ? "x" : "y";
    if (swipe[axis].direction === this._options.direction && swipe[axis].value > this._options.threshold) {
      event_handler_default.trigger(this._element, `swipe${swipe[axis].direction}`);
      this._startPosition = null;
    }
  }
  handleTouchEnd() {
    this._startPosition = null;
  }
  _getCoordinates(e) {
    const [touch2] = e.touches;
    return {
      x: touch2.clientX,
      y: touch2.clientY
    };
  }
  _getDirection(displacement) {
    return {
      x: {
        direction: displacement.x < 0 ? "left" : "right",
        value: Math.abs(displacement.x)
      },
      y: {
        direction: displacement.y < 0 ? "up" : "down",
        value: Math.abs(displacement.y)
      }
    };
  }
};
var swipe_default = Swipe;

// node_modules/tw-elements/dist/src/js/util/touch/index.js
var Touch = class {
  constructor(element2, event = "swipe", options = {}) {
    this._element = element2;
    this._event = event;
    this.swipe = new swipe_default(element2, options);
    this._touchStartHandler = this._handleTouchStart.bind(this);
    this._touchMoveHandler = this._handleTouchMove.bind(this);
    this._touchEndHandler = this._handleTouchEnd.bind(this);
  }
  dispose() {
    this._element.removeEventListener("touchstart", this._touchStartHandler);
    this._element.removeEventListener("touchmove", this._touchMoveHandler);
    window.removeEventListener("touchend", this._touchEndHandler);
  }
  init() {
    this._element.addEventListener(
      "touchstart",
      (e) => this._handleTouchStart(e)
    );
    this._element.addEventListener(
      "touchmove",
      (e) => this._handleTouchMove(e)
    );
    window.addEventListener("touchend", (e) => this._handleTouchEnd(e));
  }
  _handleTouchStart(e) {
    this[this._event].handleTouchStart(e);
  }
  _handleTouchMove(e) {
    this[this._event].handleTouchMove(e);
  }
  _handleTouchEnd(e) {
    this[this._event].handleTouchEnd(e);
  }
};
var touch_default = Touch;

// node_modules/tw-elements/dist/src/js/util/add-perfect-scrollbar-styles.js
var psClasses = "group/ps overflow-hidden [overflow-anchor:none] [overflow-style:none] touch-none";
var railXClasses = "group/x absolute bottom-0 !top-auto h-[15px] hidden opacity-0 [transition:background-color_.2s_linear,_opacity_.2s_linear] motion-reduce:transition-none group-[&.ps--active-x]/ps:block group-[&.ps--active-x]/ps:bg-transparent group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-x]/ps:opacity-60 hover:!opacity-90 hover:bg-[#eee] focus:!opacity-90 focus:bg-[#eee] [&.ps--clicking]:!opacity-90 [&.ps--clicking]:bg-[#eee] outline-none";
var railXThumbClasses = "absolute bottom-[2px] rounded-md h-1.5 opacity-0 group-hover/ps:opacity-100 group-focus/ps:opacity-100 group-active/ps:opacity-100 bg-[#aaa] [transition:background-color_.2s_linear,_height_.2s_ease-in-out] group-hover/x:bg-[#999] group-hover/x:h-[11px] group-focus/x:bg-[#999] group-focus/x:h-[11px] group-[&.ps--clicking]/x:bg-[#999] group-[&.ps--clicking]/x:h-[11px] outline-none";
var railYClasses = "group/y absolute right-0 !left-auto w-[15px] hidden opacity-0 [transition:background-color_.2s_linear,_opacity_.2s_linear] motion-reduce:transition-none group-[&.ps--active-y]/ps:block group-[&.ps--active-y]/ps:bg-transparent group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-y]/ps:opacity-60 hover:!opacity-90 hover:bg-[#eee] focus:!opacity-90 focus:bg-[#eee] [&.ps--clicking]:!opacity-90 [&.ps--clicking]:bg-[#eee] outline-none";
var railYThumbClasses = "absolute right-[2px] rounded-md w-1.5 opacity-0 group-hover/ps:opacity-100 group-focus/ps:opacity-100 group-active/ps:opacity-100 bg-[#aaa] [transition:background-color_.2s_linear,_width_.2s_ease-in-out] group-hover/y:bg-[#999] group-hover/y:w-[11px] group-focus/y:bg-[#999] group-focus/y:w-[11px] group-[&.ps--clicking]/y:bg-[#999] group-[&.ps--clicking]/y:w-[11px] outline-none";
var addPerfectScrollbarStyles = (container = document) => {
  const classes = [
    { ps: "ps__rail-x", te: railXClasses },
    { ps: "ps__rail-y", te: railYClasses },
    { ps: "ps__thumb-x", te: railXThumbClasses },
    { ps: "ps__thumb-y", te: railYThumbClasses }
  ];
  classes.forEach((item) => {
    manipulator_default.addClass(
      selector_engine_default.findOne(`.${item.ps}`, container),
      item.te
    );
    manipulator_default.removeClass(
      selector_engine_default.findOne(`.${item.ps}`, container),
      item.ps
    );
  });
  manipulator_default.addClass(container, psClasses);
  manipulator_default.removeClass(container, "ps");
};
var add_perfect_scrollbar_styles_default = addPerfectScrollbarStyles;

// node_modules/tw-elements/dist/src/js/navigation/sidenav.js
var NAME19 = "sidenav";
var DATA_KEY18 = "te.sidenav";
var ARROW_DATA = "data-te-sidenav-rotate-icon-ref";
var SELECTOR_SIDENAV = "[data-te-sidenav-init]";
var SELECTOR_TOGGLE = "[data-te-sidenav-toggle-ref]";
var SELECTOR_TOGGLE_COLLAPSE = "[data-te-collapse-init]";
var SELECTOR_SHOW_SLIM = '[data-te-sidenav-slim="true"]';
var SELECTOR_HIDE_SLIM = '[data-te-sidenav-slim="false"]';
var SELECTOR_NAVIGATION = "[data-te-sidenav-menu-ref]";
var SELECTOR_COLLAPSE = "[data-te-sidenav-collapse-ref]";
var SELECTOR_LINK = "[data-te-sidenav-link-ref]";
var TRANSLATION_LEFT = isRTL() ? 100 : -100;
var TRANSLATION_RIGHT = isRTL() ? -100 : 100;
var OPTIONS_TYPE = {
  sidenavAccordion: "(boolean)",
  sidenavBackdrop: "(boolean)",
  sidenavBackdropClass: "(null|string)",
  sidenavCloseOnEsc: "(boolean)",
  sidenavColor: "(string)",
  sidenavContent: "(null|string)",
  sidenavExpandable: "(boolean)",
  sidenavExpandOnHover: "(boolean)",
  sidenavFocusTrap: "(boolean)",
  sidenavHidden: "(boolean)",
  sidenavMode: "(string)",
  sidenavModeBreakpointOver: "(null|string|number)",
  sidenavModeBreakpointSide: "(null|string|number)",
  sidenavModeBreakpointPush: "(null|string|number)",
  sidenavBreakpointSm: "(number)",
  sidenavBreakpointMd: "(number)",
  sidenavBreakpointLg: "(number)",
  sidenavBreakpointXl: "(number)",
  sidenavBreakpoint2xl: "(number)",
  sidenavScrollContainer: "(null|string)",
  sidenavSlim: "(boolean)",
  sidenavSlimCollapsed: "(boolean)",
  sidenavSlimWidth: "(number)",
  sidenavPosition: "(string)",
  sidenavRight: "(boolean)",
  sidenavTransitionDuration: "(number)",
  sidenavWidth: "(number)"
};
var DEFAULT_OPTIONS3 = {
  sidenavAccordion: false,
  sidenavBackdrop: true,
  sidenavBackdropClass: null,
  sidenavCloseOnEsc: true,
  sidenavColor: "primary",
  sidenavContent: null,
  sidenavExpandable: true,
  sidenavExpandOnHover: false,
  sidenavFocusTrap: true,
  sidenavHidden: true,
  sidenavMode: "over",
  sidenavModeBreakpointOver: null,
  sidenavModeBreakpointSide: null,
  sidenavModeBreakpointPush: null,
  sidenavBreakpointSm: 640,
  sidenavBreakpointMd: 768,
  sidenavBreakpointLg: 1024,
  sidenavBreakpointXl: 1280,
  sidenavBreakpoint2xl: 1536,
  sidenavScrollContainer: null,
  sidenavSlim: false,
  sidenavSlimCollapsed: false,
  sidenavSlimWidth: 77,
  sidenavPosition: "fixed",
  sidenavRight: false,
  sidenavTransitionDuration: 300,
  sidenavWidth: 240
};
var Sidenav = class {
  constructor(node, options = {}) {
    __publicField(this, "_addBackdropOnInit", () => {
      if (this._options.sidenavHidden) {
        return;
      }
      this._backdrop.show();
      event_handler_default.off(this._element, "transitionend", this._addBackdropOnInit);
    });
    this._element = node;
    this._options = options;
    this._ID = getUID("");
    this._content = null;
    this._initialContentStyle = null;
    this._slimCollapsed = false;
    this._activeNode = null;
    this._tempSlim = false;
    this._backdrop = this._initializeBackDrop();
    this._focusTrap = null;
    this._perfectScrollbar = null;
    this._touch = null;
    this._setModeFromBreakpoints();
    this.escHandler = (e) => {
      if (e.keyCode === ESCAPE && this.toggler && isVisible(this.toggler)) {
        this._update(false);
        event_handler_default.off(window, "keydown", this.escHandler);
      }
    };
    this.hashHandler = () => {
      this._setActiveElements();
    };
    if (node) {
      data_default.setData(node, DATA_KEY18, this);
      this._setup();
    }
    if (this.options.sidenavBackdrop && !this.options.sidenavHidden && this.options.sidenavMode === "over") {
      event_handler_default.on(this._element, "transitionend", this._addBackdropOnInit);
    }
  }
  // Getters
  static get NAME() {
    return NAME19;
  }
  get container() {
    if (this.options.sidenavPosition === "fixed") {
      return selector_engine_default.findOne("body");
    }
    const findContainer = (el) => {
      if (!el.parentNode || el.parentNode === document) {
        return el;
      }
      if (el.parentNode.style.position === "relative" || el.parentNode.classList.contains("relative")) {
        return el.parentNode;
      }
      return findContainer(el.parentNode);
    };
    return findContainer(this._element);
  }
  get isVisible() {
    let containerStart = 0;
    let containerEnd = window.innerWidth;
    if (this.options.sidenavPosition !== "fixed") {
      const boundry = this.container.getBoundingClientRect();
      containerStart = boundry.x;
      containerEnd = boundry.x + boundry.width;
    }
    const { x } = this._element.getBoundingClientRect();
    if (this.options.sidenavRight) {
      return Math.abs(x - containerEnd) > 10;
    }
    return Math.abs(x - containerStart) < 10;
  }
  get links() {
    return selector_engine_default.find(SELECTOR_LINK, this._element);
  }
  get navigation() {
    return selector_engine_default.find(SELECTOR_NAVIGATION, this._element);
  }
  get options() {
    const config = {
      ...DEFAULT_OPTIONS3,
      ...manipulator_default.getDataAttributes(this._element),
      ...this._options
    };
    typeCheckConfig(NAME19, config, OPTIONS_TYPE);
    return config;
  }
  get sidenavStyle() {
    return {
      width: `${this.width}px`,
      height: this.options.sidenavPosition === "fixed" ? "100vh" : "100%",
      position: this.options.sidenavPosition,
      transition: `all ${this.transitionDuration} linear`
    };
  }
  get toggler() {
    const toggleElement = selector_engine_default.find(SELECTOR_TOGGLE).find(
      (toggler) => {
        const target = manipulator_default.getDataAttribute(toggler, "target");
        return selector_engine_default.findOne(target) === this._element;
      }
    );
    return toggleElement;
  }
  get transitionDuration() {
    return `${this.options.sidenavTransitionDuration / 1e3}s`;
  }
  get translation() {
    return this.options.sidenavRight ? TRANSLATION_RIGHT : TRANSLATION_LEFT;
  }
  get width() {
    return this._slimCollapsed ? this.options.sidenavSlimWidth : this.options.sidenavWidth;
  }
  get isBackdropVisible() {
    return Boolean(this._backdrop._element);
  }
  // Public
  changeMode(mode) {
    this._setMode(mode);
  }
  dispose() {
    event_handler_default.off(window, "keydown", this.escHandler);
    this.options.sidenavBackdrop && this._backdrop.dispose();
    event_handler_default.off(window, "hashchange", this.hashHandler);
    this._touch.dispose();
    data_default.removeData(this._element, DATA_KEY18);
    this._element = null;
  }
  hide() {
    this._emitEvents(false);
    this._update(false);
    this._options.sidenavBackdrop && this.isBackdropVisible && this._backdrop.hide();
  }
  show() {
    this._emitEvents(true);
    this._update(true);
    this._options.sidenavBackdrop && this._options.sidenavMode === "over" && this._backdrop.show();
  }
  toggle() {
    this._emitEvents(!this.isVisible);
    this._update(!this.isVisible);
  }
  toggleSlim() {
    this._setSlim(!this._slimCollapsed);
  }
  update(options) {
    this._options = options;
    this._setup();
  }
  getBreakpoint(prefix) {
    return this._transformBreakpointValuesToObject()[prefix];
  }
  // Private
  _transformBreakpointValuesToObject() {
    return {
      sm: this.options.sidenavBreakpointSm,
      md: this.options.sidenavBreakpointMd,
      lg: this.options.sidenavBreakpointLg,
      xl: this.options.sidenavBreakpointXl,
      "2xl": this.options.sidenavBreakpoint2xl
    };
  }
  _setModeFromBreakpoints() {
    const innerWidth = window.innerWidth;
    const breakpointsList = this._transformBreakpointValuesToObject();
    if (innerWidth === void 0 || !breakpointsList) {
      return;
    }
    const overCalculated = typeof this.options.sidenavModeBreakpointOver === "number" ? innerWidth - this.options.sidenavModeBreakpointOver : innerWidth - breakpointsList[this.options.sidenavModeBreakpointOver];
    const sideCalculated = typeof this.options.sidenavModeBreakpointSide === "number" ? innerWidth - this.options.sidenavModeBreakpointSide : innerWidth - breakpointsList[this.options.sidenavModeBreakpointSide];
    const pushCalculated = typeof this.options.sidenavModeBreakpointPush === "number" ? innerWidth - this.options.sidenavModeBreakpointPush : innerWidth - breakpointsList[this.options.sidenavModeBreakpointPush];
    const sortAsc = (a, b) => {
      if (a - b < 0)
        return -1;
      if (b - a < 0)
        return 1;
      return 0;
    };
    const closestPositive = [overCalculated, sideCalculated, pushCalculated].filter((value) => value != null && value >= 0).sort(sortAsc)[0];
    if (overCalculated > 0 && overCalculated === closestPositive) {
      this._options.sidenavMode = "over";
      this._options.sidenavHidden = true;
    } else if (sideCalculated > 0 && sideCalculated === closestPositive) {
      this._options.sidenavMode = "side";
    } else if (pushCalculated > 0 && pushCalculated === closestPositive) {
      this._options.sidenavMode = "push";
    }
  }
  _collapseItems() {
    this.navigation.forEach((menu) => {
      const collapseElements = selector_engine_default.find(SELECTOR_COLLAPSE, menu);
      collapseElements.forEach((el) => {
        collapse_default.getInstance(el).hide();
      });
    });
  }
  _getOffsetValue(show, { index, property, offsets }) {
    const initialValue = this._getPxValue(
      this._initialContentStyle[index][offsets[property].property]
    );
    const offset2 = show ? offsets[property].value : 0;
    return initialValue + offset2;
  }
  _getProperty(...args) {
    return args.map((arg, i) => {
      if (i === 0) {
        return arg;
      }
      return arg[0].toUpperCase().concat(arg.slice(1));
    }).join("");
  }
  _getPxValue(property) {
    if (!property) {
      return 0;
    }
    return parseFloat(property);
  }
  _handleSwipe(e, inverseDirecion) {
    if (inverseDirecion && this._slimCollapsed && this.options.sidenavSlim && this.options.sidenavExpandable) {
      this.toggleSlim();
    } else if (!inverseDirecion) {
      if (this._slimCollapsed || !this.options.sidenavSlim || !this.options.sidenavExpandable) {
        if (this.toggler && isVisible(this.toggler)) {
          this.toggle();
        }
      } else {
        this.toggleSlim();
      }
    }
  }
  _isActive(link, reference2) {
    if (reference2) {
      return reference2 === link;
    }
    if (link.attributes.href) {
      return new URL(link, window.location.href).href === window.location.href;
    }
    return false;
  }
  _isAllToBeCollapsed() {
    const collapseElements = selector_engine_default.find(
      SELECTOR_TOGGLE_COLLAPSE,
      this._element
    );
    const collapseElementsExpanded = collapseElements.filter(
      (collapsible) => collapsible.getAttribute("aria-expanded") === "true"
    );
    return collapseElementsExpanded.length === 0;
  }
  _isAllCollapsed() {
    return selector_engine_default.find(SELECTOR_COLLAPSE, this._element).filter(
      (el) => isVisible(el)
    ).length === 0;
  }
  _initializeBackDrop() {
    if (!this.options.sidenavBackdrop) {
      return;
    }
    const backdropClasses = this.options.sidenavBackdropClass ? this.options.sidenavBackdropClass.split(" ") : this.options.sidenavPosition ? [
      "opacity-50",
      "transition-all",
      "duration-300",
      "ease-in-out",
      this.options.sidenavPosition,
      "top-0",
      "left-0",
      "z-50",
      "bg-black/10",
      "dark:bg-black-60",
      "w-full",
      "h-full",
      this._element.id
    ] : null;
    return new backdrop_default({
      isVisible: this.options.sidenavBackdrop,
      isAnimated: true,
      rootElement: this._element.parentNode,
      backdropClasses,
      clickCallback: () => this.hide()
    });
  }
  _updateBackdrop(show) {
    if (this.options.sidenavMode === "over") {
      show ? this._backdrop.show() : this.isBackdropVisible && this._backdrop.hide();
      return;
    }
    this.isBackdropVisible && this._backdrop.hide();
  }
  _setup() {
    this._setupTouch();
    if (this.options.sidenavFocusTrap) {
      this._setupFocusTrap();
    }
    this._setupCollapse();
    if (this.options.sidenavSlim) {
      this._setupSlim();
    }
    this._setupInitialStyling();
    this._setupScrolling();
    if (this.options.sidenavContent) {
      this._setupContent();
    }
    this._setupActiveState();
    this._setupRippleEffect();
    if (!this.options.sidenavHidden) {
      this._updateOffsets(true, true);
    }
    if (this.options.sidenavMode === "over") {
      this._setTabindex(true);
    }
  }
  _setupActiveState() {
    this._setActiveElements();
    this.links.forEach((link) => {
      event_handler_default.on(link, "click", () => this._setActiveElements(link));
      event_handler_default.on(link, "keydown", (e) => {
        if (e.keyCode === ENTER) {
          this._setActiveElements(link);
        }
      });
    });
    event_handler_default.on(window, "hashchange", this.hashHandler);
  }
  _setupCollapse() {
    this.navigation.forEach((menu, menuIndex) => {
      const categories = selector_engine_default.find(SELECTOR_COLLAPSE, menu);
      categories.forEach(
        (list, index) => this._setupCollapseList({ list, index, menu, menuIndex })
      );
    });
  }
  _generateCollpaseID(index, menuIndex) {
    return `sidenav-collapse-${this._ID}-${menuIndex}-${index}`;
  }
  _setupCollapseList({ list, index, menu, menuIndex }) {
    const ID = this._generateCollpaseID(index, menuIndex);
    list.setAttribute("id", ID);
    list.setAttribute("data-te-collapse-item", "");
    const [toggler] = selector_engine_default.prev(list, SELECTOR_LINK);
    manipulator_default.setDataAttribute(toggler, "collapse-init", "");
    toggler.setAttribute("href", `#${ID}`);
    toggler.setAttribute("role", "button");
    const instance = collapse_default.getInstance(list) || new collapse_default(list, {
      toggle: false,
      parent: this.options.sidenavAccordion ? menu : list
    });
    if (list.dataset.teSidenavStateShow === "" || list.dataset.teCollapseShow === "") {
      this._rotateArrow(toggler, false);
    }
    event_handler_default.on(toggler, "click", (e) => {
      this._toggleCategory(e, instance, list);
      if (this._tempSlim && this._isAllToBeCollapsed()) {
        this._setSlim(true);
        this._tempSlim = false;
      }
      if (this.options.sidenavMode === "over" && this._focusTrap) {
        this._focusTrap.update();
      }
    });
    event_handler_default.on(
      list,
      "show.te.collapse",
      () => this._rotateArrow(toggler, false)
    );
    event_handler_default.on(
      list,
      "hide.te.collapse",
      () => this._rotateArrow(toggler, true)
    );
    event_handler_default.on(list, "shown.te.collapse", () => {
      if (this.options.sidenavMode === "over" && this._focusTrap) {
        this._focusTrap.update();
      }
    });
    event_handler_default.on(list, "hidden.te.collapse", () => {
      if (this._tempSlim && this._isAllCollapsed()) {
        this._setSlim(true);
        this._tempSlim = false;
      }
      if (this.options.sidenavMode === "over" && this._focusTrap) {
        this._focusTrap.update();
      }
    });
  }
  _setupContent() {
    this._content = selector_engine_default.find(this.options.sidenavContent);
    this._content.forEach((el) => {
      const searchFor = [
        "!p",
        "!m",
        "!px",
        "!pl",
        "!pr",
        "!mx",
        "!ml",
        "!mr",
        "!-p",
        "!-m",
        "!-px",
        "!-pl",
        "!-pr",
        "!-mx",
        "!-ml",
        "!-mr"
      ];
      const classesToRemove = [...el.classList].filter(
        (singleClass) => searchFor.findIndex((el2) => singleClass.includes(el2)) >= 0
      );
      classesToRemove.forEach((remove2) => el.classList.remove(remove2));
    });
    this._initialContentStyle = this._content.map((el) => {
      const { paddingLeft, paddingRight, marginLeft, marginRight, transition } = window.getComputedStyle(el);
      return { paddingLeft, paddingRight, marginLeft, marginRight, transition };
    });
  }
  _setupFocusTrap() {
    this._focusTrap = new focusTrap_default(
      this._element,
      {
        event: "keydown",
        condition: (e) => e.keyCode === TAB,
        onlyVisible: true
      },
      this.toggler
    );
  }
  _setupInitialStyling() {
    this._setColor();
    manipulator_default.style(this._element, this.sidenavStyle);
  }
  _setupScrolling() {
    let container = this._element;
    if (this.options.sidenavScrollContainer) {
      container = selector_engine_default.findOne(
        this.options.sidenavScrollContainer,
        this._element
      );
      const siblings = array(container.parentNode.children).filter(
        (el) => el !== container
      );
      const siblingsHeight = siblings.reduce((a, b) => {
        return a + b.clientHeight;
      }, 0);
      manipulator_default.style(container, {
        maxHeight: `calc(100% - ${siblingsHeight}px)`,
        position: "relative"
      });
    }
    this._perfectScrollbar = new perfect_scrollbar_esm_default(container, {
      suppressScrollX: true,
      handlers: ["click-rail", "drag-thumb", "wheel", "touch"]
    });
    add_perfect_scrollbar_styles_default(container);
  }
  _setupSlim() {
    this._slimCollapsed = this.options.sidenavSlimCollapsed;
    this._toggleSlimDisplay(this._slimCollapsed);
    if (this.options.sidenavExpandOnHover) {
      this._element.addEventListener("mouseenter", () => {
        if (this._slimCollapsed) {
          this._setSlim(false);
        }
      });
      this._element.addEventListener("mouseleave", () => {
        if (!this._slimCollapsed) {
          this._setSlim(true);
        }
      });
    }
  }
  _setupRippleEffect() {
    this.links.forEach((link) => {
      let wave = ripple_default.getInstance(link);
      let color = this.options.sidenavColor;
      if (wave && wave._options.sidenavColor !== this.options.sidenavColor) {
        wave.dispose();
      } else if (wave) {
        return;
      }
      if (localStorage.theme === "dark" || !("theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) {
        color = "white";
      }
      wave = new ripple_default(link, { rippleColor: color });
    });
  }
  _setupTouch() {
    this._touch = new touch_default(this._element, "swipe", { threshold: 20 });
    this._touch.init();
    event_handler_default.on(
      this._element,
      "swipeleft",
      (e) => this._handleSwipe(e, this.options.sidenavRight)
    );
    event_handler_default.on(
      this._element,
      "swiperight",
      (e) => this._handleSwipe(e, !this.options.sidenavRight)
    );
  }
  _setActive(link, reference2) {
    link.setAttribute("data-te-sidebar-state-active", "");
    if (this._activeNode) {
      link.removeAttribute("data-te-sidebar-state-active");
    }
    this._activeNode = link;
    const [collapse] = selector_engine_default.parents(
      this._activeNode,
      SELECTOR_COLLAPSE
    );
    if (!collapse) {
      this._setActiveCategory();
      return;
    }
    const [category] = selector_engine_default.prev(collapse, SELECTOR_LINK);
    this._setActiveCategory(category);
    if (!reference2 && !this._slimCollapsed) {
      collapse_default.getInstance(collapse).show();
    }
  }
  _setActiveCategory(el) {
    this.navigation.forEach((menu) => {
      const categories = selector_engine_default.find(SELECTOR_COLLAPSE, menu);
      categories.forEach((collapse) => {
        const [collapseToggler] = selector_engine_default.prev(collapse, SELECTOR_LINK);
        if (collapseToggler !== el) {
          collapseToggler.removeAttribute("data-te-sidenav-state-active");
        } else {
          collapseToggler.setAttribute("data-te-sidenav-state-active", "");
        }
      });
    });
  }
  _setActiveElements(reference2) {
    this.navigation.forEach((menu) => {
      const links = selector_engine_default.find(SELECTOR_LINK, menu);
      links.filter((link) => {
        return selector_engine_default.next(link, SELECTOR_COLLAPSE).length === 0;
      }).forEach((link) => {
        if (this._isActive(link, reference2) && link !== this._activeNode) {
          this._setActive(link, reference2);
        }
      });
    });
    reference2 && this._updateFocus(this.isVisible);
  }
  _setColor() {
    const colors = [
      "primary",
      "secondary",
      "success",
      "info",
      "warning",
      "danger",
      "light",
      "dark"
    ];
    const { sidenavColor: optionColor } = this.options;
    const color = colors.includes(optionColor) ? optionColor : "primary";
    colors.forEach((color2) => {
      this._element.classList.remove(`sidenav-${color2}`);
    });
    manipulator_default.addClass(this._element, `sidenav-${color}`);
  }
  _setContentOffsets(show, offsets, initial) {
    this._content.forEach((el, i) => {
      const padding = this._getOffsetValue(show, {
        index: i,
        property: "padding",
        offsets
      });
      const margin = this._getOffsetValue(show, {
        index: i,
        property: "margin",
        offsets
      });
      const style = {};
      if (!initial) {
        style.transition = `all ${this.transitionDuration} linear`;
      }
      style[offsets.padding.property] = `${padding}px`;
      style[offsets.margin.property] = `${margin}px`;
      manipulator_default.style(el, style);
      if (!show) {
        return;
      }
      if (initial) {
        manipulator_default.style(el, {
          transition: this._initialContentStyle[i].transition
        });
        return;
      }
      event_handler_default.on(el, "transitionend", () => {
        manipulator_default.style(el, {
          transition: this._initialContentStyle[i].transition
        });
      });
    });
  }
  _setMode(mode) {
    if (this.options.sidenavMode === mode) {
      return;
    }
    this._options.sidenavMode = mode;
    this._update(this.isVisible);
  }
  _setSlim(isSlimCollapsed) {
    const events = isSlimCollapsed ? ["collapse", "collapsed"] : ["expand", "expanded"];
    this._triggerEvents(...events);
    if (isSlimCollapsed) {
      this._collapseItems();
    }
    this._slimCollapsed = isSlimCollapsed;
    this._toggleSlimDisplay(isSlimCollapsed);
    manipulator_default.style(this._element, { width: `${this.width}px` });
    this._updateOffsets(this.isVisible);
  }
  _setTabindex(tabIndexValue) {
    this.links.forEach((link) => {
      link.tabIndex = tabIndexValue ? 0 : -1;
    });
  }
  _emitEvents(show) {
    const events = show ? ["show", "shown"] : ["hide", "hidden"];
    this._triggerEvents(...events);
  }
  _rotateArrow(toggler, collapsed) {
    const [arrow2] = selector_engine_default.children(toggler, `[${ARROW_DATA}]`);
    if (!arrow2) {
      return;
    }
    collapsed ? manipulator_default.removeClass(arrow2, "rotate-180") : manipulator_default.addClass(arrow2, "rotate-180");
  }
  _toggleCategory(e, instance) {
    e.preventDefault();
    instance.toggle();
    if (this._slimCollapsed && this.options.sidenavExpandable) {
      this._tempSlim = true;
      this._setSlim(false);
    }
  }
  _toggleSlimDisplay(slim) {
    const slimCollapsedElements = selector_engine_default.find(
      SELECTOR_SHOW_SLIM,
      this._element
    );
    const fullWidthElements = selector_engine_default.find(
      SELECTOR_HIDE_SLIM,
      this._element
    );
    const toggleElements = () => {
      slimCollapsedElements.forEach((el) => {
        manipulator_default.style(el, {
          display: this._slimCollapsed ? "unset" : "none"
        });
      });
      fullWidthElements.forEach((el) => {
        manipulator_default.style(el, {
          display: this._slimCollapsed ? "none" : "unset"
        });
      });
    };
    if (slim) {
      setTimeout(
        () => toggleElements(true),
        this.options.sidenavTransitionDuration
      );
    } else {
      toggleElements();
    }
  }
  async _triggerEvents(startEvent, completeEvent) {
    event_handler_default.trigger(this._element, `${startEvent}.te.sidenav`);
    if (completeEvent) {
      await setTimeout(() => {
        event_handler_default.trigger(this._element, `${completeEvent}.te.sidenav`);
      }, this.options.sidenavTransitionDuration + 5);
    }
  }
  _update(show) {
    if (this.toggler) {
      this._updateTogglerAria(show);
    }
    this._updateDisplay(show);
    if (this.options.sidenavBackdrop) {
      this._updateBackdrop(show);
    }
    this._updateOffsets(show);
    if (show && this.options.sidenavCloseOnEsc && this.options.sidenavMode !== "side") {
      event_handler_default.on(window, "keydown", this.escHandler);
    }
    if (this.options.sidenavFocusTrap) {
      this._updateFocus(show);
    }
  }
  _updateDisplay(show) {
    const translation = show ? 0 : this.translation;
    manipulator_default.style(this._element, {
      transform: `translateX(${translation}%)`
    });
  }
  _updateFocus(show) {
    this._setTabindex(show);
    if (this.options.sidenavMode === "over" && this.options.sidenavFocusTrap) {
      if (show) {
        this._focusTrap.trap();
        return;
      }
      this._focusTrap.disable();
    }
    this._focusTrap.disable();
  }
  _updateOffsets(show, initial = false) {
    const [paddingPosition, marginPosition] = this.options.sidenavRight ? ["right", "left"] : ["left", "right"];
    const padding = {
      property: this._getProperty("padding", paddingPosition),
      value: this.options.sidenavMode === "over" ? 0 : this.width
    };
    const margin = {
      property: this._getProperty("margin", marginPosition),
      value: this.options.sidenavMode === "push" ? -1 * this.width : 0
    };
    event_handler_default.trigger(this._element, "update.te.sidenav", {
      margin,
      padding
    });
    if (!this._content) {
      return;
    }
    this._content.className = "";
    this._setContentOffsets(show, { padding, margin }, initial);
  }
  _updateTogglerAria(show) {
    this.toggler.setAttribute("aria-expanded", show);
  }
  // Static
  static toggleSidenav() {
    return function(e) {
      const toggler = selector_engine_default.closest(e.target, SELECTOR_TOGGLE);
      const elementSelector = manipulator_default.getDataAttributes(toggler).target;
      selector_engine_default.find(elementSelector).forEach((element2) => {
        const instance = Sidenav.getInstance(element2) || new Sidenav(element2);
        instance.toggle();
      });
    };
  }
  static jQueryInterface(config, options) {
    return this.each(function() {
      let data = data_default.getData(this, DATA_KEY18);
      const _config = typeof config === "object" && config;
      if (!data && /dispose/.test(config)) {
        return;
      }
      if (!data) {
        data = new Sidenav(this, _config);
      }
      if (typeof config === "string") {
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](options);
      }
    });
  }
  static getInstance(element2) {
    return data_default.getData(element2, DATA_KEY18);
  }
  static getOrCreateInstance(element2, config = {}) {
    return this.getInstance(element2) || new this(element2, typeof config === "object" ? config : null);
  }
};
event_handler_default.on(document, "click", SELECTOR_TOGGLE, Sidenav.toggleSidenav());
selector_engine_default.find(SELECTOR_SIDENAV).forEach((sidenav) => {
  let instance = Sidenav.getInstance(sidenav);
  if (!instance) {
    instance = new Sidenav(sidenav);
  }
  return instance;
});
onDOMContentLoaded(() => {
  const $2 = getjQuery();
  if ($2) {
    const JQUERY_NO_CONFLICT = $2.fn[NAME19];
    $2.fn[NAME19] = Sidenav.jQueryInterface;
    $2.fn[NAME19].Constructor = Sidenav;
    $2.fn[NAME19].noConflict = () => {
      $2.fn[NAME19] = JQUERY_NO_CONFLICT;
      return Sidenav.jQueryInterface;
    };
  }
});
var sidenav_default = Sidenav;

// node_modules/tw-elements/dist/src/js/components/stepper.js
var NAME20 = "stepper";
var DATA_KEY19 = "te.stepper";
var EVENT_KEY15 = `.${DATA_KEY19}`;
var REF = `data-te-${NAME20}`;
var SELECTOR_EXPAND2 = `[${REF}-init]`;
var STEPPER_HORIZONTAL = "horizontal";
var STEPPER_VERTICAL = "vertical";
var DefaultType17 = {
  stepperType: "string",
  stepperLinear: "boolean",
  stepperNoEditable: "boolean",
  stepperActive: "string",
  stepperCompleted: "string",
  stepperInvalid: "string",
  stepperDisabled: "string",
  stepperVerticalBreakpoint: "number",
  stepperMobileBreakpoint: "number",
  stepperMobileBarBreakpoint: "number"
};
var Default17 = {
  stepperType: STEPPER_HORIZONTAL,
  stepperLinear: false,
  stepperNoEditable: false,
  stepperActive: "",
  stepperCompleted: "",
  stepperInvalid: "",
  stepperDisabled: "",
  stepperVerticalBreakpoint: 0,
  stepperMobileBreakpoint: 0,
  stepperMobileBarBreakpoint: 4
};
var EVENT_MOUSEDOWN2 = `mousedown${EVENT_KEY15}`;
var EVENT_KEYDOWN2 = `keydown${EVENT_KEY15}`;
var EVENT_KEYUP = `keyup${EVENT_KEY15}`;
var EVENT_RESIZE2 = `resize${EVENT_KEY15}`;
var STEP_REF = `[${REF}-step-ref]`;
var HEAD_REF = `[${REF}-head-ref]`;
var HEAD_TEXT_REF = `[${REF}-head-text-ref]`;
var HEAD_ICON_REF = `[${REF}-head-icon-ref]`;
var CONTENT_REF = `[${REF}-content-ref]`;
var Stepper = class {
  constructor(element2, options) {
    this._element = element2;
    this._options = this._getConfig(options);
    this._elementHeight = 0;
    this._steps = selector_engine_default.find(`${STEP_REF}`, this._element);
    this._currentView = "";
    this._activeStepIndex = 0;
    this._verticalStepperStyles = [];
    if (this._element) {
      data_default.setData(element2, DATA_KEY19, this);
      this._init();
    }
  }
  // Getters
  static get NAME() {
    return NAME20;
  }
  get activeStep() {
    return this._steps[this._activeStepIndex];
  }
  get activeStepIndex() {
    return this._activeStepIndex;
  }
  // Public
  dispose() {
    this._steps.forEach((el) => {
      event_handler_default.off(el, EVENT_MOUSEDOWN2);
      event_handler_default.off(el, EVENT_KEYDOWN2);
    });
    event_handler_default.off(window, EVENT_RESIZE2);
    data_default.removeData(this._element, DATA_KEY19);
    this._element = null;
  }
  changeStep(index) {
    this._toggleStep(index);
  }
  nextStep() {
    this._toggleStep(this._activeStepIndex + 1);
  }
  previousStep() {
    this._toggleStep(this._activeStepIndex - 1);
  }
  // Private
  _init() {
    const activeStep = selector_engine_default.find(`${STEP_REF}`, this._element)[this._activeStepIndex].setAttribute("data-te", "active-step");
    const stepperHeadText = selector_engine_default.find(
      `${HEAD_TEXT_REF}`,
      this._element
    );
    const stepperHeadIcon = selector_engine_default.find(
      `${HEAD_ICON_REF}`,
      this._element
    );
    if (activeStep) {
      this._activeStepIndex = this._steps.indexOf(activeStep);
      this._toggleStepClass(
        this._activeStepIndex,
        "add",
        this._options.stepperActive
      );
      stepperHeadText[this._activeStepIndex].classList.add("font-medium");
      stepperHeadIcon[this._activeStepIndex].classList.add("!bg-primary-100");
      stepperHeadIcon[this._activeStepIndex].classList.add("!text-primary-700");
    } else {
      stepperHeadText[this._activeStepIndex].classList.add("font-medium");
      stepperHeadIcon[this._activeStepIndex].classList.add("!bg-primary-100");
      stepperHeadIcon[this._activeStepIndex].classList.add("!text-primary-700");
      this._toggleStepClass(
        this._activeStepIndex,
        "add",
        this._options.stepperActive
      );
    }
    this._bindMouseDown();
    this._bindKeysNavigation();
    switch (this._options.stepperType) {
      case STEPPER_VERTICAL:
        this._toggleVertical();
        break;
      default:
        this._toggleHorizontal();
        break;
    }
    if (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) {
      this._toggleStepperView();
    }
    this._bindResize();
  }
  _getConfig(config) {
    const dataAttributes = manipulator_default.getDataAttributes(this._element);
    config = {
      ...Default17,
      ...dataAttributes,
      ...config
    };
    typeCheckConfig(NAME20, config, DefaultType17);
    return config;
  }
  _bindMouseDown() {
    this._steps.forEach((el) => {
      const stepHead = selector_engine_default.findOne(`${HEAD_REF}`, el);
      event_handler_default.on(stepHead, EVENT_MOUSEDOWN2, (e) => {
        const step = selector_engine_default.parents(e.target, `${STEP_REF}`)[0];
        const stepIndex = this._steps.indexOf(step);
        e.preventDefault();
        this._toggleStep(stepIndex);
      });
    });
  }
  _bindResize() {
    event_handler_default.on(window, EVENT_RESIZE2, () => {
      if (this._currentView === STEPPER_VERTICAL) {
        this._setSingleStepHeight(this.activeStep);
      }
      if (this._currentView === STEPPER_HORIZONTAL) {
        this._setHeight(this.activeStep);
      }
      if (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) {
        this._toggleStepperView();
      }
    });
  }
  _toggleStepperView() {
    const shouldBeHorizontal = this._options.stepperVerticalBreakpoint < window.innerWidth;
    const shouldBeVertical = this._options.stepperVerticalBreakpoint > window.innerWidth;
    const shouldBeMobile = this._options.stepperMobileBreakpoint > window.innerWidth;
    if (shouldBeHorizontal && this._currentView !== STEPPER_HORIZONTAL) {
      this._toggleHorizontal();
    }
    if (shouldBeVertical && !shouldBeMobile && this._currentView !== STEPPER_VERTICAL) {
      this._steps.forEach((el) => {
        const stepContent = selector_engine_default.findOne(`${CONTENT_REF}`, el);
        this._resetStepperHeight();
        this._showElement(stepContent);
      });
      this._toggleVertical();
    }
  }
  _toggleStep(index) {
    if (this._activeStepIndex === index) {
      return;
    }
    if (this._options.stepperNoEditable) {
      this._toggleDisabled();
    }
    this._showElement(
      selector_engine_default.findOne(`${CONTENT_REF}`, this._steps[index])
    );
    this._toggleActive(index);
    if (index > this._activeStepIndex) {
      this._toggleCompleted(this._activeStepIndex);
    }
    if (this._currentView === STEPPER_HORIZONTAL) {
      this._animateHorizontalStep(index);
    } else {
      this._animateVerticalStep(index);
      this._setSingleStepHeight(this._steps[index]);
    }
    this._toggleStepTabIndex(
      selector_engine_default.findOne(`${HEAD_REF}`, this.activeStep),
      selector_engine_default.findOne(`${HEAD_REF}`, this._steps[index])
    );
    this._activeStepIndex = index;
    this._steps[this._activeStepIndex].setAttribute("data-te", "active-step");
    this._steps.forEach((step, index2) => {
      if (step[this._activeStepIndex] !== index2) {
        step.removeAttribute("data-te");
      }
    });
  }
  _resetStepperHeight() {
    this._element.style.height = "";
  }
  _setStepsHeight() {
    this._steps.forEach((el) => {
      const stepContent = selector_engine_default.findOne(`${CONTENT_REF}`, el);
      const stepComputed = window.getComputedStyle(stepContent);
      this._verticalStepperStyles.push({
        paddingTop: parseFloat(stepComputed.paddingTop),
        paddingBottom: parseFloat(stepComputed.paddingBottom)
      });
      const stepHeight = stepContent.scrollHeight;
      stepContent.style.height = `${stepHeight}px`;
    });
  }
  _setSingleStepHeight(step) {
    const stepContent = selector_engine_default.findOne(`${CONTENT_REF}`, step);
    const isActiveStep = this.activeStep === step;
    const stepIndex = this._steps.indexOf(step);
    let stepContentHeight;
    if (!isActiveStep) {
      stepContentHeight = stepContent.scrollHeight + this._verticalStepperStyles[stepIndex].paddingTop + this._verticalStepperStyles[stepIndex].paddingBottom;
    } else {
      stepContent.style.height = "";
      stepContentHeight = stepContent.scrollHeight;
    }
    stepContent.style.height = `${stepContentHeight}px`;
  }
  _toggleVertical() {
    this._currentView = STEPPER_VERTICAL;
    this._setStepsHeight();
    this._hideInactiveSteps();
  }
  _toggleHorizontal() {
    this._currentView = STEPPER_HORIZONTAL;
    this._setHeight(this.activeStep);
    this._hideInactiveSteps();
  }
  _toggleStepperClass() {
    const vertical = selector_engine_default.findOne(
      "[data-te-stepper-type]",
      this._element
    );
    if (vertical !== null) {
      this._steps.forEach((el) => {
        selector_engine_default.findOne(`${CONTENT_REF}`, el).classList.remove("!my-0");
        selector_engine_default.findOne(`${CONTENT_REF}`, el).classList.remove("!py-0");
        selector_engine_default.findOne(`${CONTENT_REF}`, el).classList.remove("!h-0");
      });
    }
  }
  _toggleStepClass(index, action, className) {
    if (className) {
      this._steps[index].classList[action](className);
    }
  }
  _bindKeysNavigation() {
    this._toggleStepTabIndex(
      false,
      selector_engine_default.findOne(`${HEAD_REF}`, this.activeStep)
    );
    this._steps.forEach((el) => {
      const stepHead = selector_engine_default.findOne(`${HEAD_REF}`, el);
      event_handler_default.on(stepHead, EVENT_KEYDOWN2, (e) => {
        const focusedStep = selector_engine_default.parents(
          e.currentTarget,
          `${STEP_REF}`
        )[0];
        const nextStep = selector_engine_default.next(focusedStep, `${STEP_REF}`)[0];
        const prevStep = selector_engine_default.prev(focusedStep, `${STEP_REF}`)[0];
        const focusedStepHead = selector_engine_default.findOne(
          `${HEAD_REF}`,
          focusedStep
        );
        const activeStepHead = selector_engine_default.findOne(
          `${HEAD_REF}`,
          this.activeStep
        );
        let nextStepHead = null;
        let prevStepHead = null;
        if (nextStep) {
          nextStepHead = selector_engine_default.findOne(`${HEAD_REF}`, nextStep);
        }
        if (prevStep) {
          prevStepHead = selector_engine_default.findOne(`${HEAD_REF}`, prevStep);
        }
        if (e.keyCode === LEFT_ARROW && this._currentView !== STEPPER_VERTICAL) {
          if (prevStepHead) {
            this._toggleStepTabIndex(focusedStepHead, prevStepHead);
            this._toggleOutlineStyles(focusedStepHead, prevStepHead);
            prevStepHead.focus();
          } else if (nextStepHead) {
            this._toggleStepTabIndex(focusedStepHead, nextStepHead);
            this._toggleOutlineStyles(focusedStepHead, nextStepHead);
            nextStepHead.focus();
          }
        }
        if (e.keyCode === RIGHT_ARROW && this._currentView !== STEPPER_VERTICAL) {
          if (nextStepHead) {
            this._toggleStepTabIndex(focusedStepHead, nextStepHead);
            this._toggleOutlineStyles(focusedStepHead, nextStepHead);
            nextStepHead.focus();
          } else if (prevStepHead) {
            this._toggleStepTabIndex(focusedStepHead, prevStepHead);
            this._toggleOutlineStyles(focusedStepHead, prevStepHead);
            prevStepHead.focus();
          }
        }
        if (e.keyCode === DOWN_ARROW && this._currentView === STEPPER_VERTICAL) {
          e.preventDefault();
          if (nextStepHead) {
            this._toggleStepTabIndex(focusedStepHead, nextStepHead);
            this._toggleOutlineStyles(focusedStepHead, nextStepHead);
            nextStepHead.focus();
          }
        }
        if (e.keyCode === UP_ARROW && this._currentView === STEPPER_VERTICAL) {
          e.preventDefault();
          if (prevStepHead) {
            this._toggleStepTabIndex(focusedStepHead, prevStepHead);
            this._toggleOutlineStyles(focusedStepHead, prevStepHead);
            prevStepHead.focus();
          }
        }
        if (e.keyCode === HOME) {
          const firstStepHead = selector_engine_default.findOne(
            `${HEAD_REF}`,
            this._steps[0]
          );
          this._toggleStepTabIndex(focusedStepHead, firstStepHead);
          this._toggleOutlineStyles(focusedStepHead, firstStepHead);
          firstStepHead.focus();
        }
        if (e.keyCode === END) {
          const lastStep = this._steps[this._steps.length - 1];
          const lastStepHead = selector_engine_default.findOne(`${HEAD_REF}`, lastStep);
          this._toggleStepTabIndex(focusedStepHead, lastStepHead);
          this._toggleOutlineStyles(focusedStepHead, lastStepHead);
          lastStepHead.focus();
        }
        if (e.keyCode === ENTER || e.keyCode === SPACE) {
          e.preventDefault();
          this.changeStep(this._steps.indexOf(focusedStep));
        }
        if (e.keyCode === TAB) {
          this._toggleStepTabIndex(focusedStepHead, activeStepHead);
          this._toggleOutlineStyles(focusedStepHead, false);
          activeStepHead.focus();
        }
      });
      event_handler_default.on(stepHead, EVENT_KEYUP, (e) => {
        const focusedStep = selector_engine_default.parents(
          e.currentTarget,
          `${STEP_REF}`
        )[0];
        const focusedStepHead = selector_engine_default.findOne(
          `${HEAD_REF}`,
          focusedStep
        );
        const activeStepHead = selector_engine_default.findOne(
          `${HEAD_REF}`,
          this.activeStep
        );
        if (e.keyCode === TAB) {
          this._toggleStepTabIndex(focusedStepHead, activeStepHead);
          this._toggleOutlineStyles(false, activeStepHead);
          activeStepHead.focus();
        }
      });
    });
  }
  _toggleStepTabIndex(focusedElement, newTarget) {
    if (focusedElement) {
      focusedElement.setAttribute("tabIndex", -1);
    }
    if (newTarget) {
      newTarget.setAttribute("tabIndex", 0);
    }
  }
  _toggleOutlineStyles(focusedElement, newTarget) {
    if (focusedElement) {
      focusedElement.style.outline = "";
    }
    if (newTarget) {
      newTarget.style.outline = "revert";
    }
  }
  _toggleDisabled() {
    const stepperHead = selector_engine_default.find(`${HEAD_REF}`, this._element);
    const stepperHeadIcon = selector_engine_default.find(
      `${HEAD_ICON_REF}`,
      this._element
    );
    stepperHead[this._activeStepIndex].classList.add("color-[#858585]");
    stepperHead[this._activeStepIndex].classList.add("cursor-default");
    stepperHeadIcon[this._activeStepIndex].classList.add("!bg-[#858585]");
    this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperDisabled
    );
  }
  _toggleActive(index) {
    const stepperHeadText = selector_engine_default.find(
      `${HEAD_TEXT_REF}`,
      this._element
    );
    const stepperHeadIcon = selector_engine_default.find(
      `${HEAD_ICON_REF}`,
      this._element
    );
    stepperHeadText[index].classList.add("font-medium");
    stepperHeadIcon[index].classList.add("!bg-primary-100");
    stepperHeadIcon[index].classList.add("!text-primary-700");
    stepperHeadIcon[index].classList.remove("!bg-success-100");
    stepperHeadIcon[index].classList.remove("!text-success-700");
    stepperHeadText[this._activeStepIndex].classList.remove("font-medium");
    stepperHeadIcon[this._activeStepIndex].classList.remove("!bg-primary-100");
    stepperHeadIcon[this._activeStepIndex].classList.remove(
      "!text-primary-700"
    );
    this._toggleStepClass(index, "add", this._options.stepperActive);
    this._toggleStepClass(
      this._activeStepIndex,
      "remove",
      this._options.stepperActive
    );
  }
  _toggleCompleted(index) {
    const stepperHeadIcon = selector_engine_default.find(
      `${HEAD_ICON_REF}`,
      this._element
    );
    stepperHeadIcon[index].classList.add("!bg-success-100");
    stepperHeadIcon[index].classList.add("!text-success-700");
    stepperHeadIcon[index].classList.remove("!bg-danger-100");
    stepperHeadIcon[index].classList.remove("!text-danger-700");
    this._toggleStepClass(index, "add", this._options.stepperCompleted);
    this._toggleStepClass(index, "remove", this._options.stepperInvalid);
  }
  _hideInactiveSteps() {
    this._steps.forEach((el) => {
      if (!el.getAttribute("data-te")) {
        this._hideElement(selector_engine_default.findOne(`${CONTENT_REF}`, el));
      }
    });
  }
  _setHeight(stepElement) {
    const stepContent = selector_engine_default.findOne(`${CONTENT_REF}`, stepElement);
    const contentStyle = getComputedStyle(stepContent);
    const stepHead = selector_engine_default.findOne(`${HEAD_REF}`, stepElement);
    const headStyle = getComputedStyle(stepHead);
    const stepContentHeight = stepContent.offsetHeight + parseFloat(contentStyle.marginTop) + parseFloat(contentStyle.marginBottom);
    const stepHeadHeight = stepHead.offsetHeight + parseFloat(headStyle.marginTop) + parseFloat(headStyle.marginBottom);
    this._element.style.height = `${stepHeadHeight + stepContentHeight}px`;
  }
  _hideElement(stepContent) {
    const isActive = selector_engine_default.parents(
      stepContent,
      `${STEP_REF}`
    )[0].getAttribute("data-te");
    if (!isActive && this._currentView !== STEPPER_VERTICAL) {
    } else {
      stepContent.classList.add("!my-0");
      stepContent.classList.add("!py-0");
      stepContent.classList.add("!h-0");
    }
  }
  _showElement(stepContent) {
    if (this._currentView === STEPPER_VERTICAL) {
      stepContent.classList.remove("!my-0");
      stepContent.classList.remove("!py-0");
      stepContent.classList.remove("!h-0");
    } else {
      stepContent.style.display = "block";
    }
  }
  _animateHorizontalStep(index) {
    const isForward = index > this._activeStepIndex;
    const nextStepContent = selector_engine_default.findOne(
      `${CONTENT_REF}`,
      this._steps[index]
    );
    const activeStepContent = selector_engine_default.findOne(
      `${CONTENT_REF}`,
      this.activeStep
    );
    let nextStepAnimation;
    let activeStepAnimation;
    this._steps.forEach((el, i) => {
      const stepContent = selector_engine_default.findOne(`${CONTENT_REF}`, el);
      if (i !== index && i !== this._activeStepIndex) {
        this._hideElement(stepContent);
      }
    });
    const CLASS_NAME_SLIDE_RIGHT = "translate-x-[150%]";
    const CLASS_NAME_SLIDE_LEFT = "-translate-x-[150%]";
    const CLASS_NAME_SLIDE_IN = "translate-0";
    if (isForward) {
      activeStepAnimation = CLASS_NAME_SLIDE_LEFT;
      nextStepAnimation = CLASS_NAME_SLIDE_IN;
      nextStepContent.classList.remove("translate-x-[150%]");
      nextStepContent.classList.remove("-translate-x-[150%]");
    } else {
      activeStepAnimation = CLASS_NAME_SLIDE_RIGHT;
      nextStepAnimation = CLASS_NAME_SLIDE_IN;
      nextStepContent.classList.remove("-translate-x-[150%]");
      nextStepContent.classList.remove("translate-x-[150%]");
    }
    activeStepContent.classList.add(activeStepAnimation);
    nextStepContent.classList.add(nextStepAnimation);
    this._setHeight(this._steps[index]);
  }
  _animateVerticalStep(index) {
    const nextStepContent = selector_engine_default.findOne(
      `${CONTENT_REF}`,
      this._steps[index]
    );
    const activeStepContent = selector_engine_default.findOne(
      `${CONTENT_REF}`,
      this.activeStep
    );
    this._hideElement(activeStepContent);
    this._showElement(nextStepContent);
  }
  static getInstance(element2) {
    return data_default.getData(element2, DATA_KEY19);
  }
  static getOrCreateInstance(element2, config = {}) {
    return this.getInstance(element2) || new this(element2, typeof config === "object" ? config : null);
  }
};
selector_engine_default.find(SELECTOR_EXPAND2).forEach((el) => {
  let instance = Stepper.getInstance(el);
  if (!instance) {
    instance = new Stepper(el);
  }
  return instance;
});
var stepper_default = Stepper;

// node_modules/tw-elements/dist/src/js/forms/select/select-option.js
var DATA_ACTIVE2 = "data-te-input-state-active";
var DATA_SELECTED = "data-te-input-selected";
var DATA_MULTIPLE_ACTIVE = "data-te-input-multiple-active";
var SELECTOR_FORM_CHECK_INPUT = "[data-te-form-check-input]";
var SelectOption = class {
  constructor(id, nativeOption, multiple, value, label, selected, disabled, hidden, secondaryText, groupId, icon) {
    this.id = id;
    this.nativeOption = nativeOption;
    this.multiple = multiple;
    this.value = value;
    this.label = label;
    this.selected = selected;
    this.disabled = disabled;
    this.hidden = hidden;
    this.secondaryText = secondaryText;
    this.groupId = groupId;
    this.icon = icon;
    this.node = null;
    this.active = false;
  }
  select() {
    if (this.multiple) {
      this._selectMultiple();
    } else {
      this._selectSingle();
    }
  }
  _selectSingle() {
    if (!this.selected) {
      this.node.setAttribute(DATA_SELECTED, "");
      this.node.setAttribute("aria-selected", true);
      this.selected = true;
      if (this.nativeOption) {
        this.nativeOption.selected = true;
      }
    }
  }
  _selectMultiple() {
    if (!this.selected) {
      const checkbox = selector_engine_default.findOne(
        SELECTOR_FORM_CHECK_INPUT,
        this.node
      );
      checkbox.checked = true;
      this.node.setAttribute(DATA_SELECTED, "");
      this.node.setAttribute("aria-selected", true);
      this.selected = true;
      if (this.nativeOption) {
        this.nativeOption.selected = true;
      }
    }
  }
  deselect() {
    if (this.multiple) {
      this._deselectMultiple();
    } else {
      this._deselectSingle();
    }
  }
  _deselectSingle() {
    if (this.selected) {
      this.node.removeAttribute(DATA_SELECTED);
      this.node.setAttribute("aria-selected", false);
      this.selected = false;
      if (this.nativeOption) {
        this.nativeOption.selected = false;
      }
    }
  }
  _deselectMultiple() {
    if (this.selected) {
      const checkbox = selector_engine_default.findOne(
        SELECTOR_FORM_CHECK_INPUT,
        this.node
      );
      checkbox.checked = false;
      this.node.removeAttribute(DATA_SELECTED);
      this.node.setAttribute("aria-selected", false);
      this.selected = false;
      if (this.nativeOption) {
        this.nativeOption.selected = false;
      }
    }
  }
  setNode(node) {
    this.node = node;
  }
  setActiveStyles() {
    if (!this.active) {
      if (this.multiple) {
        this.node.setAttribute(DATA_MULTIPLE_ACTIVE, "");
        return;
      }
      this.active = true;
      this.node.setAttribute(DATA_ACTIVE2, "");
    }
  }
  removeActiveStyles() {
    if (this.active) {
      this.active = false;
      this.node.removeAttribute(DATA_ACTIVE2);
    }
    if (this.multiple) {
      this.node.removeAttribute(DATA_MULTIPLE_ACTIVE);
    }
  }
};
var select_option_default = SelectOption;

// node_modules/tw-elements/dist/src/js/forms/select/selection-model.js
var SelectionModel = class {
  constructor(multiple = false) {
    this._multiple = multiple;
    this._selections = [];
  }
  select(option) {
    if (this._multiple) {
      this._selections.push(option);
    } else {
      this._selections = [option];
    }
  }
  deselect(option) {
    if (this._multiple) {
      const optionIndex = this._selections.findIndex(
        (selection) => option === selection
      );
      this._selections.splice(optionIndex, 1);
    } else {
      this._selections = [];
    }
  }
  clear() {
    this._selections = [];
  }
  get selection() {
    return this._selections[0];
  }
  get selections() {
    return this._selections;
  }
  get label() {
    return this._selections[0] && this.selection.label;
  }
  get labels() {
    return this._selections.map((selection) => selection.label).join(", ");
  }
  get value() {
    return this.selections[0] && this.selection.value;
  }
  get values() {
    return this._selections.map((selection) => selection.value);
  }
};
var selection_model_default = SelectionModel;

// node_modules/tw-elements/dist/src/js/forms/select/util.js
function allOptionsSelected(options) {
  return options.filter((option) => !option.disabled).every((option) => {
    return option.selected;
  });
}

// node_modules/tw-elements/dist/src/js/forms/select/templates.js
var DATA_FORM_OUTLINE = "data-te-select-form-outline-ref";
var DATA_SELECT_WRAPPER = "data-te-select-wrapper-ref";
var DATA_SELECT_INPUT = "data-te-select-input-ref";
var DATA_CLEAR_BUTTON = "data-te-select-clear-btn-ref";
var DATA_SELECT_DROPDOWN_CONTAINER = "data-te-select-dropdown-container-ref";
var DATA_DROPDOWN = "data-te-select-dropdown-ref";
var DATA_OPTIONS_WRAPPER = "data-te-select-options-wrapper-ref";
var DATA_OPTIONS_LIST = "data-te-select-options-list-ref";
var DATA_FILTER_INPUT = "data-te-select-input-filter-ref";
var DATA_OPTION = "data-te-select-option-ref";
var DATA_OPTION_ALL = "data-te-select-option-all-ref";
var DATA_SELECT_OPTION_TEXT = "data-te-select-option-text-ref";
var DATA_FORM_CHECK_INPUT = "data-te-form-check-input";
var DATA_SELECT_OPTION_GROUP = "data-te-select-option-group-ref";
var DATA_SELECT_OPTION_GROUP_LABEL = "data-te-select-option-group-label-ref";
var DATA_SELECTED2 = "data-te-select-selected";
var preventKeydown = (event) => {
  if (event.code === "Tab" || event.code === "Esc") {
    return;
  }
  event.preventDefault();
};
function _setSizeClasses(element2, config, defaultSize, smSize, lgSize) {
  if (config.selectSize === "default") {
    manipulator_default.addClass(element2, defaultSize);
  }
  if (config.selectSize === "sm") {
    manipulator_default.addClass(element2, smSize);
  }
  if (config.selectSize === "lg") {
    manipulator_default.addClass(element2, lgSize);
  }
}
function getWrapperTemplate(id, config, label, classes) {
  const wrapper = document.createElement("div");
  wrapper.setAttribute("id", id);
  wrapper.setAttribute(DATA_SELECT_WRAPPER, "");
  const formOutline = element("div");
  formOutline.setAttribute(DATA_FORM_OUTLINE, "");
  manipulator_default.addClass(formOutline, classes.formOutline);
  const input = element("input");
  const role = config.selectFilter ? "combobox" : "listbox";
  const multiselectable = config.multiple ? "true" : "false";
  const disabled = config.disabled ? "true" : "false";
  input.setAttribute(DATA_SELECT_INPUT, "");
  manipulator_default.addClass(input, classes.selectInput);
  _setSizeClasses(
    input,
    config,
    classes.selectInputSizeDefault,
    classes.selectInputSizeSm,
    classes.selectInputSizeLg
  );
  if (config.selectFormWhite) {
    manipulator_default.addClass(input, classes.selectInputWhite);
  }
  input.setAttribute("type", "text");
  input.setAttribute("role", role);
  input.setAttribute("aria-multiselectable", multiselectable);
  input.setAttribute("aria-disabled", disabled);
  input.setAttribute("aria-haspopup", "true");
  input.setAttribute("aria-expanded", false);
  if (config.tabIndex) {
    input.setAttribute("tabIndex", config.tabIndex);
  }
  if (config.disabled) {
    input.setAttribute("disabled", "");
  }
  if (config.selectPlaceholder !== "") {
    input.setAttribute("placeholder", config.selectPlaceholder);
  }
  if (config.selectValidation) {
    manipulator_default.addStyle(input, {
      "pointer-events": "none",
      "caret-color": "transparent"
    });
    manipulator_default.addStyle(formOutline, { cursor: "pointer" });
  } else {
    input.setAttribute("readonly", "true");
  }
  if (config.selectValidation) {
    input.setAttribute("required", "true");
    input.setAttribute("aria-required", "true");
    input.addEventListener("keydown", preventKeydown);
  }
  const validFeedback = element("div");
  manipulator_default.addClass(validFeedback, classes.selectValidationValid);
  const validFeedBackText = document.createTextNode(
    `${config.selectValidFeedback}`
  );
  validFeedback.appendChild(validFeedBackText);
  const invalidFeedback = element("div");
  manipulator_default.addClass(invalidFeedback, classes.selectValidationInvalid);
  const invalidFeedBackText = document.createTextNode(
    `${config.selectInvalidFeedback}`
  );
  invalidFeedback.appendChild(invalidFeedBackText);
  const clearBtn = element("span");
  clearBtn.setAttribute(DATA_CLEAR_BUTTON, "");
  manipulator_default.addClass(clearBtn, classes.selectClearBtn);
  _setSizeClasses(
    clearBtn,
    config,
    classes.selectClearBtnDefault,
    classes.selectClearBtnSm,
    classes.selectClearBtnLg
  );
  if (config.selectFormWhite) {
    manipulator_default.addClass(clearBtn, classes.selectClearBtnWhite);
  }
  const clearBtnText = document.createTextNode("✕");
  clearBtn.appendChild(clearBtnText);
  clearBtn.setAttribute("tabindex", "0");
  const arrow2 = element("span");
  manipulator_default.addClass(arrow2, classes.selectArrow);
  _setSizeClasses(
    arrow2,
    config,
    classes.selectArrowDefault,
    classes.selectArrowSm,
    classes.selectArrowLg
  );
  if (config.selectFormWhite) {
    manipulator_default.addClass(arrow2, classes.selectArrowWhite);
  }
  const arrowText = document.createTextNode("▼");
  arrow2.appendChild(arrowText);
  formOutline.appendChild(input);
  if (label) {
    manipulator_default.addClass(label, classes.selectLabel);
    _setSizeClasses(
      label,
      config,
      classes.selectLabelSizeDefault,
      classes.selectLabelSizeSm,
      classes.selectLabelSizeLg
    );
    if (config.selectFormWhite) {
      manipulator_default.addClass(label, classes.selectLabelWhite);
    }
    formOutline.appendChild(label);
  }
  if (config.selectValidation) {
    formOutline.appendChild(validFeedback);
    formOutline.appendChild(invalidFeedback);
  }
  if (config.selectClearButton) {
    formOutline.appendChild(clearBtn);
  }
  formOutline.appendChild(arrow2);
  wrapper.appendChild(formOutline);
  return wrapper;
}
function getDropdownTemplate(id, config, width, height, selectAllOption, options, customContent, classes) {
  const dropdownContainer = document.createElement("div");
  dropdownContainer.setAttribute(DATA_SELECT_DROPDOWN_CONTAINER, "");
  manipulator_default.addClass(dropdownContainer, classes.selectDropdownContainer);
  dropdownContainer.setAttribute("id", `${id}`);
  dropdownContainer.style.width = `${width}px`;
  const dropdown = document.createElement("div");
  dropdown.setAttribute("tabindex", 0);
  dropdown.setAttribute(DATA_DROPDOWN, "");
  manipulator_default.addClass(dropdown, classes.dropdown);
  const optionsWrapper = element("div");
  optionsWrapper.setAttribute(DATA_OPTIONS_WRAPPER, "");
  manipulator_default.addClass(optionsWrapper, classes.optionsWrapper);
  manipulator_default.addClass(optionsWrapper, classes.optionsWrapperScrollbar);
  optionsWrapper.style.maxHeight = `${height}px`;
  const optionsList = getOptionsListTemplate(
    options,
    selectAllOption,
    config,
    classes
  );
  optionsWrapper.appendChild(optionsList);
  if (config.selectFilter) {
    dropdown.appendChild(
      getFilterTemplate(config.selectSearchPlaceholder, classes)
    );
  }
  dropdown.appendChild(optionsWrapper);
  if (customContent) {
    dropdown.appendChild(customContent);
  }
  dropdownContainer.appendChild(dropdown);
  return dropdownContainer;
}
function getOptionsListTemplate(options, selectAllOption, config, classes) {
  const optionsList = element("div");
  optionsList.setAttribute(DATA_OPTIONS_LIST, "");
  manipulator_default.addClass(optionsList, classes.optionsList);
  let optionsNodes;
  if (config.multiple) {
    optionsNodes = getMultipleOptionsNodes(
      options,
      selectAllOption,
      config,
      classes
    );
  } else {
    optionsNodes = getSingleOptionsNodes(options, config, classes);
  }
  optionsNodes.forEach((node) => {
    optionsList.appendChild(node);
  });
  return optionsList;
}
function getFilterTemplate(placeholder, classes) {
  const inputGroup = element("div");
  manipulator_default.addClass(inputGroup, classes.inputGroup);
  const input = element("input");
  input.setAttribute(DATA_FILTER_INPUT, "");
  manipulator_default.addClass(input, classes.selectFilterInput);
  input.placeholder = placeholder;
  input.setAttribute("role", "searchbox");
  input.setAttribute("type", "text");
  inputGroup.appendChild(input);
  return inputGroup;
}
function getSingleOptionsNodes(options, config, classes) {
  const nodes = getOptionsNodes(options, config, classes);
  return nodes;
}
function getMultipleOptionsNodes(options, selectAllOption, config, classes) {
  let selectAllNode = null;
  if (config.selectAll) {
    selectAllNode = createSelectAllNode(
      selectAllOption,
      options,
      config,
      classes
    );
  }
  const optionsNodes = getOptionsNodes(options, config, classes);
  const nodes = selectAllNode ? [selectAllNode, ...optionsNodes] : optionsNodes;
  return nodes;
}
function getOptionsNodes(options, config, classes) {
  const nodes = [];
  options.forEach((option) => {
    const isOptionGroup = Object.prototype.hasOwnProperty.call(
      option,
      "options"
    );
    if (isOptionGroup) {
      const group = createOptionGroupTemplate(option, config, classes);
      nodes.push(group);
    } else {
      nodes.push(createOptionTemplate(option, config, classes));
    }
  });
  return nodes;
}
function createSelectAllNode(option, options, config, classes) {
  const isSelected = allOptionsSelected(options);
  const optionNode = element("div");
  optionNode.setAttribute(DATA_OPTION, "");
  manipulator_default.addClass(optionNode, classes.selectOption);
  optionNode.setAttribute(DATA_OPTION_ALL, "");
  manipulator_default.addStyle(optionNode, {
    height: `${config.selectOptionHeight}px`
  });
  optionNode.setAttribute("role", "option");
  optionNode.setAttribute("aria-selected", isSelected);
  if (isSelected) {
    optionNode.setAttribute(DATA_SELECTED2, "");
  }
  optionNode.appendChild(getOptionContentTemplate(option, config, classes));
  option.setNode(optionNode);
  return optionNode;
}
function createOptionTemplate(option, config, classes) {
  if (option.node) {
    return option.node;
  }
  const optionNode = element("div");
  optionNode.setAttribute(DATA_OPTION, "");
  manipulator_default.addClass(optionNode, classes.selectOption);
  manipulator_default.addStyle(optionNode, {
    height: `${config.selectOptionHeight}px`
  });
  manipulator_default.setDataAttribute(optionNode, "id", option.id);
  optionNode.setAttribute("role", "option");
  optionNode.setAttribute("aria-selected", option.selected);
  optionNode.setAttribute("aria-disabled", option.disabled);
  if (option.selected) {
    optionNode.setAttribute(DATA_SELECTED2, "");
  }
  if (option.disabled) {
    optionNode.setAttribute("data-te-select-option-disabled", true);
  }
  if (option.hidden) {
    manipulator_default.addClass(optionNode, "hidden");
  }
  optionNode.appendChild(getOptionContentTemplate(option, config, classes));
  if (option.icon) {
    optionNode.appendChild(getOptionIconTemplate(option, classes));
  }
  option.setNode(optionNode);
  return optionNode;
}
function getOptionContentTemplate(option, config, classes) {
  const content = element("span");
  content.setAttribute(DATA_SELECT_OPTION_TEXT, "");
  manipulator_default.addClass(content, classes.selectOptionText);
  const label = document.createTextNode(option.label);
  if (config.multiple) {
    content.appendChild(getCheckboxTemplate(option, classes));
  }
  content.appendChild(label);
  if (option.secondaryText || typeof option.secondaryText === "number") {
    content.appendChild(
      getSecondaryTextTemplate(option.secondaryText, classes)
    );
  }
  return content;
}
function getSecondaryTextTemplate(text, classes) {
  const span = element("span");
  manipulator_default.addClass(span, classes.selectOptionSecondaryText);
  const textContent = document.createTextNode(text);
  span.appendChild(textContent);
  return span;
}
function getCheckboxTemplate(option, classes) {
  const checkbox = element("input");
  checkbox.setAttribute("type", "checkbox");
  manipulator_default.addClass(checkbox, classes.formCheckInput);
  checkbox.setAttribute(DATA_FORM_CHECK_INPUT, "");
  const label = element("label");
  if (option.selected) {
    checkbox.setAttribute("checked", true);
  }
  if (option.disabled) {
    checkbox.setAttribute("disabled", true);
  }
  checkbox.appendChild(label);
  return checkbox;
}
function getOptionIconTemplate(option, classes) {
  const container = element("span");
  const image = element("img");
  manipulator_default.addClass(image, classes.selectOptionIcon);
  image.src = option.icon;
  container.appendChild(image);
  return container;
}
function createOptionGroupTemplate(optionGroup, config, classes) {
  const group = element("div");
  group.setAttribute(DATA_SELECT_OPTION_GROUP, "");
  manipulator_default.addClass(group, classes.selectOptionGroup);
  group.setAttribute("role", "group");
  group.setAttribute("id", optionGroup.id);
  if (optionGroup.hidden) {
    manipulator_default.addClass(group, "hidden");
  }
  const label = element("label");
  label.setAttribute(DATA_SELECT_OPTION_GROUP_LABEL, "");
  manipulator_default.addClass(label, classes.selectOptionGroupLabel);
  manipulator_default.addStyle(label, { height: `${config.selectOptionHeight}px` });
  label.setAttribute("for", optionGroup.id);
  label.textContent = optionGroup.label;
  group.appendChild(label);
  optionGroup.options.forEach((option) => {
    group.appendChild(createOptionTemplate(option, config, classes));
  });
  return group;
}
function getFakeValueTemplate(value, classes) {
  const fakeValue = element("div");
  fakeValue.innerHTML = value;
  manipulator_default.addClass(fakeValue, classes.selectLabel);
  manipulator_default.addClass(fakeValue, classes.selectFakeValue);
  return fakeValue;
}

// node_modules/tw-elements/dist/src/js/forms/select/index.js
var NAME21 = "select";
var DATA_KEY20 = "te.select";
var EVENT_KEY16 = `.${DATA_KEY20}`;
var EVENT_CLOSE3 = `close${EVENT_KEY16}`;
var EVENT_OPEN2 = `open${EVENT_KEY16}`;
var EVENT_SELECT = `optionSelect${EVENT_KEY16}`;
var EVENT_DESELECT = `optionDeselect${EVENT_KEY16}`;
var EVENT_VALUE_CHANGE = `valueChange${EVENT_KEY16}`;
var EVENT_CHANGE = "change";
var DATA_SELECT_INIT = "data-te-select-init";
var DATA_NO_RESULT = "data-te-select-no-results-ref";
var DATA_OPEN = "data-te-select-open";
var DATA_ACTIVE3 = "data-te-input-state-active";
var DATA_FOCUSED2 = "data-te-input-focused";
var DATA_DISABLED = "data-te-input-disabled";
var DATA_SELECT_OPTION_GROUP_LABEL2 = "data-te-select-option-group-label-ref";
var DATA_OPTION_ALL2 = "data-te-select-option-all-ref";
var DATA_SELECTED3 = "data-te-select-selected";
var SELECTOR_SELECT = `[${DATA_SELECT_INIT}]`;
var SELECTOR_LABEL = "[data-te-select-label-ref]";
var SELECTOR_INPUT = "[data-te-select-input-ref]";
var SELECTOR_FILTER_INPUT = "[data-te-select-input-filter-ref]";
var SELECTOR_DROPDOWN3 = "[data-te-select-dropdown-ref]";
var SELECTOR_OPTIONS_WRAPPER = "[data-te-select-options-wrapper-ref]";
var SELECTOR_OPTIONS_LIST = "[data-te-select-options-list-ref]";
var SELECTOR_OPTION = "[data-te-select-option-ref]";
var SELECTOR_CLEAR_BUTTON = "[data-te-select-clear-btn-ref]";
var SELECTOR_CUSTOM_CONTENT = "[data-te-select-custom-content-ref]";
var SELECTOR_NO_RESULTS = `[${DATA_NO_RESULT}]`;
var SELECTOR_FORM_OUTLINE = "[data-te-select-form-outline-ref]";
var SELECTOR_TOGGLE2 = "[data-te-select-toggle]";
var SELECTOR_NOTCH2 = "[data-te-input-notch-ref]";
var ANIMATION_TRANSITION_TIME = 200;
var Default18 = {
  selectAutoSelect: false,
  selectContainer: "body",
  selectClearButton: false,
  disabled: false,
  selectDisplayedLabels: 5,
  selectFormWhite: false,
  multiple: false,
  selectOptionsSelectedLabel: "options selected",
  selectOptionHeight: 38,
  selectAll: true,
  selectAllLabel: "Select all",
  selectSearchPlaceholder: "Search...",
  selectSize: "default",
  selectVisibleOptions: 5,
  selectFilter: false,
  selectFilterDebounce: 300,
  selectNoResultText: "No results",
  selectValidation: false,
  selectValidFeedback: "Valid",
  selectInvalidFeedback: "Invalid",
  selectPlaceholder: ""
};
var DefaultType18 = {
  selectAutoSelect: "boolean",
  selectContainer: "string",
  selectClearButton: "boolean",
  disabled: "boolean",
  selectDisplayedLabels: "number",
  selectFormWhite: "boolean",
  multiple: "boolean",
  selectOptionsSelectedLabel: "string",
  selectOptionHeight: "number",
  selectAll: "boolean",
  selectAllLabel: "string",
  selectSearchPlaceholder: "string",
  selectSize: "string",
  selectVisibleOptions: "number",
  selectFilter: "boolean",
  selectFilterDebounce: "number",
  selectNoResultText: "string",
  selectValidation: "boolean",
  selectValidFeedback: "string",
  selectInvalidFeedback: "string",
  selectPlaceholder: "string"
};
var DefaultClasses12 = {
  dropdown: "relative outline-none min-w-[100px] m-0 scale-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-select-open]:scale-100 data-[te-select-open]:opacity-100 dark:bg-zinc-700",
  formCheckInput: "relative float-left mt-[3px] mr-2 h-4 w-4 cursor-pointer appearance-none rounded-sm border border-gray-300 bg-white bg-contain bg-center bg-no-repeat align-top transition duration-200 motion-reduce:transition-none checked:border-blue-600 checked:bg-blue-600 checked:after:absolute checked:after:ml-[5px] checked:after:mt-px checked:after:block checked:after:h-[9px] checked:after:w-[5px] checked:after:rotate-45 checked:after:border-2 checked:after:border-t-0 checked:after:border-l-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] focus:outline-none group-data-[te-select-option-text-ref]:mr-2.5 dark:bg-zinc-700 dark:checked:bg-blue-500",
  formOutline: "relative",
  initialized: "hidden",
  inputGroup: "flex items-center whitespace-nowrap p-2.5 text-center text-base font-normal leading-[1.6] text-gray-700 dark:bg-zinc-800 dark:text-gray-200 dark:placeholder:text-gray-200",
  noResult: "flex items-center px-4",
  optionsList: "list-none m-0 p-0",
  optionsWrapper: "overflow-y-auto",
  optionsWrapperScrollbar: "[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded",
  selectArrow: "absolute right-2 text-[0.8rem] cursor-pointer peer-focus:text-blue-600 peer-data-[te-input-focused]:text-blue-600 group-data-[te-was-validated]/validation:peer-valid:text-green-600 group-data-[te-was-validated]/validation:peer-invalid:text-[rgb(220,76,100)]",
  selectArrowWhite: "text-gray-50 peer-focus:!text-white peer-data-[te-input-focused]:!text-white",
  selectArrowDefault: "top-2",
  selectArrowLg: "top-[13px]",
  selectArrowSm: "top-1",
  selectClearBtn: "absolute top-2 right-7 text-black cursor-pointer focus:text-blue-600 outline-none dark:text-gray-200",
  selectClearBtnWhite: "!text-gray-50",
  selectClearBtnDefault: "top-2 text-base",
  selectClearBtnLg: "top-[11px] text-base",
  selectClearBtnSm: "top-1 text-[0.8rem]",
  selectDropdownContainer: "z-[1070]",
  selectFakeValue: "transform-none hidden data-[te-input-state-active]:block",
  selectFilterInput: "relative m-0 block w-full min-w-0 flex-auto rounded border border-solid border-gray-300 bg-transparent bg-clip-padding px-3 py-1.5 text-base font-normal text-gray-700 transition duration-300 ease-in-out motion-reduce:transition-none focus:border-blue-600 focus:text-gray-700 focus:shadow-te-blue focus:outline-none dark:text-gray-200 dark:placeholder:text-gray-200",
  selectInput: "peer block min-h-[auto] w-full rounded border-0 bg-transparent outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0 cursor-pointer data-[te-input-disabled]:bg-[#e9ecef] data-[te-input-disabled]:cursor-default group-data-[te-was-validated]/validation:mb-4 dark:data-[te-input-disabled]:bg-zinc-600",
  selectInputWhite: "!text-gray-50",
  selectInputSizeDefault: "py-[0.32rem] px-3 leading-[1.6]",
  selectInputSizeLg: "py-[0.32rem] px-3 leading-[2.15]",
  selectInputSizeSm: "py-[0.33rem] px-3 text-xs leading-[1.5]",
  selectLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate text-gray-500 transition-all duration-200 ease-out peer-focus:scale-[0.8] peer-focus:text-blue-600 peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200 data-[te-input-state-active]:scale-[0.8]",
  selectLabelWhite: "!text-gray-50",
  selectLabelSizeDefault: "pt-[0.37rem] leading-[1.6] peer-focus:-translate-y-[0.9rem] peer-data-[te-input-state-active]:-translate-y-[0.9rem] data-[te-input-state-active]:-translate-y-[0.9rem]",
  selectLabelSizeLg: "pt-[0.37rem] leading-[2.15] peer-focus:-translate-y-[1.15rem] peer-data-[te-input-state-active]:-translate-y-[1.15rem] data-[te-input-state-active]:-translate-y-[1.15rem]",
  selectLabelSizeSm: "pt-[0.37rem] text-xs leading-[1.5] peer-focus:-translate-y-[0.75rem] peer-data-[te-input-state-active]:-translate-y-[0.75rem] data-[te-input-state-active]:-translate-y-[0.75rem]",
  selectOption: "flex flex-row items-center justify-between w-full px-4 truncate text-gray-700 bg-transparent select-none cursor-pointer data-[te-input-multiple-active]:bg-black/5 hover:[&:not([data-te-select-option-disabled])]:bg-black/5 data-[te-input-state-active]:bg-black/5 data-[te-select-option-selected]:data-[te-input-state-active]:bg-black/5 data-[te-select-selected]:data-[te-select-option-disabled]:cursor-default data-[te-select-selected]:data-[te-select-option-disabled]:text-gray-400 data-[te-select-selected]:data-[te-select-option-disabled]:bg-transparent data-[te-select-option-selected]:bg-black/[0.02] data-[te-select-option-disabled]:text-gray-400 data-[te-select-option-disabled]:cursor-default group-data-[te-select-option-group-ref]/opt:pl-7 dark:text-gray-200 dark:hover:[&:not([data-te-select-option-disabled])]:bg-white/30 dark:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-selected]:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-disabled]:text-gray-400 dark:data-[te-input-multiple-active]:bg-white/30",
  selectOptionGroup: "group/opt",
  selectOptionGroupLabel: "flex flex-row items-center w-full px-4 truncate bg-transparent text-black/50 select-none dark:text-gray-300",
  selectOptionIcon: "w-7 h-7 rounded-full",
  selectOptionSecondaryText: "block text-[0.8rem] text-gray-500 dark:text-gray-300",
  selectOptionText: "group",
  selectValidationValid: "hidden absolute -mt-3 w-auto text-sm text-green-600 cursor-pointer group-data-[te-was-validated]/validation:peer-valid:block",
  selectValidationInvalid: "hidden absolute -mt-3 w-auto text-sm text-[rgb(220,76,100)] cursor-pointer group-data-[te-was-validated]/validation:peer-invalid:block"
};
var DefaultClassesType12 = {
  dropdown: "string",
  formCheckInput: "string",
  formOutline: "string",
  initialized: "string",
  inputGroup: "string",
  noResult: "string",
  optionsList: "string",
  optionsWrapper: "string",
  optionsWrapperScrollbar: "string",
  selectArrow: "string",
  selectArrowDefault: "string",
  selectArrowLg: "string",
  selectArrowSm: "string",
  selectClearBtn: "string",
  selectClearBtnDefault: "string",
  selectClearBtnLg: "string",
  selectClearBtnSm: "string",
  selectDropdownContainer: "string",
  selectFakeValue: "string",
  selectFilterInput: "string",
  selectInput: "string",
  selectInputSizeDefault: "string",
  selectInputSizeLg: "string",
  selectInputSizeSm: "string",
  selectLabel: "string",
  selectLabelSizeDefault: "string",
  selectLabelSizeLg: "string",
  selectLabelSizeSm: "string",
  selectOption: "string",
  selectOptionGroup: "string",
  selectOptionGroupLabel: "string",
  selectOptionIcon: "string",
  selectOptionSecondaryText: "string",
  selectOptionText: "string"
};
var Select = class {
  constructor(element2, config, classes) {
    this._element = element2;
    this._config = this._getConfig(config);
    this._classes = this._getClasses(classes);
    this._optionsToRender = this._getOptionsToRender(element2);
    this._plainOptions = this._getPlainOptions(this._optionsToRender);
    this._filteredOptionsList = null;
    this._selectionModel = new selection_model_default(this.multiple);
    this._activeOptionIndex = -1;
    this._activeOption = null;
    this._wrapperId = getUID("select-wrapper-");
    this._dropdownContainerId = getUID("select-dropdown-container-");
    this._selectAllId = getUID("select-all-");
    this._debounceTimeoutId = null;
    this._dropdownHeight = this._config.selectOptionHeight * this._config.selectVisibleOptions;
    this._popper = null;
    this._input = null;
    this._label = selector_engine_default.next(this._element, SELECTOR_LABEL)[0];
    this._notch = null;
    this._fakeValue = null;
    this._isFakeValueActive = false;
    this._customContent = selector_engine_default.next(
      element2,
      SELECTOR_CUSTOM_CONTENT
    )[0];
    this._toggleButton = null;
    this._elementToggle = null;
    this._wrapper = null;
    this._inputEl = null;
    this._dropdownContainer = null;
    this._container = null;
    this._selectAllOption = null;
    this._init();
    this._mutationObserver = null;
    this._isOpen = false;
    this._addMutationObserver();
    if (this._element) {
      data_default.setData(element2, DATA_KEY20, this);
    }
  }
  static get NAME() {
    return NAME21;
  }
  get filterInput() {
    return selector_engine_default.findOne(
      SELECTOR_FILTER_INPUT,
      this._dropdownContainer
    );
  }
  get dropdown() {
    return selector_engine_default.findOne(SELECTOR_DROPDOWN3, this._dropdownContainer);
  }
  get optionsList() {
    return selector_engine_default.findOne(
      SELECTOR_OPTIONS_LIST,
      this._dropdownContainer
    );
  }
  get optionsWrapper() {
    return selector_engine_default.findOne(
      SELECTOR_OPTIONS_WRAPPER,
      this._dropdownContainer
    );
  }
  get clearButton() {
    return selector_engine_default.findOne(SELECTOR_CLEAR_BUTTON, this._wrapper);
  }
  get options() {
    return this._filteredOptionsList ? this._filteredOptionsList : this._plainOptions;
  }
  get value() {
    return this.multiple ? this._selectionModel.values : this._selectionModel.value;
  }
  get multiple() {
    return this._config.multiple;
  }
  get hasSelectAll() {
    return this.multiple && this._config.selectAll;
  }
  get hasSelection() {
    return this._selectionModel.selection || this._selectionModel.selections.length > 0;
  }
  _getConfig(config) {
    const dataAttributes = manipulator_default.getDataAttributes(this._element);
    config = {
      ...Default18,
      ...dataAttributes,
      ...config
    };
    if (this._element.hasAttribute("multiple")) {
      config.multiple = true;
    }
    if (this._element.hasAttribute("disabled")) {
      config.disabled = true;
    }
    if (this._element.tabIndex) {
      config.tabIndex = this._element.getAttribute("tabIndex");
    }
    typeCheckConfig(NAME21, config, DefaultType18);
    return config;
  }
  _getClasses(classes) {
    const dataAttributes = manipulator_default.getDataClassAttributes(this._element);
    classes = {
      ...DefaultClasses12,
      ...dataAttributes,
      ...classes
    };
    typeCheckConfig(NAME21, classes, DefaultClassesType12);
    return classes;
  }
  _getOptionsToRender(select) {
    const options = [];
    const nodes = select.childNodes;
    nodes.forEach((node) => {
      if (node.nodeName === "OPTGROUP") {
        const optionGroup = {
          id: getUID("group-"),
          label: node.label,
          disabled: node.hasAttribute("disabled"),
          hidden: node.hasAttribute("hidden"),
          options: []
        };
        const groupOptions = node.childNodes;
        groupOptions.forEach((option) => {
          if (option.nodeName === "OPTION") {
            optionGroup.options.push(
              this._createOptionObject(option, optionGroup)
            );
          }
        });
        options.push(optionGroup);
      } else if (node.nodeName === "OPTION") {
        options.push(this._createOptionObject(node));
      }
    });
    return options;
  }
  _getPlainOptions(optionsToRender) {
    const hasOptionGroup = selector_engine_default.findOne("optgroup", this._element);
    if (!hasOptionGroup) {
      return optionsToRender;
    }
    const options = [];
    optionsToRender.forEach((option) => {
      const isOptionGroup = Object.prototype.hasOwnProperty.call(
        option,
        "options"
      );
      if (isOptionGroup) {
        option.options.forEach((nestedOption) => {
          options.push(nestedOption);
        });
      } else {
        options.push(option);
      }
    });
    return options;
  }
  _createOptionObject(nativeOption, group = {}) {
    const id = getUID("option-");
    const groupId = group.id ? group.id : null;
    const groupDisabled = group.disabled ? group.disabled : false;
    const selected = nativeOption.selected || nativeOption.hasAttribute(DATA_SELECTED3);
    const disabled = nativeOption.hasAttribute("disabled") || groupDisabled;
    const hidden = nativeOption.hasAttribute("hidden") || group && group.hidden;
    const multiple = this.multiple;
    const value = nativeOption.value;
    const label = nativeOption.label;
    const secondaryText = manipulator_default.getDataAttribute(
      nativeOption,
      "selectSecondaryText"
    );
    const icon = manipulator_default.getDataAttribute(nativeOption, "select-icon");
    return new select_option_default(
      id,
      nativeOption,
      multiple,
      value,
      label,
      selected,
      disabled,
      hidden,
      secondaryText,
      groupId,
      icon
    );
  }
  _getNavigationOptions() {
    const availableOptions = this.options.filter((option) => !option.hidden);
    return this.hasSelectAll ? [this._selectAllOption, ...availableOptions] : availableOptions;
  }
  _init() {
    this._renderMaterialWrapper();
    this._wrapper = selector_engine_default.findOne(`#${this._wrapperId}`);
    this._input = selector_engine_default.findOne(SELECTOR_INPUT, this._wrapper);
    this._config.disabled && this._input.setAttribute(DATA_DISABLED, "");
    const containerSelector = this._config.selectContainer;
    if (containerSelector === "body") {
      this._container = document.body;
    } else {
      this._container = selector_engine_default.findOne(containerSelector);
    }
    this._initOutlineInput();
    this._setDefaultSelections();
    this._updateInputValue();
    this._appendFakeValue();
    this._updateFakeLabelPosition();
    this._updateLabelPosition();
    this._updateClearButtonVisibility();
    this._bindComponentEvents();
    if (this.hasSelectAll) {
      this._selectAllOption = this._createSelectAllOption();
    }
    this._dropdownContainer = getDropdownTemplate(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent,
      this._classes
    );
    this._setFirstActiveOption();
    this._listenToFocusChange();
  }
  _renderMaterialWrapper() {
    const template = getWrapperTemplate(
      this._wrapperId,
      this._config,
      this._label,
      this._classes
    );
    this._element.parentNode.insertBefore(template, this._element);
    manipulator_default.addClass(this._element, this._classes.initialized);
    template.appendChild(this._element);
  }
  _initOutlineInput() {
    const inputWrapper = selector_engine_default.findOne(
      SELECTOR_FORM_OUTLINE,
      this._wrapper
    );
    const outlineInput = new input_default(inputWrapper, {
      inputFormWhite: this._config.selectFormWhite
    });
    outlineInput.init();
    this._notch = selector_engine_default.findOne(SELECTOR_NOTCH2, this._wrapper);
  }
  _bindComponentEvents() {
    this._listenToComponentKeydown();
    this._listenToWrapperClick();
    this._listenToClearBtnClick();
    this._listenToClearBtnKeydown();
  }
  _setDefaultSelections() {
    this.options.forEach((option) => {
      if (option.selected) {
        this._selectionModel.select(option);
      }
    });
  }
  _listenToComponentKeydown() {
    event_handler_default.on(this._wrapper, "keydown", this._handleKeydown.bind(this));
  }
  _handleKeydown(event) {
    if (this._isOpen && !this._config.selectFilter) {
      this._handleOpenKeydown(event);
    } else {
      this._handleClosedKeydown(event);
    }
  }
  _handleOpenKeydown(event) {
    const key = event.keyCode;
    const isCloseKey = key === ESCAPE || key === UP_ARROW && event.altKey || key === TAB;
    if (key === TAB && this._config.selectAutoSelect && !this.multiple) {
      this._handleAutoSelection(this._activeOption);
    }
    if (isCloseKey) {
      this.close();
      this._input.focus();
      return;
    }
    switch (key) {
      case DOWN_ARROW:
        this._setNextOptionActive();
        this._scrollToOption(this._activeOption);
        break;
      case UP_ARROW:
        this._setPreviousOptionActive();
        this._scrollToOption(this._activeOption);
        break;
      case HOME:
        this._setFirstOptionActive();
        this._scrollToOption(this._activeOption);
        break;
      case END:
        this._setLastOptionActive();
        this._scrollToOption(this._activeOption);
        break;
      case ENTER:
        event.preventDefault();
        if (this._activeOption) {
          if (this.hasSelectAll && this._activeOptionIndex === 0) {
            this._handleSelectAll();
          } else {
            this._handleSelection(this._activeOption);
          }
        }
        return;
      default:
        return;
    }
    event.preventDefault();
  }
  _handleClosedKeydown(event) {
    const key = event.keyCode;
    if (key === ENTER) {
      event.preventDefault();
    }
    const isOpenKey = key === ENTER || key === DOWN_ARROW && event.altKey || key === DOWN_ARROW && this.multiple;
    if (isOpenKey) {
      this.open();
    }
    if (!this.multiple) {
      switch (key) {
        case DOWN_ARROW:
          this._setNextOptionActive();
          this._handleSelection(this._activeOption);
          break;
        case UP_ARROW:
          this._setPreviousOptionActive();
          this._handleSelection(this._activeOption);
          break;
        case HOME:
          this._setFirstOptionActive();
          this._handleSelection(this._activeOption);
          break;
        case END:
          this._setLastOptionActive();
          this._handleSelection(this._activeOption);
          break;
        default:
          return;
      }
    } else {
      switch (key) {
        case DOWN_ARROW:
          this.open();
          break;
        case UP_ARROW:
          this.open();
          break;
        default:
          return;
      }
    }
    event.preventDefault();
  }
  _scrollToOption(option) {
    if (!option) {
      return;
    }
    let optionIndex;
    const visibleOptions = this.options.filter((option2) => !option2.hidden);
    if (this.hasSelectAll) {
      optionIndex = visibleOptions.indexOf(option) + 1;
    } else {
      optionIndex = visibleOptions.indexOf(option);
    }
    const groupsNumber = this._getNumberOfGroupsBeforeOption(optionIndex);
    const scrollToIndex = optionIndex + groupsNumber;
    const list = this.optionsWrapper;
    const listHeight = list.offsetHeight;
    const optionHeight = this._config.selectOptionHeight;
    const scrollTop = list.scrollTop;
    if (optionIndex > -1) {
      const optionOffset = scrollToIndex * optionHeight;
      const isBelow = optionOffset + optionHeight > scrollTop + listHeight;
      const isAbove = optionOffset < scrollTop;
      if (isAbove) {
        list.scrollTop = optionOffset;
      } else if (isBelow) {
        list.scrollTop = optionOffset - listHeight + optionHeight;
      } else {
        list.scrollTop = scrollTop;
      }
    }
  }
  _getNumberOfGroupsBeforeOption(optionIndex) {
    const optionsList = this.options.filter((option) => !option.hidden);
    const groupsList = this._optionsToRender.filter((group) => !group.hidden);
    const index = this.hasSelectAll ? optionIndex - 1 : optionIndex;
    let groupsNumber = 0;
    for (let i = 0; i <= index; i++) {
      if (optionsList[i].groupId && groupsList[groupsNumber] && groupsList[groupsNumber].id && optionsList[i].groupId === groupsList[groupsNumber].id) {
        groupsNumber++;
      }
    }
    return groupsNumber;
  }
  _setNextOptionActive() {
    let index = this._activeOptionIndex + 1;
    const options = this._getNavigationOptions();
    if (!options[index]) {
      return;
    }
    while (options[index].disabled) {
      index += 1;
      if (!options[index]) {
        return;
      }
    }
    this._updateActiveOption(options[index], index);
  }
  _setPreviousOptionActive() {
    let index = this._activeOptionIndex - 1;
    const options = this._getNavigationOptions();
    if (!options[index]) {
      return;
    }
    while (options[index].disabled) {
      index -= 1;
      if (!options[index]) {
        return;
      }
    }
    this._updateActiveOption(options[index], index);
  }
  _setFirstOptionActive() {
    const index = 0;
    const options = this._getNavigationOptions();
    this._updateActiveOption(options[index], index);
  }
  _setLastOptionActive() {
    const options = this._getNavigationOptions();
    const index = options.length - 1;
    this._updateActiveOption(options[index], index);
  }
  _updateActiveOption(newActiveOption, index) {
    const currentActiveOption = this._activeOption;
    if (currentActiveOption) {
      currentActiveOption.removeActiveStyles();
    }
    newActiveOption.setActiveStyles();
    this._activeOptionIndex = index;
    this._activeOption = newActiveOption;
  }
  _listenToWrapperClick() {
    event_handler_default.on(this._wrapper, "click", () => {
      this.toggle();
    });
  }
  _listenToClearBtnClick() {
    event_handler_default.on(this.clearButton, "click", (event) => {
      event.preventDefault();
      event.stopPropagation();
      this._handleClear();
    });
  }
  _listenToClearBtnKeydown() {
    event_handler_default.on(this.clearButton, "keydown", (event) => {
      if (event.keyCode === ENTER) {
        this._handleClear();
        event.preventDefault();
        event.stopPropagation();
      }
    });
  }
  _handleClear() {
    if (this.multiple) {
      this._selectionModel.clear();
      this._deselectAllOptions(this.options);
      if (this.hasSelectAll) {
        this._updateSelectAllState();
      }
    } else {
      const selected = this._selectionModel.selection;
      this._selectionModel.clear();
      selected.deselect();
    }
    this._updateInputValue();
    this._updateFakeLabelPosition();
    this._updateLabelPosition();
    this._updateClearButtonVisibility();
    this._emitValueChangeEvent(null);
    this._emitNativeChangeEvent();
  }
  _listenToOptionsClick() {
    event_handler_default.on(this.optionsWrapper, "click", (event) => {
      const optionGroupLabel = event.target.hasAttribute(
        DATA_SELECT_OPTION_GROUP_LABEL2
      );
      if (optionGroupLabel) {
        return;
      }
      const target = event.target.nodeName === "DIV" ? event.target : selector_engine_default.closest(event.target, SELECTOR_OPTION);
      const selectAllOption = target.hasAttribute(DATA_OPTION_ALL2);
      if (selectAllOption) {
        this._handleSelectAll();
        return;
      }
      const id = target.dataset.teId;
      const option = this.options.find((option2) => option2.id === id);
      if (option && !option.disabled) {
        this._handleSelection(option);
      }
    });
  }
  _handleSelectAll() {
    const selected = this._selectAllOption.selected;
    if (selected) {
      this._deselectAllOptions(this.options);
      this._selectAllOption.deselect();
    } else {
      this._selectAllOptions(this.options);
      this._selectAllOption.select();
    }
    this._updateInputValue();
    this._updateFakeLabelPosition();
    this._updateLabelPosition();
    this._updateClearButtonVisibility();
    this._emitValueChangeEvent(this.value);
    this._emitNativeChangeEvent();
  }
  _selectAllOptions(options) {
    options.forEach((option) => {
      if (!option.selected && !option.disabled) {
        this._selectionModel.select(option);
        option.select();
      }
    });
  }
  _deselectAllOptions(options) {
    options.forEach((option) => {
      if (option.selected && !option.disabled) {
        this._selectionModel.deselect(option);
        option.deselect();
      }
    });
  }
  _handleSelection(option) {
    if (this.multiple) {
      this._handleMultiSelection(option);
      if (this.hasSelectAll) {
        this._updateSelectAllState();
      }
    } else {
      this._handleSingleSelection(option);
    }
    this._updateInputValue();
    this._updateFakeLabelPosition();
    this._updateLabelPosition();
    this._updateClearButtonVisibility();
  }
  _handleAutoSelection(option) {
    this._singleOptionSelect(option);
    this._updateInputValue();
    this._updateFakeLabelPosition();
    this._updateLabelPosition();
    this._updateClearButtonVisibility();
  }
  _handleSingleSelection(option) {
    this._singleOptionSelect(option);
    this.close();
    this._input.focus();
  }
  _singleOptionSelect(option) {
    const currentSelected = this._selectionModel.selections[0];
    if (currentSelected && currentSelected !== option) {
      this._selectionModel.deselect(currentSelected);
      currentSelected.deselect();
      currentSelected.node.setAttribute(DATA_SELECTED3, false);
      event_handler_default.trigger(this._element, EVENT_DESELECT, {
        value: currentSelected.value
      });
    }
    if (!currentSelected || currentSelected && option !== currentSelected) {
      this._selectionModel.select(option);
      option.select();
      option.node.setAttribute(DATA_SELECTED3, true);
      event_handler_default.trigger(this._element, EVENT_SELECT, {
        value: option.value
      });
      this._emitValueChangeEvent(this.value);
      this._emitNativeChangeEvent();
    }
  }
  _handleMultiSelection(option) {
    if (option.selected) {
      this._selectionModel.deselect(option);
      option.deselect();
      option.node.setAttribute(DATA_SELECTED3, false);
      event_handler_default.trigger(this._element, EVENT_DESELECT, {
        value: option.value
      });
    } else {
      this._selectionModel.select(option);
      option.select();
      option.node.setAttribute(DATA_SELECTED3, true);
      event_handler_default.trigger(this._element, EVENT_SELECT, {
        value: option.value
      });
    }
    this._emitValueChangeEvent(this.value);
    this._emitNativeChangeEvent();
  }
  _emitValueChangeEvent(value) {
    event_handler_default.trigger(this._element, EVENT_VALUE_CHANGE, { value });
  }
  _emitNativeChangeEvent() {
    event_handler_default.trigger(this._element, EVENT_CHANGE);
  }
  _updateInputValue() {
    const labels = this.multiple ? this._selectionModel.labels : this._selectionModel.label;
    let value;
    if (this.multiple && this._config.selectDisplayedLabels !== -1 && this._selectionModel.selections.length > this._config.selectDisplayedLabels) {
      value = `${this._selectionModel.selections.length} ${this._config.selectOptionsSelectedLabel}`;
    } else {
      value = labels;
    }
    if (!this.multiple && !this._isSelectionValid(this._selectionModel.selection)) {
      this._input.value = "";
    } else if (this._isLabelEmpty(this._selectionModel.selection)) {
      this._input.value = " ";
    } else if (value) {
      this._input.value = value;
    } else {
      this.multiple || !this._optionsToRender[0] ? this._input.value = "" : this._input.value = this._optionsToRender[0].label;
    }
  }
  _isSelectionValid(selection) {
    if (selection && (selection.disabled || selection.value === "")) {
      return false;
    }
    return true;
  }
  _isLabelEmpty(selection) {
    if (selection && selection.label === "") {
      return true;
    }
    return false;
  }
  _appendFakeValue() {
    if (!this._selectionModel.selection || this._selectionModel._multiple) {
      return;
    }
    const value = this._selectionModel.selection.label;
    this._fakeValue = getFakeValueTemplate(value, this._classes);
    const inputWrapper = selector_engine_default.findOne(
      SELECTOR_FORM_OUTLINE,
      this._wrapper
    );
    inputWrapper.appendChild(this._fakeValue);
  }
  _updateLabelPosition() {
    const isInitialized = this._element.hasAttribute(DATA_SELECT_INIT);
    const isValueEmpty = this._input.value !== "";
    if (!this._label) {
      return;
    }
    if (isInitialized && (isValueEmpty || this._isOpen || this._isFakeValueActive)) {
      this._label.setAttribute(DATA_ACTIVE3, "");
      this._notch.setAttribute(DATA_ACTIVE3, "");
    } else {
      this._label.removeAttribute(DATA_ACTIVE3);
      this._notch.removeAttribute(DATA_ACTIVE3, "");
    }
  }
  _updateLabelPositionWhileClosing() {
    if (!this._label) {
      return;
    }
    if (this._input.value !== "" || this._isFakeValueActive) {
      this._label.setAttribute(DATA_ACTIVE3, "");
      this._notch.setAttribute(DATA_ACTIVE3, "");
    } else {
      this._label.removeAttribute(DATA_ACTIVE3);
      this._notch.removeAttribute(DATA_ACTIVE3);
    }
  }
  _updateFakeLabelPosition() {
    if (!this._fakeValue) {
      return;
    }
    if (this._input.value === "" && this._fakeValue.innerHTML !== "") {
      this._isFakeValueActive = true;
      this._fakeValue.setAttribute(DATA_ACTIVE3, "");
    } else {
      this._isFakeValueActive = false;
      this._fakeValue.removeAttribute(DATA_ACTIVE3);
    }
  }
  _updateClearButtonVisibility() {
    if (!this.clearButton) {
      return;
    }
    const hasSelection = this._selectionModel.selection || this._selectionModel.selections.length > 0;
    if (hasSelection) {
      manipulator_default.addStyle(this.clearButton, { display: "block" });
    } else {
      manipulator_default.addStyle(this.clearButton, { display: "none" });
    }
  }
  _updateSelectAllState() {
    const selectAllSelected = this._selectAllOption.selected;
    const allSelected = allOptionsSelected(this.options);
    if (!allSelected && selectAllSelected) {
      this._selectAllOption.deselect();
    } else if (allSelected && !selectAllSelected) {
      this._selectAllOption.select();
    }
  }
  toggle() {
    if (this._isOpen) {
      this.close();
    } else {
      this.open();
    }
  }
  open() {
    const isDisabled2 = this._config.disabled;
    const openEvent = event_handler_default.trigger(this._element, EVENT_OPEN2);
    if (this._isOpen || isDisabled2 || openEvent.defaultPrevented) {
      return;
    }
    this._openDropdown();
    this._updateDropdownWidth();
    this._setFirstActiveOption();
    this._scrollToOption(this._activeOption);
    if (this._config.selectFilter) {
      setTimeout(() => {
        this.filterInput.focus();
      }, 0);
      this._listenToSelectSearch();
      this._listenToDropdownKeydown();
    }
    this._listenToOptionsClick();
    this._listenToOutsideClick();
    this._listenToWindowResize();
    this._isOpen = true;
    this._updateLabelPosition();
    this._setInputActiveStyles();
  }
  _openDropdown() {
    this._popper = createPopper3(this._input, this._dropdownContainer, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 1]
          }
        }
      ]
    });
    this._container.appendChild(this._dropdownContainer);
    setTimeout(() => {
      this.dropdown.setAttribute(DATA_OPEN, "");
    }, 0);
  }
  _updateDropdownWidth() {
    const inputWidth = this._input.offsetWidth;
    manipulator_default.addStyle(this._dropdownContainer, { width: `${inputWidth}px` });
  }
  _setFirstActiveOption() {
    const options = this._getNavigationOptions();
    const currentActive = this._activeOption;
    if (currentActive) {
      currentActive.removeActiveStyles();
    }
    const firstSelected = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;
    if (firstSelected) {
      this._activeOption = firstSelected;
      firstSelected.setActiveStyles();
      this._activeOptionIndex = options.findIndex(
        (option) => option === firstSelected
      );
    } else {
      this._activeOption = null;
      this._activeOptionIndex = -1;
    }
  }
  _setInputActiveStyles() {
    this._input.setAttribute(DATA_FOCUSED2, "");
    selector_engine_default.findOne(SELECTOR_NOTCH2, this._wrapper).setAttribute(
      DATA_FOCUSED2,
      ""
    );
  }
  _listenToWindowResize() {
    event_handler_default.on(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleWindowResize() {
    if (this._dropdownContainer) {
      this._updateDropdownWidth();
    }
  }
  _listenToSelectSearch() {
    this.filterInput.addEventListener("input", (event) => {
      const searchTerm = event.target.value;
      const debounceTime = this._config.selectFilterDebounce;
      this._debounceFilter(searchTerm, debounceTime);
    });
  }
  _debounceFilter(searchTerm, debounceTime) {
    if (this._debounceTimeoutId) {
      clearTimeout(this._debounceTimeoutId);
    }
    this._debounceTimeoutId = setTimeout(() => {
      this._filterOptions(searchTerm);
    }, debounceTime);
  }
  _filterOptions(searchTerm) {
    const filtered = [];
    this._optionsToRender.forEach((option) => {
      const isOptionGroup = Object.prototype.hasOwnProperty.call(
        option,
        "options"
      );
      const isValidOption = !isOptionGroup && option.label.toLowerCase().includes(searchTerm.toLowerCase());
      const group = {};
      if (isOptionGroup) {
        group.label = option.label;
        group.options = this._filter(searchTerm, option.options);
        if (group.options.length > 0) {
          filtered.push(group);
        }
      }
      if (isValidOption) {
        filtered.push(option);
      }
    });
    const hasNoResultsText = this._config.selectNoResultText !== "";
    const hasFilteredOptions = filtered.length !== 0;
    if (hasFilteredOptions) {
      this._updateOptionsListTemplate(filtered);
      this._popper.forceUpdate();
      this._filteredOptionsList = this._getPlainOptions(filtered);
      if (this.hasSelectAll) {
        this._updateSelectAllState();
      }
      this._setFirstActiveOption();
    } else if (!hasFilteredOptions && hasNoResultsText) {
      const noResultsTemplate = this._getNoResultTemplate();
      this.optionsWrapper.innerHTML = noResultsTemplate;
    }
  }
  _updateOptionsListTemplate(optionsToRender) {
    const optionsWrapperContent = selector_engine_default.findOne(SELECTOR_OPTIONS_LIST, this._dropdownContainer) || selector_engine_default.findOne(SELECTOR_NO_RESULTS, this._dropdownContainer);
    const optionsListTemplate = getOptionsListTemplate(
      optionsToRender,
      this._selectAllOption,
      this._config,
      this._classes
    );
    this.optionsWrapper.removeChild(optionsWrapperContent);
    this.optionsWrapper.appendChild(optionsListTemplate);
  }
  _getNoResultTemplate() {
    return `<div class="${this._classes.noResult}" ${DATA_NO_RESULT} style="height: ${this._config.selectOptionHeight}px">${this._config.selectNoResultText}</div>`;
  }
  _filter(value, options) {
    const filterValue = value.toLowerCase();
    return options.filter(
      (option) => option.label.toLowerCase().includes(filterValue)
    );
  }
  _listenToDropdownKeydown() {
    event_handler_default.on(
      this.dropdown,
      "keydown",
      this._handleOpenKeydown.bind(this)
    );
  }
  _listenToOutsideClick() {
    this._outsideClick = this._handleOutSideClick.bind(this);
    event_handler_default.on(document, "click", this._outsideClick);
  }
  _listenToFocusChange(add = true) {
    if (add === false) {
      event_handler_default.remove(
        this._input,
        "focus",
        () => this._notch.setAttribute(DATA_FOCUSED2, "")
      );
      event_handler_default.remove(
        this._input,
        "blur",
        () => this._notch.removeAttribute(DATA_FOCUSED2)
      );
      return;
    }
    event_handler_default.on(
      this._input,
      "focus",
      () => this._notch.setAttribute(DATA_FOCUSED2, "")
    );
    event_handler_default.on(
      this._input,
      "blur",
      () => this._notch.removeAttribute(DATA_FOCUSED2)
    );
  }
  _handleOutSideClick(event) {
    const isSelectContent = this._wrapper && this._wrapper.contains(event.target);
    const isDropdown = event.target === this._dropdownContainer;
    const isDropdownContent = this._dropdownContainer && this._dropdownContainer.contains(event.target);
    let isButton;
    if (!this._toggleButton) {
      this._elementToggle = selector_engine_default.find(SELECTOR_TOGGLE2);
    }
    if (this._elementToggle) {
      this._elementToggle.forEach((button) => {
        const attributes = manipulator_default.getDataAttribute(
          button,
          "select-toggle"
        );
        if (attributes === this._element.id || this._element.classList.contains(attributes)) {
          this._toggleButton = button;
          isButton = this._toggleButton.contains(event.target);
        }
      });
    }
    if (!isSelectContent && !isDropdown && !isDropdownContent && !isButton) {
      this.close();
    }
  }
  close() {
    const closeEvent = event_handler_default.trigger(this._element, EVENT_CLOSE3);
    if (!this._isOpen || closeEvent.defaultPrevented) {
      return;
    }
    if (this._config.selectFilter && this.hasSelectAll) {
      this._resetFilterState();
      this._updateOptionsListTemplate(this._optionsToRender);
      if (this._config.multiple) {
        this._updateSelectAllState();
      }
    }
    this._removeDropdownEvents();
    this.dropdown.removeAttribute(DATA_OPEN);
    setTimeout(() => {
      this._input.removeAttribute(DATA_FOCUSED2);
      selector_engine_default.findOne(SELECTOR_NOTCH2, this._wrapper).removeAttribute(
        DATA_FOCUSED2
      );
      if (this._label && !this.hasSelection) {
        this._label.removeAttribute(DATA_ACTIVE3);
        this._notch.setAttribute(DATA_ACTIVE3, "");
        this._input.removeAttribute(DATA_ACTIVE3);
        this._notch.removeAttribute(DATA_ACTIVE3);
      }
      this._updateLabelPositionWhileClosing();
    }, 0);
    setTimeout(() => {
      if (this._container && this._dropdownContainer.parentNode === this._container) {
        this._container.removeChild(this._dropdownContainer);
      }
      this._popper.destroy();
      this._isOpen = false;
      event_handler_default.off(this.dropdown, "transitionend");
    }, ANIMATION_TRANSITION_TIME);
  }
  _resetFilterState() {
    this.filterInput.value = "";
    this._filteredOptionsList = null;
  }
  _removeDropdownEvents() {
    event_handler_default.off(document, "click", this._outsideClick);
    if (this._config.selectFilter) {
      event_handler_default.off(this.dropdown, "keydown");
    }
    event_handler_default.off(this.optionsWrapper, "click");
  }
  _addMutationObserver() {
    this._mutationObserver = new MutationObserver(() => {
      if (this._wrapper) {
        this._updateSelections();
        this._updateDisabledState();
      }
    });
    this._observeMutationObserver();
  }
  _updateSelections() {
    this._optionsToRender = this._getOptionsToRender(this._element);
    this._plainOptions = this._getPlainOptions(this._optionsToRender);
    this._selectionModel.clear();
    this._setDefaultSelections();
    this._updateInputValue();
    this._updateFakeLabelPosition();
    this._updateLabelPosition();
    this._updateClearButtonVisibility();
    if (this.hasSelectAll) {
      this._updateSelectAllState();
    }
    const hasFilterValue = this._config.filter && this.filterInput && this.filterInput.value;
    if (this._isOpen && !hasFilterValue) {
      this._updateOptionsListTemplate(this._optionsToRender);
      this._setFirstActiveOption();
    } else if (this._isOpen && hasFilterValue) {
      this._filterOptions(this.filterInput.value);
      this._setFirstActiveOption();
    } else {
      this._dropdownContainer = getDropdownTemplate(
        this._dropdownContainerId,
        this._config,
        this._input.offsetWidth,
        this._dropdownHeight,
        this._selectAllOption,
        this._optionsToRender,
        this._customContent,
        this._classes
      );
    }
  }
  _updateDisabledState() {
    const input = selector_engine_default.findOne(SELECTOR_INPUT, this._wrapper);
    if (this._element.hasAttribute("disabled")) {
      this._config.disabled = true;
      input.setAttribute("disabled", "");
      input.setAttribute(DATA_DISABLED, "");
    } else {
      this._config.disabled = false;
      input.removeAttribute("disabled");
      input.removeAttribute(DATA_DISABLED);
    }
  }
  _observeMutationObserver() {
    if (!this._mutationObserver) {
      return;
    }
    this._mutationObserver.observe(this._element, {
      attributes: true,
      childList: true,
      characterData: true,
      subtree: true
    });
  }
  _disconnectMutationObserver() {
    if (this.mutationObserver) {
      this._mutationObserver.disconnect();
      this._mutationObserver = null;
    }
  }
  _createSelectAllOption() {
    const id = this._selectAllId;
    const nativeOption = null;
    const multiple = true;
    const value = "select-all";
    const label = this._config.selectAllLabel;
    const selected = allOptionsSelected(this.options);
    const disabled = false;
    const hidden = false;
    const secondaryText = null;
    const groupId = null;
    const icon = null;
    return new select_option_default(
      id,
      nativeOption,
      multiple,
      value,
      label,
      selected,
      disabled,
      hidden,
      secondaryText,
      groupId,
      icon
    );
  }
  dispose() {
    this._removeComponentEvents();
    this._destroyMaterialSelect();
    this._listenToFocusChange(false);
    data_default.removeData(this._element, DATA_KEY20);
  }
  _removeComponentEvents() {
    event_handler_default.off(this.input, "click");
    event_handler_default.off(this.wrapper, this._handleKeydown.bind(this));
    event_handler_default.off(this.clearButton, "click");
    event_handler_default.off(this.clearButton, "keydown");
    event_handler_default.off(window, "resize", this._handleWindowResize.bind(this));
  }
  _destroyMaterialSelect() {
    if (this._isOpen) {
      this.close();
    }
    this._destroyMaterialTemplate();
  }
  _destroyMaterialTemplate() {
    const wrapperParent = this._wrapper.parentNode;
    const labels = selector_engine_default.find("label", this._wrapper);
    wrapperParent.appendChild(this._element);
    labels.forEach((label) => {
      wrapperParent.appendChild(label);
    });
    labels.forEach((label) => {
      label.removeAttribute(DATA_ACTIVE3);
    });
    manipulator_default.removeClass(this._element, this._classes.initialized);
    this._element.removeActiveStyles(DATA_SELECT_INIT);
    wrapperParent.removeChild(this._wrapper);
  }
  setValue(value) {
    this.options.filter((option) => option.selected).forEach((selection) => selection.nativeOption.selected = false);
    const isMultipleValue = Array.isArray(value);
    if (isMultipleValue) {
      value.forEach((selectionValue) => {
        this._selectByValue(selectionValue);
      });
    } else {
      this._selectByValue(value);
    }
    this._updateSelections();
  }
  _selectByValue(value) {
    const correspondingOption = this.options.find(
      (option) => option.value === value
    );
    if (!correspondingOption) {
      return false;
    }
    correspondingOption.nativeOption.selected = true;
    return true;
  }
  static jQueryInterface(config, options) {
    return this.each(function() {
      let data = data_default.getData(this, DATA_KEY20);
      const _config = typeof config === "object" && config;
      if (!data && /dispose/.test(config)) {
        return;
      }
      if (!data) {
        data = new Select(this, _config);
      }
      if (typeof config === "string") {
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](options);
      }
    });
  }
  static getInstance(element2) {
    return data_default.getData(element2, DATA_KEY20);
  }
  static getOrCreateInstance(element2, config = {}) {
    return this.getInstance(element2) || new this(element2, typeof config === "object" ? config : null);
  }
};
var select_default = Select;
var $ = getjQuery();
selector_engine_default.find(SELECTOR_SELECT).forEach((select) => {
  let instance = Select.getInstance(select);
  if (!instance) {
    instance = new Select(select);
  }
});
onDOMContentLoaded(() => {
  if ($) {
    const JQUERY_NO_CONFLICT = $.fn[NAME21];
    $.fn[NAME21] = Select.jQueryInterface;
    $.fn[NAME21].Constructor = Select;
    $.fn[NAME21].noConflict = () => {
      $.fn[NAME21] = JQUERY_NO_CONFLICT;
      return Select.jQueryInterface;
    };
  }
});

// node_modules/tw-elements/dist/src/js/components/chips/templates.js
var getInputField = ({ inputID, labelText }, classes) => {
  return `<div data-te-chips-input-wrapper data-te-input-wrapper-init class="${classes.chipsInputWrapper}">
      <input
          type="text"
          class="${classes.chipsInput}"
          id="${inputID}"
          placeholder="Example label" />
        <label
          for="${inputID}"
          class="${classes.chipsLabel}"
          >${labelText}
        </label>

        <div data-te-input-notch-ref class="${classes.chipsNotchesWrapper}">
        <div class="${classes.chipsNotchesLeading}" data-te-input-notch-leading-ref style="width: 9px;"></div>
        <div class="${classes.chipsNotchesMiddle}" data-te-input-notch-middle-ref style="width: 87.2px;"></div>
        <div class="${classes.chipsNotchesTrailing}" data-te-input-notch-trailing-ref></div>
      </div>
    </div>`;
};
var getChip = ({ text, iconSVG }, classes) => {
  return `<div data-te-chip-init data-te-ripple-init class="${classes.chipElement}">
    <span data-te-chip-text>${text}</span> 
      <span data-te-chip-close class="${classes.chipCloseIcon}">
        ${iconSVG}
      </span>
  </div>`;
};

// node_modules/tw-elements/dist/src/js/components/chips/chip.js
var NAME22 = "chip";
var DATA_KEY21 = `te.${NAME22}`;
var ATTR_CHIP_CLOSE = "data-te-chip-close";
var ATTR_SELECTOR_CHIP_INIT = "[data-te-chip-init]";
var ATTR_SELECTOR_CHIP_CLOSE = `[${ATTR_CHIP_CLOSE}]`;
var EVENT_DELETE = "delete.te.chips";
var EVENT_SELECT2 = "select.te.chip";
var defaultIcon2 = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-3 h-3"> <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>`;
var DefaultType19 = {
  text: "string",
  closeIcon: "boolean",
  img: "object",
  iconSVG: "string"
};
var Default19 = {
  text: "",
  closeIcon: false,
  img: { path: "", alt: "" },
  iconSVG: defaultIcon2
};
var DefaultClasses13 = {
  icon: "float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:text-[#8b8b8b] transition-all duration-200 ease-in-out",
  chipElement: "flex justify-between items-center h-[32px] leading-loose py-[5px] px-[12px] mr-4 my-[5px] text-[13px] font-normal text-[#4f4f4f] cursor-pointer bg-[#eceff1] dark:text-white dark:bg-neutral-600 rounded-[16px] transition-[opacity] duration-300 ease-linear [word-wrap: break-word] shadow-none normal-case hover:!shadow-none active:bg-[#cacfd1] inline-block font-medium leading-normal text-[#4f4f4f] text-center no-underline align-middle cursor-pointer select-none border-[.125rem] border-solid border-transparent py-1.5 px-3 text-xs rounded",
  chipCloseIcon: "w-4 float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:fill-[#8b8b8b] dark:fill-gray-400 dark:hover:fill-gray-100 transition-all duration-200 ease-in-out"
};
var DefaultClassesType13 = {
  icon: "string",
  chipElement: "string",
  chipCloseIcon: "string"
};
var Chip = class {
  constructor(element2, data = {}, classes) {
    this._element = element2;
    this._options = this._getConfig(data);
    this._classes = this._getClasses(classes);
  }
  // Getters
  static get NAME() {
    return NAME22;
  }
  // Public
  init() {
    this._appendCloseIcon();
    this._handleDelete();
    this._handleTextChip();
    this._handleClickOnChip();
  }
  dispose() {
    this._element = null;
    this._options = null;
    event_handler_default.off(this._element, "click");
  }
  appendChip() {
    const { text, closeIcon, iconSVG } = this._options;
    const chip = getChip({ text, closeIcon, iconSVG }, this._classes);
    return chip;
  }
  // Private
  _appendCloseIcon(el = this._element) {
    if (selector_engine_default.find(ATTR_SELECTOR_CHIP_CLOSE, this._element).length > 0)
      return;
    if (this._options.closeIcon) {
      const createIcon = element("span");
      createIcon.classList = this._classes.icon;
      createIcon.setAttribute(ATTR_CHIP_CLOSE);
      createIcon.innerHTML = this._options.iconSVG;
      el.insertAdjacentElement("beforeend", createIcon);
    }
  }
  _handleClickOnChip() {
    event_handler_default.on(this._element, "click", (event) => {
      const { textContent } = event.target;
      const obj = {};
      obj.tag = textContent.trim();
      event_handler_default.trigger(EVENT_SELECT2, { event, obj });
    });
  }
  _handleDelete() {
    const deleteElement = selector_engine_default.find(
      ATTR_SELECTOR_CHIP_CLOSE,
      this._element
    );
    if (deleteElement.length === 0)
      return;
    event_handler_default.on(this._element, "click", ATTR_SELECTOR_CHIP_CLOSE, () => {
      event_handler_default.trigger(this._element, EVENT_DELETE);
      this._element.remove();
    });
  }
  _handleTextChip() {
    if (this._element.innerText !== "")
      return;
    this._element.innerText = this._options.text;
  }
  _getConfig(options) {
    const config = {
      ...Default19,
      ...manipulator_default.getDataAttributes(this._element),
      ...options
    };
    typeCheckConfig(NAME22, config, DefaultType19);
    return config;
  }
  _getClasses(classes) {
    const dataAttributes = manipulator_default.getDataClassAttributes(this._element);
    classes = {
      ...DefaultClasses13,
      ...dataAttributes,
      ...classes
    };
    typeCheckConfig(NAME22, classes, DefaultClassesType13);
    return classes;
  }
  static getInstance(element2) {
    return data_default.getData(element2, DATA_KEY21);
  }
  static getOrCreateInstance(element2, config = {}) {
    return this.getInstance(element2) || new this(element2, typeof config === "object" ? config : null);
  }
};
event_handler_default.on(window, "DOMContentLoaded", () => {
  selector_engine_default.find(ATTR_SELECTOR_CHIP_INIT).forEach((chip) => {
    let instance = Chip.getInstance(chip);
    if (!instance) {
      instance = new Chip(chip);
    }
    return instance.init();
  });
});
var chip_default = Chip;

// node_modules/tw-elements/dist/src/js/components/chips/index.js
var NAME23 = "chips";
var ATTR_NAME2 = `data-te-${NAME23}`;
var DATA_KEY22 = `te.${NAME23}`;
var ATTR_CHIPS_INIT = `${ATTR_NAME2}-init`;
var ATTR_CHIPS_ACTIVE = `${ATTR_NAME2}-active`;
var ATTR_CHIPS_INITIAL = `${ATTR_NAME2}-initial`;
var ATTR_CHIPS_PLACEHOLDER = `${ATTR_NAME2}-placeholder`;
var ATTR_CHIPS_WRAPPER = `${ATTR_NAME2}-input-wrapper`;
var ATTR_CHIP_INIT = "data-te-chip-init";
var ATTR_CHIP_CLOSE2 = "data-te-chip-close";
var ATTR_CHIP_TEXT = "data-te-chip-text";
var ATTR_SELECTOR_CHIPS_INIT = `[${ATTR_CHIPS_INIT}]`;
var ATTR_SELECTOR_CHIPS_ACTIVE = `[${ATTR_CHIPS_ACTIVE}]`;
var ATTR_SELECTOR_CHIP_INIT2 = `[${ATTR_CHIP_INIT}]`;
var ATTR_SELECTOR_CHIP_ACTIVE = `${ATTR_SELECTOR_CHIP_INIT2}${ATTR_SELECTOR_CHIPS_ACTIVE}`;
var ATTR_SELECTOR_CLOSE = `[${ATTR_CHIP_CLOSE2}]`;
var ATTR_SELECTOR_CHIPS_WRAPPER = `[${ATTR_CHIPS_WRAPPER}]`;
var ATTR_SELECTOR_CHIP_TEXT = `[${ATTR_CHIP_TEXT}]`;
var ATTR_SELECTOR_CHIPS_PLACEHOLDER = `[${ATTR_CHIPS_PLACEHOLDER}]`;
var DATA_NOTCH_LEADING2 = "data-te-input-notch-leading-ref";
var DATA_NOTCH_MIDDLE2 = "data-te-input-notch-middle-ref";
var SELECTOR_NOTCH_LEADING2 = `[${DATA_NOTCH_LEADING2}]`;
var SELECTOR_NOTCH_MIDDLE2 = `[${DATA_NOTCH_MIDDLE2}]`;
var ATTR_INPUT_STATE_ACTIVE = "data-te-input-state-active";
var ATTR_SELECTOR_INPUT_NOTCH_REF = "[data-te-input-notch-ref]";
var EVENT_ADD = "add.te.chips";
var EVENT_ARROW_DOWN = "arrowDown.te.chips";
var EVENT_ARROW_LEFT = "arrowLeft.te.chips";
var EVENT_ARROW_RIGHT = "arrowRight.te.chips";
var EVENT_ARROW_UP = "arrowUp.te.chips";
var EVENT_DELETE2 = "delete.te.chips";
var EVENT_SELECT3 = "select.te.chips";
var DefaultType20 = {
  inputID: "string",
  parentSelector: "string",
  initialValues: "array",
  editable: "boolean",
  labelText: "string"
};
var Default20 = {
  inputID: getUID("chips-input-"),
  parentSelector: "",
  initialValues: [{ tag: "init1" }, { tag: "init2" }],
  editable: false,
  labelText: "Example label"
};
var DefaultClasses14 = {
  opacity: "opacity-0",
  inputWrapperPadding: "p-[5px]",
  transition: "transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]",
  contentEditable: "outline-none !border-[3px] !border-solid !border-[#b2b3b4]",
  chipsInputWrapper: "relative flex items-center flex-wrap transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]",
  chipsInput: "peer block min-h-[auto] w-[150px] rounded border-0 bg-transparent py-[0.32rem] px-3 leading-[1.6] outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0",
  chipsLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate pt-[0.37rem] leading-[1.6] text-gray-500 transition-all duration-200 ease-out peer-focus:-translate-y-[0.9rem] peer-focus:scale-[0.8] peer-focus:text-blue-600 peer-data-[te-input-state-active]:-translate-y-[0.9rem] peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200",
  chipsNotchesWrapper: "group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none",
  chipsNotchesLeading: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0 border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-blue-600",
  chipsNotchesMiddle: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-blue-600",
  chipsNotchesTrailing: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0 border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-blue-600"
};
var DefaultClassesType14 = {
  opacity: "string",
  inputWrapperPadding: "string",
  transition: "string",
  contentEditable: "string",
  chipsInputWrapper: "string",
  chipsInput: "string",
  chipsLabel: "string",
  chipsNotchesWrapper: "string",
  chipsNotchesLeading: "string",
  chipsNotchesMiddle: "string",
  chipsNotchesTrailing: "string"
};
var ChipsInput = class extends chip_default {
  constructor(element2, data = {}, classes) {
    super(element2, data);
    __publicField(this, "_handleBlurInput", ({ target }) => {
      if (target.value.length > 0) {
        this._handleCreateChip(target, target.value);
      }
      if (this.allChips.length > 0) {
        target.setAttribute(ATTR_CHIPS_ACTIVE, "");
        this.input.setAttribute(ATTR_INPUT_STATE_ACTIVE, "");
        selector_engine_default.findOne(
          ATTR_SELECTOR_INPUT_NOTCH_REF,
          this.input.parentNode
        ).setAttribute(ATTR_INPUT_STATE_ACTIVE, "");
        this.chipsInputWrapper.classList.add(
          ...this._classes.inputWrapperPadding.split(" ")
        );
      } else {
        target.removeAttribute(ATTR_CHIPS_ACTIVE);
        this.input.removeAttribute(ATTR_INPUT_STATE_ACTIVE);
        selector_engine_default.findOne(
          ATTR_SELECTOR_INPUT_NOTCH_REF,
          this.input.parentNode
        ).removeAttribute(ATTR_INPUT_STATE_ACTIVE);
        this.chipsInputWrapper.classList.remove(
          ...this._classes.inputWrapperPadding.split(" ")
        );
      }
      this.allChips.forEach((chip) => chip.removeAttribute(ATTR_CHIPS_ACTIVE));
    });
    this._element = element2;
    this._label = null;
    this._labelWidth = 0;
    this._labelMarginLeft = 0;
    this._notchLeading = null;
    this._notchMiddle = null;
    if (this._element) {
      data_default.setData(element2, DATA_KEY22, this);
    }
    this._options = this._getConfig(data);
    this._classes = this._getClasses(classes);
    this.numberClicks = 0;
    this.init();
  }
  // Getters
  static get NAME() {
    return NAME23;
  }
  get activeChip() {
    return selector_engine_default.findOne(ATTR_SELECTOR_CHIP_ACTIVE, this._element);
  }
  get input() {
    return selector_engine_default.findOne("input", this._element);
  }
  get allChips() {
    return selector_engine_default.find(ATTR_SELECTOR_CHIP_INIT2, this._element);
  }
  get chipsInputWrapper() {
    return selector_engine_default.findOne(ATTR_SELECTOR_CHIPS_WRAPPER, this._element);
  }
  // Public
  init() {
    this._setChipsClass();
    this._appendInputToElement(ATTR_CHIPS_PLACEHOLDER);
    this._handleInitialValue();
    this._handleInputText();
    this._handleKeyboard();
    this._handleChipsOnSelect();
    this._handleEditable();
    this._handleChipsFocus();
    this._handleClicksOnChips();
    this._getLabelData();
    this._getLabelWidth();
    this._getNotchData();
    this._applyNotch();
  }
  dispose() {
    this._element = null;
    this._options = null;
  }
  // Private
  _getNotchData() {
    this._notchMiddle = selector_engine_default.findOne(
      SELECTOR_NOTCH_MIDDLE2,
      this._element
    );
    this._notchLeading = selector_engine_default.findOne(
      SELECTOR_NOTCH_LEADING2,
      this._element
    );
  }
  _getLabelData() {
    this._label = selector_engine_default.findOne("label", this._element);
  }
  _getLabelWidth() {
    this._labelWidth = this._label.clientWidth * 0.8 + 8;
  }
  _applyNotch() {
    this._notchMiddle.style.width = `${this._labelWidth}px`;
    this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`;
    if (this._label === null)
      return;
    this._label.style.marginLeft = `${this._labelMarginLeft}px`;
  }
  _setChipsClass() {
    this._element.setAttribute(ATTR_CHIPS_INIT, "");
  }
  _handleDeleteEvents(event) {
    const [last] = this.allChips.slice(-1);
    if (this.activeChip === null) {
      last.remove();
      this._handleEvents(event, EVENT_DELETE2);
    } else {
      const index = this.allChips.findIndex((chip) => chip === this.activeChip);
      const activeChipAfter = this._handleActiveChipAfterRemove(index);
      const arr = [];
      if (this.activeChip === null)
        return;
      this.activeChip.remove();
      this._handleEvents(event, EVENT_DELETE2);
      this.numberClicks = index;
      activeChipAfter.setAttribute(ATTR_CHIPS_ACTIVE, "");
      this.allChips.forEach((chip) => {
        if (chip.hasAttribute(ATTR_CHIPS_ACTIVE)) {
          arr.push(chip);
          if (arr.length > 1) {
            this.allChips.forEach((chip2) => chip2.remove());
          }
        }
      });
    }
  }
  _handleUpEvents(event) {
    this.numberClicks += 1;
    if (this.numberClicks === this.allChips.length + 1)
      this.numberClicks = 0;
    this._handleRightKeyboardArrow(this.numberClicks);
    this._handleEvents(event, EVENT_ARROW_RIGHT);
    this._handleEvents(event, EVENT_ARROW_UP);
  }
  _handleDownEvents(event) {
    this.numberClicks -= 1;
    if (this.numberClicks <= 0)
      this.numberClicks = this.allChips.length;
    this._handleLeftKeyboardArrow(this.numberClicks);
    this._handleEvents(event, EVENT_ARROW_LEFT);
    this._handleEvents(event, EVENT_ARROW_DOWN);
  }
  _keyboardEvents(event) {
    const { target, keyCode, ctrlKey } = event;
    if (target.value.length > 0 || this.allChips.length === 0)
      return;
    if (keyCode === BACKSPACE || keyCode === DELETE) {
      this._handleDeleteEvents(event);
    } else if (keyCode === RIGHT_ARROW || keyCode === UP_ARROW) {
      this._handleUpEvents(event);
    } else if (keyCode === LEFT_ARROW || keyCode === DOWN_ARROW) {
      this._handleDownEvents(event);
    } else if (keyCode === 65 && ctrlKey) {
      this._handleAddActiveClass();
    }
  }
  _handleKeyboard() {
    event_handler_default.on(
      this.input,
      "keydown",
      (event) => this._keyboardEvents(event)
    );
  }
  _handleEditable() {
    const { editable } = this._options;
    if (!editable)
      return;
    this.allChips.forEach((chip) => {
      event_handler_default.on(chip, "dblclick", (e) => {
        const close = selector_engine_default.findOne(ATTR_SELECTOR_CLOSE, chip);
        chip.classList.add(...this._classes.contentEditable.split(" "));
        chip.contentEditable = true;
        chip.focus();
        setTimeout(() => {
          manipulator_default.addStyle(close, { display: "none" });
        }, 200);
        close.classList.add(...this._classes.opacity.split(" "));
        const obj = {};
        obj.tag = e.target.textContent;
        event_handler_default.trigger(chip, EVENT_SELECT3, {
          event: e,
          allChips: this.allChips
        });
      });
      event_handler_default.on(document, "click", ({ target }) => {
        const close = selector_engine_default.findOne(ATTR_SELECTOR_CLOSE, chip);
        const chipText = selector_engine_default.findOne(ATTR_SELECTOR_CHIP_TEXT, chip);
        const isContainer = target === chip;
        const isContainerContent = chip && chip.contains(target);
        if (!isContainer && !isContainerContent) {
          chip.contentEditable = false;
          chip.classList.remove(...this._classes.contentEditable.split(" "));
          if (chipText.textContent !== "") {
            setTimeout(() => {
              manipulator_default.addStyle(close, { display: "block" });
              close.classList.remove(...this._classes.opacity.split(" "));
            }, 160);
          }
        }
        if (chipText.textContent === "") {
          setTimeout(() => {
            chip.classList.add(...this._classes.opacity.split(" "));
          }, 200);
          setTimeout(() => {
            chip.remove();
          }, 300);
        }
      });
    });
  }
  _handleRemoveActiveClass() {
    this.allChips.forEach((chip) => chip.removeAttribute(ATTR_CHIPS_ACTIVE));
  }
  _handleAddActiveClass() {
    this.allChips.forEach((chip) => chip.setAttribute(ATTR_CHIPS_ACTIVE, ""));
  }
  _handleRightKeyboardArrow(num) {
    this._handleRemoveActiveClass();
    if (num === 0)
      num = 1;
    this._handleAddActiveClassWithKebyboard(num);
  }
  _handleLeftKeyboardArrow(num) {
    this._handleRemoveActiveClass();
    this._handleAddActiveClassWithKebyboard(num);
  }
  _handleActiveChipAfterRemove(index) {
    const chipIndex = index === 0 ? 1 : index - 1;
    return this.allChips[chipIndex];
  }
  _handleClicksOnChips() {
    event_handler_default.on(this._element, "click", () => {
      if (this.allChips.length === 0) {
        this.chipsInputWrapper.classList.remove(
          ...this._classes.inputWrapperPadding.split(" ")
        );
        this.input.removeAttribute(ATTR_CHIPS_ACTIVE);
      }
    });
  }
  _handleTextContent() {
    const arr = [];
    this.allChips.forEach((chip) => arr.push({ tag: chip.textContent.trim() }));
    return arr;
  }
  _handleEvents(event, eventName) {
    const arr = this._handleTextContent();
    const filterActive = this.allChips.filter(
      (chip) => chip.hasAttribute(ATTR_CHIPS_ACTIVE) && chip
    );
    event_handler_default.trigger(this._element, eventName, {
      event,
      allChips: this.allChips,
      arrOfObjects: arr,
      active: filterActive,
      activeObj: {
        tag: filterActive.length <= 0 ? "" : filterActive[0].textContent.trim()
      }
    });
  }
  _handleChipsFocus() {
    event_handler_default.on(this._element, "click", ({ target: { attributes } }) => {
      const attrList = [...attributes];
      if (attrList.includes(ATTR_CHIP_INIT) || attrList.includes(ATTR_CHIP_CLOSE2) || attrList.includes(ATTR_CHIP_TEXT)) {
        return;
      }
      this.input.focus();
    });
  }
  _handleInitialValue() {
    this._appendInputToElement(ATTR_CHIPS_INITIAL);
    if (this._element.hasAttribute(ATTR_CHIPS_INITIAL)) {
      const { initialValues } = this._options;
      initialValues.forEach(
        ({ tag }) => this._handleCreateChip(this.input, tag)
      );
      selector_engine_default.findOne(
        ATTR_SELECTOR_INPUT_NOTCH_REF,
        this.input.parentNode
      ).setAttribute(ATTR_INPUT_STATE_ACTIVE, "");
      this.input.setAttribute(ATTR_CHIPS_ACTIVE, "");
      this.input.setAttribute(ATTR_INPUT_STATE_ACTIVE, "");
    }
    if (this.allChips.length > 0) {
      this.chipsInputWrapper.classList.add(
        ...this._classes.inputWrapperPadding.split(" ")
      );
      this.chipsInputWrapper.classList.add(
        ...this._classes.transition.split(" ")
      );
    }
  }
  _handleKeysInputToElement(event) {
    const { keyCode, target } = event;
    if (target.hasAttribute(ATTR_CHIP_INIT)) {
      const close = selector_engine_default.findOne(ATTR_SELECTOR_CLOSE, target);
      if (keyCode === ENTER) {
        target.contentEditable = false;
        target.classList.remove(...this._classes.contentEditable.split(" "));
        if (target.textContent !== "") {
          setTimeout(() => {
            manipulator_default.addStyle(close, { display: "block" });
            close.classList.remove(...this._classes.opacity.split(" "));
          }, 160);
        } else if (target.textContent === "") {
          setTimeout(() => {
            target.classList.add(...this._classes.opacity.split(" "));
          }, 200);
          setTimeout(() => {
            target.remove();
          }, 300);
        }
      }
      return;
    }
    if (keyCode === ENTER) {
      if (target.value === "")
        return;
      this._handleCreateChip(target, target.value);
      this._handleRemoveActiveClass();
      this.numberClicks = this.allChips.length + 1;
      this._handleEvents(event, EVENT_ADD);
    }
    if (this.allChips.length > 0) {
      this.chipsInputWrapper.classList.add(
        ...this._classes.inputWrapperPadding.split(" ")
      );
      this.chipsInputWrapper.classList.add(
        ...this._classes.transition.split(" ")
      );
    } else {
      this.chipsInputWrapper.classList.remove(
        ...this._classes.inputWrapperPadding.split(" ")
      );
    }
  }
  _handleInputText() {
    const placeholder = selector_engine_default.findOne(
      ATTR_SELECTOR_CHIPS_PLACEHOLDER,
      this._element
    );
    event_handler_default.on(
      this._element,
      "keyup",
      placeholder,
      (e) => this._handleKeysInputToElement(e)
    );
    event_handler_default.on(this.input, "blur", (e) => this._handleBlurInput(e));
  }
  _appendInputToElement(selector) {
    if (!this._element.hasAttribute(selector))
      return;
    const inputField = getInputField(this._options, this._classes);
    this._element.insertAdjacentHTML("beforeend", inputField);
  }
  _handleCreateChip(target, value) {
    const divElement = element("div");
    const instance = chip_default.getInstance(divElement);
    const divWithChips = new chip_default(instance, { text: value }, this._classes);
    if (this._options.parentSelector !== "") {
      const parent = document.querySelector(this._options.parentSelector);
      parent.insertAdjacentHTML("beforeend", divWithChips.appendChip());
    } else {
      target.insertAdjacentHTML("beforebegin", divWithChips.appendChip());
    }
    target.value = "";
    selector_engine_default.find(ATTR_SELECTOR_CHIP_INIT2).forEach((chip) => {
      let instance2 = chip_default.getInstance(chip);
      if (!instance2) {
        instance2 = new chip_default(chip, {}, this._classes);
      }
      return instance2.init();
    });
    this._handleEditable();
  }
  _handleChipsOnSelect() {
    this.allChips.forEach((chip) => {
      event_handler_default.on(this._element, "click", (e) => {
        event_handler_default.trigger(chip, EVENT_SELECT3, {
          event: e,
          allChips: this.allChips
        });
      });
    });
  }
  _handleAddActiveClassWithKebyboard(num) {
    let chip;
    if (this.allChips[num - 1] === void 0) {
      chip = this.allChips[num - 2];
    } else {
      chip = this.allChips[num - 1];
    }
    chip.setAttribute(ATTR_CHIPS_ACTIVE);
  }
  _getConfig(options) {
    const config = {
      ...Default20,
      ...manipulator_default.getDataAttributes(this._element),
      ...options
    };
    typeCheckConfig(NAME23, config, DefaultType20);
    return config;
  }
  _getClasses(classes) {
    const dataAttributes = manipulator_default.getDataClassAttributes(this._element);
    classes = {
      ...DefaultClasses14,
      ...dataAttributes,
      ...classes
    };
    typeCheckConfig(NAME23, classes, DefaultClassesType14);
    return classes;
  }
  static getInstance(element2) {
    return data_default.getData(element2, DATA_KEY22);
  }
  static getOrCreateInstance(element2, config = {}) {
    return this.getInstance(element2) || new this(element2, typeof config === "object" ? config : null);
  }
};
var chips_default = ChipsInput;
event_handler_default.on(window, "DOMContentLoaded", () => {
  selector_engine_default.find(ATTR_SELECTOR_CHIPS_INIT).forEach((chip) => {
    let instance = ChipsInput.getInstance(chip);
    if (!instance) {
      instance = new ChipsInput(chip);
    }
    return instance;
  });
});
export {
  alert_default as Alert,
  animate_default as Animate,
  button_default as Button,
  carousel_default as Carousel,
  chips_default as ChipsInput,
  collapse_default as Collapse,
  datepicker_default as Datepicker,
  dropdown_default as Dropdown,
  input_default as Input,
  modal_default as Modal,
  offcanvas_default as Offcanvas,
  popover_default as Popover,
  ripple_default as Ripple,
  scrollspy_default as ScrollSpy,
  select_default as Select,
  sidenav_default as Sidenav,
  stepper_default as Stepper,
  tab_default as Tab,
  timepicker_default as Timepicker,
  toast_default as Toast,
  tooltip_default as Tooltip
};
/*! Bundled license information:

perfect-scrollbar/dist/perfect-scrollbar.esm.js:
  (*!
   * perfect-scrollbar v1.5.3
   * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
   * Licensed under MIT
   *)
*/
//# sourceMappingURL=tw-elements_dist_src_js.js.map
